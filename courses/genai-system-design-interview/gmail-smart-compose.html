<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gmail Smart Compose - Genai System Design Interview</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Open Sans', Arial, sans-serif;
    font-size: 16px;
    line-height: 1.6;
    color: #454545;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    font-size: 2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.2;
}

h2 {
    font-size: 1.5em;
    margin: 1.2em 0 0.6em 0;
    line-height: 1.3;
}

h3 {
    font-size: 1.2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.4;
}

p {
    margin: 0.8em 0;
}

a {
    color: #0077aa;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

ul, ol {
    margin: 0.8em 0;
    padding-left: 2em;
}

li {
    margin: 0.4em 0;
}

code, pre {
    background: #f4f4f4;
    border: 1px solid #ddd;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
}

code {
    padding: 2px 5px;
}

pre {
    padding: 10px;
    overflow-x: auto;
    margin: 1em 0;
}

pre code {
    border: none;
    padding: 0;
}

img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 1.5em auto;
}

figure {
    margin: 1.5em 0;
    text-align: center;
}

figcaption {
    font-style: italic;
    font-size: 0.9em;
    color: #666;
    margin-top: 0.5em;
}

.chapter-number {
    font-weight: bold;
    color: #0077aa;
}

.nav {
    margin: 2em 0;
    padding: 1em 0;
    border-top: 1px solid #ddd;
    border-bottom: 1px solid #ddd;
}

.nav a {
    margin-right: 1em;
}

.toc {
    list-style: none;
    padding: 0;
}

.toc li {
    margin: 0.8em 0;
}

.course-section {
    margin: 2em 0;
}

.course-title {
    font-size: 1.3em;
    font-weight: bold;
    color: #0077aa;
    margin: 1.5em 0 0.8em 0;
}

.metadata {
    font-size: 0.9em;
    color: #888;
    margin: 2em 0 1em 0;
}

.breadcrumb {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 1em;
}

.breadcrumb a {
    color: #0077aa;
}

@media (max-width: 600px) {
    body {
        padding: 10px;
    }

    h1 {
        font-size: 1.5em;
    }

    h2 {
        font-size: 1.3em;
    }
}</style>
</head>
<body>
    <div class="breadcrumb">
        <a href="../../index.html">Home</a> /
        <a href="../genai-system-design-interview.html">Genai System Design Interview</a> /
        Gmail Smart Compose
    </div>

    <div class="nav">
        <a href="../genai-system-design-interview.html">← Course Contents</a>
        <a href="introduction-and-overview.html">← Previous</a>
        <a href="google-translate.html">Next →</a>
    </div>

    <main>
        <h1>
            <span class="chapter-number">02</span> Gmail Smart Compose
        </h1>

        <div class="metadata">
            <a href="https://bytebytego.com/courses/genai-system-design-interview/gmail-smart-compose" target="_blank" rel="noopener">Original source</a>
        </div>

        <article>
            <header><strong class="style_chapter__grtAe">02</strong><h1>Gmail Smart Compose</h1></header><h2 id="introduction">Introduction</h2>
<p>Gmail's Smart Compose feature [1] assists users by suggesting the next few words as they write an email. This chapter explores this feature and examines the Transformer architecture that powers most generative systems.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a Gmail compose window showing an email being drafted.  The window's title bar displays 'Taco Tuesdays' and close ('X') buttons. Below, the 'To' field shows 'Ethan Clarke' as the recipient.  A 'Cc Bcc' field is also visible, though empty. The 'Subject' line reads 'Taco Tuesdays.' The email body begins with 'Hey Ethan!' followed by 'What's up? Haven't seen you for a whil...'  A small, rectangular 'tab' button is present at the end of this line. A curved, reddish-brown arrow originates from near the 'tab' button and points to the text 'Suggested words' outside the email window, indicating that the 'tab' button likely triggers a suggestion of words to complete the sentence, providing contextual word completion or auto-suggestions based on the existing text.  The Gmail logo is visible in the top left corner." loading="lazy" width="496" height="200" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-1-6JKF7SFG.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 1: Gmail's Smart Compose feature</figcaption></div></figure>
<h2 id="clarifying-requirements">Clarifying Requirements</h2>
<p>Here is a typical interaction between a candidate and an interviewer:</p>
<p><strong>Candidate:</strong> Different users might have different writing styles. Is the system expected to make personalized suggestions?<br>
<strong>Interviewer:</strong> For simplicity, let's not include personalization.</p>
<p><strong>Candidate:</strong> Should the system suggest the next few words only when it is confident in its prediction?<br>
<em><strong>Interviewer:</strong> Yes.</em></p>
<p><strong>Candidate:</strong> The email dataset must be sufficiently large to train a model. Do we know the approximate size of the data?<br>
<strong>Interviewer:</strong> Assume our dataset consists of around one billion email messages.</p>
<p><strong>Candidate:</strong> There are different parts of data to utilize when making suggestions. For example, a user's past emails or the subject of the current email. To keep it simple, can I only utilize the email's body as the context?<br>
<strong>Interviewer:</strong> Good point. In practice, though, we use more than what the user has typed in the current email. Let's start by using the body of the email. If we have more time, we can expand the context to include other relevant information.</p>
<p><strong>Candidate:</strong> What languages should the system support?<br>
<strong>Interviewer:</strong> Let's begin with English.</p>
<p><strong>Candidate:</strong> Do we need to ensure the system is not biased?<br>
<strong>Interviewer:</strong> This is an important requirement for this system. The system should not make biased assumptions in providing its suggestions.</p>
<p><strong>Candidate:</strong> How many active users does Gmail have? Is the computing cost a concern in this feature?<br>
<strong>Interviewer:</strong> Gmail has about 1.8 billion users, and a single user can send as many as 500 emails in a day. We do care about the computing costs, but let's focus on developing the system first. We can optimize for efficiency in future iterations.</p>
<p><strong>Candidate:</strong> Should the system make real-time suggestions?<br>
<strong>Interviewer:</strong> Yes. The expected latency should be imperceptible; something around 100 milliseconds should be fine.</p>
<h2 id="frame-the-problem-as-an-ml-task">Frame the Problem as an ML Task</h2>
<p>In this section, we frame the Smart Compose feature as an ML task. This requires us to understand the system's inputs and outputs and choose a suitable ML approach for learning the task.</p>
<h3 id="specifying-the-systems-input-and-output">Specifying the system's input and output</h3>
<p>The input to the model is a sequence of words typed by the user. The output is a continuation of that sequence. The model generates the words that the user is likely to type next.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simple data flow diagram illustrating the functionality of a 'Smart Compose System.'  The diagram shows an input string, 'Hi John! I hope,'  connected via a solid black arrow to a light-orange, rounded-rectangle box labeled 'Smart Compose System.' This box represents the system's processing unit.  Another solid black arrow extends from the 'Smart Compose System' box to an output string, 'you are doing well!'  The arrows indicate the direction of data flow, showing that the input string is processed by the Smart Compose System, resulting in the output string.  A small text note at the bottom of the 'Smart Compose System' box reads 'Text is not SVG - cannot display,' indicating that the box's visual representation is not an SVG image." loading="lazy" width="496" height="69" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-2-GWOU67YB.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 2: Input and output of the Smart Compose system</figcaption></div></figure>
<h3 id="choosing-a-suitable-ml-approach">Choosing a suitable ML approach</h3>
<p>Smart Compose generates textual content, so we categorize it as a text generation task. Various ML architectures are designed to process sequential data, which is essential for text generation. Two popular architectures are recurrent neural networks (RNNs) [2] and Transformers [3].</p>
<p>Transformers provide several advantages over RNNs, with two main benefits being:</p>
<ul>
<li><strong>Parallelism:</strong> In an RNN, computations from one time step are carried forward and used in the next, creating a time-dependent chain of operations. Transformers, on the other hand, can process all input tokens simultaneously through their self-attention mechanism.</li>
<li><strong>Better handling of long sequences:</strong> Transformers use self-attention mechanisms to focus on any part of a sequence, regardless of distance. In contrast, RNNs, struggle with long-range dependencies because of their sequential structure and the vanishing gradient problem.</li>
</ul>
<p>Due to these advantages, Transformers have shown outstanding performance in text generation tasks and are, thus, used in most generative systems nowadays. Therefore, we chose Transformers to build the Smart Compose feature.</p>
<div class="table-wrap" style="--table-min-width: 640px;"><table><thead><tr><th style="text-align: center;">Feature</th><th style="text-align: center;">RNN (GRU [4], LSTM [5])</th><th style="text-align: center;">Transformer</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>Architecture</strong></td><td style="text-align: center;">Simple</td><td style="text-align: center;">Complex</td></tr><tr><td style="text-align: center;"><strong>Training efficiency</strong></td><td style="text-align: center;">Inefficient due to sequential processing</td><td style="text-align: center;">Efficient due to parallel processing</td></tr><tr><td style="text-align: center;"><strong>Effectiveness</strong></td><td style="text-align: center;">Low as it struggles with long sequences</td><td style="text-align: center;">High as it handles long sequences</td></tr><tr><td style="text-align: center;"><strong>Scalability</strong></td><td style="text-align: center;">Limited scalability</td><td style="text-align: center;">Highly scalable</td></tr><tr><td style="text-align: center;"><strong>Applications</strong></td><td style="text-align: center;">Simple tasks such as time series modeling</td><td style="text-align: center;">Complex tasks such as language completion or translation</td></tr></tbody></table></div>
<p class="tableCaption"><p>Table 1: Comparison of RNN and Transformer architectures</p></p>
<p>While Transformers are more parallelizable due to their lack of strict sequential dependencies, their self-attention mechanism has a computational complexity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is the sequence length. This complexity arises because the self-attention mechanism requires the calculation of attention scores between every pair of tokens in the sequence. Various techniques are introduced to reduce the complexity of attention. To learn more, refer to Group Attention [6] and Flash Attention [7].</p>
<h2 id="data-preparation">Data Preparation</h2>
<p>During the data preparation step, we convert raw data into the format expected by the ML model. First, let's briefly review the available data.</p>
<p>Two sources of data are available for training our model: general data and email data. General data includes publicly available text from sources such as books, websites, and social media posts. This data is important for training language models because it contains diverse vocabulary, syntax, and contexts.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a digitized page displaying two vertically-aligned columns of text.  Each column contains a poem, seemingly from the same source, with line numbers ('6' and '9') marking the end of the first and second stanzas respectively in each column. The left column's poem focuses on the fleeting nature of summer's beauty and the enduring sweetness that remains even in winter. The right column's poem uses musical metaphors to explore the themes of loneliness and the importance of connection, contrasting the solitary life with the vibrant fullness of a family.  The poems are presented in a serif typeface, typical of older printed works, with consistent line spacing and justification. No URLs or parameters are visible; the only additional elements are the line numbers, which serve as visual separators within the poems. The two columns are presented side-by-side without any explicit visual connection beyond their shared page layout.  The text flows vertically within each column, with each line representing a verse in the respective poem." loading="lazy" width="881" height="620" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(881px, 100vw), (max-width: 1200px) min(881px, 80vw), min(881px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-3-BMH23DOJ.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-3-BMH23DOJ.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-3-BMH23DOJ.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-3-BMH23DOJ.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-3-BMH23DOJ.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-3-BMH23DOJ.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-3-BMH23DOJ.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-3-BMH23DOJ.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-3-BMH23DOJ.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 3: Example of general data from Shakespeare</figcaption></div></figure>
<p>The email data, as specified in the requirements, consists of one billion email messages. This data is crucial for the model to learn email writing styles and common phrases used in emails. Table 2 shows a simplified example of email data. In practice, more metadata is stored for each email message.</p>
<div class="table-wrap" style="--table-min-width: 640px;"><table><thead><tr><th>Email ID</th><th>Sender</th><th>Recipient</th><th>Subject</th><th>Body</th></tr></thead><tbody><tr><td>4953</td><td><a href="mailto:john@gmail.com" target="_blank" rel="noopener noreferrer">john@gmail.com</a></td><td><a href="mailto:mike@yahoo.com" target="_blank" rel="noopener noreferrer">mike@yahoo.com</a></td><td>Catchup?</td><td>Hey Mike, let's catch up this Sat. …</td></tr><tr><td>9356</td><td><a href="mailto:kkart@gmail.com" target="_blank" rel="noopener noreferrer">kkart@gmail.com</a></td><td><a href="mailto:cs382@stanford.edu" target="_blank" rel="noopener noreferrer">cs382@stanford.edu</a></td><td>Project Deadline</td><td>Hi TA, I hope you are well. I am writing to you to …</td></tr></tbody></table></div>
<p class="tableCaption">Table 2: Example of email data</p>
<p>Raw text in both general data and email data is often noisy and inconsistent, which can degrade the model performance. Additionally, ML models require data to be in a numerical format. For these reasons, raw text has to be prepared using the following two key steps:</p>
<ul>
<li>Text cleaning and normalization</li>
<li>Text tokenization and token indexing</li>
</ul>
<h3 id="text-cleaning-and-normalization">Text cleaning and normalization</h3>
<h4 id="text-cleaning">Text cleaning</h4>
<p>Text cleaning removes unnecessary or irrelevant information. Common methods include:</p>
<ul>
<li><strong>Remove non-English text:</strong> Use language identification [8] methods such as [9] to identify and remove non-English text from general and email data.</li>
<li><strong>Remove confidential information:</strong> Emails may contain confidential information such as phone and credit card numbers. These details must be removed to prevent the model from learning or exposing them later. We replace personal names, URLs, email addresses, and phone numbers with placeholder characters. For example, replace "<a href="mailto:john@gmail.com" target="_blank" rel="noopener noreferrer">john@gmail.com</a>" with "##@gmail.com."</li>
<li><strong>Remove irrelevant characters or symbols:</strong> Remove unnecessary or irrelevant characters and symbols that do not contribute to the meaning. For example, symbols such as "©," "™," or emojis are removed, as they do not typically change the meaning of text.</li>
<li><strong>Remove duplicated data:</strong> Duplicate data refers to identical text from different sources that appear multiple times in the dataset. We remove duplicates to prevent the model from becoming biased and skewing the model's learning process.</li>
</ul>
<h4 id="text-normalization">Text normalization</h4>
<p>Text normalization transforms text into a consistent format. For example, it converts different ways of writing a phone number—such as "(123) 456-7890," "123.456.7890," and "123-456-7890"—into a standard format, for example, "1234567890." Text normalization ensures consistency and reduces complexity in text data.</p>
<p>Next, we convert the raw text into a sequence of numbers through text tokenization and token indexing.</p>
<h3 id="text-tokenization-and-token-indexing">Text tokenization and token indexing</h3>
<p>Text tokenization followed by token indexing converts the raw text into a format the Transformer model expects: a sequence of numbers.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a data processing pipeline illustrating text tokenization.  The pipeline begins with a dashed-line box labeled 'Raw text' containing the text string 'Hi I am Emilie'.  A solid arrow points from this box to a light green rounded-rectangle labeled 'Text Tokenization...'. This rectangle represents the process of converting raw text into numerical tokens.  Another solid arrow extends from the 'Text Tokenization...' block to a sequence of four adjacent boxes, each containing a number (3, 7, 11, 29). This final sequence is labeled 'Sequence of indices,' indicating that the numbers represent the indices or positions of the tokens in a vocabulary or embedding space.  The overall flow shows how raw text is transformed into a numerical representation suitable for machine learning models, where each number corresponds to a specific word or sub-word unit from the input text." loading="lazy" width="500" height="120" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-4-BA4VVSJR.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 4: Converting raw text to a sequence of numbers</figcaption></div></figure>
<p>Let's examine each step in more detail.</p>
<h4 id="text-tokenization">Text tokenization</h4>
<p>Text tokenization is the process of splitting text into smaller units called tokens. Figure 5 shows how OpenAI's GPT-4 tokenizes the sentence "Let's go to NYC".<sup><a id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label" href="/courses/genai-system-design-interview/gmail-smart-compose#user-content-fn-1">1</a></sup></p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simple flowchart illustrating the process of tokenization in natural language processing.  At the top, a rectangular box contains the input phrase 'Let's go to NYC'. A downward arrow connects this box to a second box labeled 'Tokenization,' indicating that the input phrase will undergo this process.  From the 'Tokenization' box, another downward arrow points to a horizontal arrangement of five smaller rectangular boxes. Each of these smaller boxes contains a single token from the input phrase: 'Let,' ''s,' 'go,' 'to,' and 'NYC.'  The arrangement visually demonstrates how the 'Tokenization' process breaks down the input sentence into its individual constituent words and punctuation marks, effectively separating the input string into its fundamental units." loading="lazy" width="276" height="180" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-5-NZHRPTGU.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 5: Example of GPT-4 tokenization</figcaption></div></figure>
<p>Tokenization can be performed at different levels. For example, "Hello world" can be split into ["Hello", "world"] or ["H", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d"]. Generally, tokenization algorithms are divided into three categories:</p>
<ul>
<li>Character-level tokenization</li>
<li>Word-level tokenization</li>
<li>Subword-level tokenization</li>
</ul>
<p>Understanding each tokenization category and its pros and cons is crucial in most ML interviews. Let's delve into them.</p>
<h5 id="character-level-tokenization">Character-level tokenization</h5>
<p>Character-level tokenization breaks text down into a set of characters. It is simple to implement, but difficult for the model to learn meaningful representations for each token. For example, it's harder to learn a meaningful representation for the letter "g" than for the word "go," because "go" has a clear meaning, whereas "g" does not. Because of this, character-level tokenization often results in a loss of performance.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a flowchart illustrating character-level tokenization.  At the top, a rectangular box contains the text 'Let's go!'. A downward arrow connects this box to the text 'Character-level tokenization,' indicating the process's starting point.  Below this, a series of nine rectangular boxes, resembling keyboard keys, are arranged horizontally. Each box contains a single character from the input string 'Let's go!', representing the individual tokens resulting from the character-level tokenization. The order of characters in the boxes mirrors the order in the input string: L, e, t, ', s,  g, o, !.  The arrow from 'Character-level tokenization' points to this row of character boxes, showing the output of the process.  A small text at the bottom indicates that the image is not an SVG and cannot be fully displayed." loading="lazy" width="360" height="185" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-6-23D4UOAA.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 6: Example of character-level tokenization</figcaption></div></figure>
<h5 id="word-level-tokenization">Word-level tokenization</h5>
<p>Word-level tokenization breaks text into individual words. While there are different algorithms for word-level tokenization, a simple algorithm is to split the text using its whitespaces.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simple data processing pipeline illustrating word-level tokenization.  A rectangular box at the top contains the input text string 'Let's go!'. A downward-pointing arrow connects this input box to a text label 'Word-level tokenization,' indicating a processing step.  This processing step outputs two rectangular boxes placed side-by-side, each containing a single token from the input string: 'Let's' in the left box and 'go!' in the right box.  The text 'Text is not SVG - cannot display' below the output boxes suggests that the image is a simplified representation and that a more detailed visualization of the tokenization process might be available in a richer format like SVG. The overall flow depicts the transformation of a single input string into individual word tokens." loading="lazy" width="228" height="201" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-7-ZHAQMFRA.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 7: Example of word-level tokenization</figcaption></div></figure>
<p>The advantage of word-level tokenization is that it is simpler for the model to learn meaningful representations for each token. However, the main disadvantage of word-level tokenization is that it typically leads to a very large vocabulary size. For example, Transformer-XL [10] uses a word-level tokenizer, resulting in a vocabulary of 267,735 tokens. A large vocabulary size is problematic because the model has to learn representations for hundreds of thousands of tokens. This makes the training time-consuming and, therefore, more costly to train than character-level tokenization.</p>
<p>Let's examine subword-level tokenization which offers a balance between word-level and character-level tokenization.</p>
<h5 id="subword-level-tokenization">Subword-level tokenization</h5>
<p>Subword-level tokenization splits text into smaller units called subwords. It is based on the principle that a frequently used word should not be split into smaller subwords, but a rare word should be split into smaller meaningful subwords. For example, "unhappily" might be considered a rare word and thus be split into "unhappy" and "ly." Both "unhappy" and "ly" are more frequently used in text data, making it easier for the model to learn a meaningful representation for each.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simple illustration of subword-level tokenization.  A top rectangular box contains the input phrase 'Let's go!'. A downward-pointing arrow connects this box to the text 'Subword-level tokenization,' indicating a process is applied.  Another downward-pointing arrow leads from 'Subword-level tokenization' to four smaller, rectangular boxes arranged horizontally. Each smaller box represents a token resulting from the tokenization process: 'Let,' ''s,' 'go,' and '!'.  The arrangement shows the input phrase being broken down into its constituent subword units, demonstrating how subword tokenization works by splitting words and contractions into smaller meaningful units." loading="lazy" width="232" height="192" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-8-QUTPVYHZ.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 8: Example of subword-level tokenization</figcaption></div></figure>
<p>While subword-level tokenization can be complex to implement, it has several benefits. First, it leads to a manageable vocabulary size, thus reducing the cost of the model learning representations for each subword. Second, subword-level tokenization allows the model to represent unfamiliar words by decomposing them into known subwords.</p>
<p>Table 3 below compares the characteristics of the three tokenization categories.</p>
<div class="table-wrap" style="--table-min-width: 640px;"><table><thead><tr><th style="text-align: center;">Characteristics</th><th style="text-align: center;">Character-level</th><th style="text-align: center;">Word-level</th><th style="text-align: center;">Subword-level</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>Granularity</strong></td><td style="text-align: center;">Individual characters</td><td style="text-align: center;">Individual words</td><td style="text-align: center;">Subwords</td></tr><tr><td style="text-align: center;"><strong>Vocabulary size</strong></td><td style="text-align: center;">Small</td><td style="text-align: center;">Large</td><td style="text-align: center;">Moderate</td></tr><tr><td style="text-align: center;"><strong>Algorithm complexity</strong></td><td style="text-align: center;">Simple</td><td style="text-align: center;">Simple</td><td style="text-align: center;">Complex</td></tr><tr><td style="text-align: center;"><strong>Handling unseen words</strong></td><td style="text-align: center;">Decomposes unseen words into characters</td><td style="text-align: center;">Cannot easily handle unseen words</td><td style="text-align: center;">Decomposes unseen words into known subwords</td></tr><tr><td style="text-align: center;"><strong>Vocabulary size</strong></td><td style="text-align: center;">~100</td><td style="text-align: center;">~300,000+</td><td style="text-align: center;">~50,000–150,000</td></tr><tr><td style="text-align: center;"><strong>Performance</strong></td><td style="text-align: center;">Poor performance</td><td style="text-align: center;">High performance but not practical</td><td style="text-align: center;">High performance and practical</td></tr></tbody></table></div>
<p class="tableCaption"><p>Table 3: Comparison between different tokenization categories</p></p>
<h5 id="which-tokenization-is-suitable-for-the-smart-compose-feature">Which tokenization is suitable for the Smart Compose feature?</h5>
<p>Most state-of-the-art language models use subword-level tokenization algorithms such as Byte-Pair Encoding (BPE) [11] and SentencePiece [12]. These algorithms are more efficient and can effectively handle multiple languages. For example, OpenAI's GPT-4 uses a variant of BPE [13], and Google's Gemini uses SentencePiece [14].</p>
<p>Given the effectiveness of subword-level tokenization, we use it as the text tokenizer for the Smart Compose feature. We rely on popular Python libraries such as Tiktoken [13] by OpenAI or SentencePiece [15] by Google to perform text tokenization. These libraries are implemented reliably and they support various tokenization algorithms.</p>
<p>In Chapter 3, we will dive into BPE and explore its algorithms. To learn more about subword-level tokenization algorithms, refer to [16].</p>
<h4 id="token-indexing">Token indexing</h4>
<p>Token indexing is the process of converting textual tokens into integer numbers.</p>
<p>To prepare for token indexing, the tokenization algorithm first builds a vocabulary—a collection of all unique tokens—from the training text data and then stores it in a table. Figure 9 shows examples of vocabularies for different tokenization categories. The order and ID values are chosen arbitrarily for demonstration purposes.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents three tables illustrating different vocabulary levels used in natural language processing.  The first table, labeled 'Character-level Vocabulary,' maps individual characters (e.g., 'a', 'b', 'A', 'B', '!', '&lt;SPACE&gt;') to unique numerical IDs (0, 1, 26, 27, 57, 105 respectively).  The second table, 'Word-level...', shows a mapping of whole words (e.g., 'a', 'about', 'after', 'all', 'also', 'zebra', '!') to IDs (0, 1, 2, 3, 4, 270030, 270131 respectively). The third table, 'Subword-level Vocabulary,' presents a mapping of subword units and special tokens (e.g., 'the', 'of', 'home', '##ing', '##ed', '##able', '&lt;EOS&gt;', '&lt;SPACE&gt;') to IDs (0, 1, 2, 50252, 50253, 50254, 50255, 50256 respectively).  Each table demonstrates a different granularity of tokenization, with character-level being the finest and subword-level offering a balance between character and word-level representations, often handling out-of-vocabulary words more effectively.  The ellipses (...) indicate that the tables are truncated and contain more entries than shown." loading="lazy" width="556" height="399" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-9-JNMLKDJN.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 9: Examples of different vocabularies</figcaption></div></figure>
<p>Once the tokenization algorithm has built the vocabulary, we can convert any token into a number and any number back into a token. Figure 10 shows token indexing using the GPT-4 vocabulary [17].</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a process of tokenization and numerical ID assignment within a GPT-4 vocabulary.  The left side shows a flowchart.  A rectangular box labeled 'Let's go!' is at the top, pointing downwards to a row of four boxes representing the individual tokens: 'Let,' ''s,' 'go,' and '!'.  An arrow then points from the 'go' token to another row of four boxes, each containing a numerical ID: 10267, 596, 733, and 0.  These IDs correspond to the tokens above them. The right side displays a table labeled 'GPT-4 Vocabulary,' with two columns: 'Token' and 'ID.'  This table shows a partial list of tokens and their corresponding numerical IDs, including the tokens and IDs from the flowchart, illustrating the mapping between text tokens and their numerical representations used internally by the GPT-4 model.  The ellipses (...) indicate that the table contains more entries than are shown." loading="lazy" width="389" height="276" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-10-4OOHC2UL.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 10: Example of token indexing</figcaption></div></figure>
<p>To summarize the data preparation step, we first clean and normalize the text data to ensure high-quality, consistent text in our training data. Next, we use a subword-level tokenization algorithm such as BPE to tokenize the text into textual tokens (subwords) and then replace each token with its numerical index. These steps ensure our training data is now represented in a numerical format that the ML model can use.</p>
<h2 id="model-development">Model Development</h2>
<p>The Smart Compose feature is a text generation task in which a Transformer model predicts how email sentences are likely to be completed. In this section, we explore the details of the Transformer architecture, training strategies, and sampling methods to develop the text generation model.</p>
<h3 id="architecture">Architecture</h3>
<p>The Transformer architecture, introduced in the paper "Attention Is All You Need" [3], is designed to process sequences. This makes it ideal for tasks that require understanding a text and the relationships between its words. For example, in the Smart Compose feature, the model processes the sequence of words already entered by the user so it can suggest the next words.</p>
<p>Transformers have three primary variations:</p>
<ul>
<li>Encoder-only</li>
<li>Decoder-only</li>
<li>Encoder-decoder</li>
</ul>
<p>Each variation has minor architectural differences that make them suitable for specific tasks. Let's briefly explore each variation and its applications.</p>
<h4 id="encoder-only">Encoder-only</h4>
<p>An encoder-only Transformer is used for tasks that require understanding the overall meaning of a text. It processes the input sequence as a whole and makes predictions about it. For instance, in a sentiment analysis task, an encoder-only Transformer predicts the sentiment of the input sentence.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified diagram of a sentiment analysis system.  The bottom component, enclosed in a dashed-line box, represents the input text: 'This product is very good'.  An arrow points upward from this input text to a larger, light-green, rectangular box labeled 'Encoder-only Transformer,' indicating that the input text is processed by this transformer model.  The transformer likely encodes the input text into a numerical representation suitable for sentiment analysis.  Finally, another upward-pointing arrow connects the output of the 'Encoder-only Transformer' to a small, square box labeled 'Sentiment: 1,' signifying that the model has assigned a sentiment score of '1' (presumably positive, given the input text) to the input sentence. The overall flow demonstrates the process of inputting text, transforming it using an encoder-only transformer, and generating a numerical sentiment score as output." loading="lazy" width="244" height="244" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-11-56XLOMNR.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 11: Encoder-only Transformer for sentiment analysis</figcaption></div></figure>
<p>Encoder-only Transformers are commonly used for tasks such as sentence classification and named entity recognition, which focus on understanding the input rather than generating new content. Google's BERT [18] is a well-known example of an encoder-only Transformer. However, these models are not typically used to generate new sequences. Decoder-only Transformers, on the other, are specifically designed for that purpose.</p>
<h4 id="decoder-only">Decoder-only</h4>
<p>A decoder-only Transformer processes the input sequence and generates a new sequence iteratively.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified architectural diagram focusing on a decoder-only Transformer model.  The central element is a rectangular box with a peach/light-orange fill and a gold border, clearly labeled 'Decoder-only Transformer.' This box represents the core of the generative AI system. Above and below this central box are dashed-line rectangles, representing unspecified input and output components respectively.  No arrows or explicit connections are shown between these components and the decoder-only Transformer, implying a general flow of information:  unspecified input feeds into the decoder-only Transformer, which then produces an unspecified output.  The lack of detail in the input and output boxes suggests a focus on the core Transformer architecture itself, rather than the specifics of data ingestion or post-processing." loading="lazy" width="276" height="217" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(276px, 100vw), (max-width: 1200px) min(276px, 80vw), min(276px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-12-VU62GO5K.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-12-VU62GO5K.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-12-VU62GO5K.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-12-VU62GO5K.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-12-VU62GO5K.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-12-VU62GO5K.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-12-VU62GO5K.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-12-VU62GO5K.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-12-VU62GO5K.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 12: Decoder-only Transformer for text completion</figcaption></div></figure>
<p>Decoder-only Transformers are widely used in generative tasks including text generation, where the model generates a sequence one token at a time based on the previously generated tokens. Most large language models (LLMs), such as OpenAI's GPT-4 [19], Meta's LLaMA [20], and Google's Gemini [14], are based on a decoder-only Transformer.</p>
<h4 id="encoder-decoder">Encoder-decoder</h4>
<p>The encoder-decoder architecture utilizes both encoder-only and decoder-only Transformers. An encoder component processes the input sequence and a decoder uses that processed information to generate the output sequence.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified diagram of a machine translation system.  A light-green rectangle labeled 'Encoder-only...' represents an encoder component of a neural machine translation model, which takes as input an English sentence 'I am graduating' enclosed in a dashed-line box labeled 'English:'.  An arrow indicates the flow of information from the English sentence to the encoder.  A light-orange rectangle labeled 'Decoder-only...' represents a decoder component, receiving the output from the encoder.  An arrow shows the data flow from the encoder to the decoder. Finally, an arrow points from the decoder to a dashed-line box labeled 'Japanese:' containing the Japanese translation '私は卒業します'. This illustrates the translation process: the encoder processes the English input, and the decoder generates the Japanese output." loading="lazy" width="408" height="223" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-13-6ITL25HJ.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 13: Encoder-decoder Transformer used for language translation</figcaption></div></figure>
<p>An encoder-decoder Transformer is particularly suited for tasks where the output is a transformation of the input. For example, in a language translation task, the input sentence in one language is transformed into an equivalent sentence in another language. We'll examine this architecture in Chapter 3.</p>
<p>Figure 14 below shows commonly used models that employ different variations of Transformers.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a classification of different transformer-based language models based on their architecture.  The diagram starts with a central node labeled 'Transformer,' branching into three main architectural types: 'Encoder-only,' 'Decoder-only,' and 'Encoder-decoder.'  The 'Encoder-only' branch connects to 'Meta's RoBERTa' and 'Google's BERT.' The 'Decoder-only' branch connects to 'OpenAI's GPT,' 'Anthropic's Claude,' 'Meta's LLaMA,' 'xAI's Grok,' and 'Google's Gemini.' Finally, the 'Encoder-decoder' branch connects to 'Meta's BART' and 'Google's T5.'  Each line represents a specific language model, indicating its architectural classification within the broader transformer family.  The arrangement visually demonstrates the relationships between different models and their underlying architectural designs." loading="lazy" width="429" height="378" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-14-HCWUCU7I.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 14: Popular models for each variation of Transformers</figcaption></div></figure>
<h4 id="which-transformer-variation-is-suitable-for-the-smart-compose-feature">Which Transformer variation is suitable for the Smart Compose feature?</h4>
<p>The choice between encoder-only, decoder-only, and encoder-decoder Transformer models depends on whether the nature of the task is generation or understanding. Smart Compose is a text generation task that aims to complete a partially written text. Therefore, a decoder-only Transformer is ideal for this task due to its ability to generate text based on a given sequence.</p>
<p>ML system design interviews typically focus on high-level concepts and component interactions rather than architectural details. We'll provide a brief overview of the Transformer architecture without going too deep. For a deeper understanding of Transformer architectures, refer to [21] and [22].</p>
<p>A decoder-only Transformer consists of the following components:</p>
<ul>
<li>Text embedding</li>
<li>Positional encoding</li>
<li>Transformer</li>
<li>Prediction head</li>
</ul>
<h4 id="text-embedding">Text embedding</h4>
<p>The text embedding component converts each token ID into a fixed-length vector called an "embedding." Embeddings are typically stored in a table, as shown in Figure 15, and learned during the training process.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a process of token embedding.  On the left is a vocabulary table with two columns: 'Token' and 'ID'.  The 'Token' column lists example words or symbols (!, ', go, etc.), while the 'ID' column assigns a unique numerical identifier to each token (0, 1, 733, etc.).  This table is labeled 'Vocabulary'.  To the right is an 'Embedding table...', which is a matrix containing numerical values (e.g., 0.25, 0.10, 0.75, etc.). Curved arrows connect the vocabulary table to the embedding table.  Specifically, an arrow labeled 'Token 0 embedding' connects the ID '0' from the vocabulary table to the first row of the embedding table, indicating that the embedding for token '!' (ID 0) is the vector [0.25, 0.10, 0.75]. Similarly, an arrow labeled 'Token 1 embedding' connects the ID '1' to the second row of the embedding table, showing the embedding for token ''' (ID 1) as the vector [0.18, -0.9, 0.34].  The embedding table represents a vector representation of each token from the vocabulary, where each row corresponds to a unique token ID and contains its embedding vector." loading="lazy" width="428" height="280" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-15-NUHSASKZ.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 15: Embedding table representing tokens</figcaption></div></figure>
<p>The text embedding is crucial in a decoder-only Transformer. Let's understand why.</p>
<p>During data preparation, we tokenized the text and converted tokens to IDs. However, there are two significant limitations in how the text is represented:</p>
<ul>
<li><strong>Sparsity:</strong> The vocabulary typically includes tens of thousands of token IDs. Representing these IDs using one-hot encoding results in sparse, high-dimensional data, which is inefficient.</li>
<li><strong>Lack of semantic information:</strong> Token IDs are arbitrary and do not capture any relationships between words. For example, the words "happy" and "joyful" might be close in meaning, but their token IDs may not reflect this similarity.</li>
</ul>
<p>The text embedding component addresses both of these limitations by converting token IDs into learned embeddings. Since the embeddings are dense vectors in a lower-dimensional space, sparsity is no longer a concern.</p>
<p>In addition, since the embeddings are learned during model training, they capture semantic meanings. For example, the embeddings for "happy" and "joyful" will be closer together in the embedding space than those for "happy" and "sad," as shown in Figure 16.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a two-dimensional scatter plot with axes labeled X1 and X2.  The plot displays various words categorized into two distinct clusters.  The first cluster, encircled in red, is positioned towards the lower left and contains the words 'Sad' and 'Angry.' The second cluster, also encircled in red, is located towards the upper right and includes the words 'Joyful' and 'Happy.'  The remaining words—'Orange,' 'Apple,' 'Strawb...' (presumably 'Strawberry'), 'Cat,' 'Dog,' 'Car,' 'Bicycle,' and 'Bus'—are scattered across the plot, not clearly belonging to either cluster, suggesting they represent a different dimension or category not directly related to the emotional states represented by the clustered words.  There are no explicit connections or information flow lines drawn between the words; their positions relative to each other and the axes implicitly suggest a relationship based on an unspecified underlying data set." loading="lazy" width="440" height="319" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-16-WJL5HCGD.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 16: Word embedding similarities (visualized in 2D for simplicity)</figcaption></div></figure>
<h4 id="positional-encoding">Positional encoding</h4>
<p>Transformers do not inherently consider the order of input tokens. If we look at the formula for attention,<br>
am, n=exp(qmknd)j=1Nexp(qmknd),</p>
<p>we see that it is permutation-invariant, meaning the attention mechanism doesn't account for token positions in the sequence. For instance, the Transformer cannot differentiate between "initialize the variable, then use it" and "use the variable, then initialize it." This impacts the model's ability to understand or generate coherent text.</p>
<p>To overcome this limitation, positional encoding provides the Transformer with position information for each token in the input sequence. Without positional encoding, the model treats the input sequence as a bag of words, which is problematic. With positional encoding, each token's position is encoded using a positional encoding function,<br>
pi=f(i),<br>
where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(⋅)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span> is the positional encoding function and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is the position of the token. This allows the model to distinguish between <code>use the variable, then initialize it'' and </code>initialize the variable, then use it."</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified diagram of a transformer model processing the input text 'I am home'.  The bottom layer shows the input text, which is tokenized into three tokens: 'I', 'am', and 'home'. Each token is represented by its corresponding token ID (40, 1097, and 2162 respectively). These IDs are then mapped to their respective token embeddings, which are represented as 3x3 matrices of numerical values (e.g., for 'I': 0.2, 0.5, -0.6; 0.9, -0.1, 0.9).  These embeddings are further augmented with positional embeddings (indicated by  `$e_.:.token i embedding` and `$p_.:.position i embeddi...`), which provide information about the token's position in the sequence. The combined token and positional embeddings are then fed into the transformer layers (represented by three stacked orange rectangles), which process the information. The output of the transformer (not explicitly shown) would be the model's representation of the input sentence.  Arrows indicate the flow of information from the input text through tokenization, embedding, and into the transformer." loading="lazy" width="608" height="459" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-17-T5YZU7PS.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 17: Adding positional information to the Transformer's input sequence</figcaption></div></figure>
<p>Positional encoding can be achieved through two common methods:</p>
<ul>
<li>Fixed positional encoding</li>
<li>Learned positional encoding</li>
</ul>
<h5 id="fixed-positional-encoding">Fixed positional encoding</h5>
<p>This method uses a fixed function to map a position (an integer) to a fixed-size vector. The original Transformer paper introduced the sine-cosine function at different frequencies as its positional encoding function.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a slide or a section of a document explaining sine-cosine positional encoding.  The top line displays the title 'Sine-cosine positional encoding'. Below this title, a partially shown mathematical equation is presented:  `$\begin{align*} PE_{(pos, 2i)} &amp;= ...` This equation fragment suggests a formula for calculating positional encoding (PE), where `pos` likely represents the position of a token in a sequence, and `2i` likely indexes a dimension within the encoding vector. The ellipsis (...) indicates that the equation continues beyond what's shown.  The equation is written using LaTeX mathematical notation, implying a technical or academic context. The bottom line indicates that the underlying text is not an SVG image, explaining why a visual representation of the equation might be missing.  There are no other components, connections, or information flows depicted in the image beyond the title and the partial equation." loading="lazy" width="287" height="145" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-18-OJVX4FS3.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 18: Sine-cosine positional encoding formula</figcaption></div></figure>
<p>Figure 19 illustrates an example of sine-cosine positional encoding, showing vector representations for four different positions. For simplicity, this example uses a vector dimension of four. In practice, this dimensionality typically matches that of the token embeddings so they can be added together (see Figure 17).</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a table-like structure displaying the results of a sine and cosine calculation across multiple iterations.  The structure is organized into four columns and four rows. Each row represents a different iteration, indicated by the changing subscript in the variable names `$P_{ij}`. The first row initializes two variables, `$P_{00}` and `$P_{02}` to 0, and `$P_{01}` and `$P_{03}` to 1.0. Subsequent rows calculate the sine and cosine of increasing integer values (1, 2, 3...).  Specifically, columns 1 and 3 calculate the sine of the iteration number (e.g., `$P_{10} = sin(1...)`, `$P_{20} = sin(2...)`), while columns 2 and 4 calculate the cosine (e.g., `$P_{11} = cos(1...)`, `$P_{21} = cos(2...)`). The numerical results of these calculations are displayed in each cell, showing the computed sine and cosine values for each iteration.  The ellipses (...) in the formulas suggest that the actual calculations might involve more complex expressions than just `sin(x)` and `cos(x)`.  The `$p_...` prefix before each row seems to be a common identifier for the entire set of calculations." loading="lazy" width="457" height="342" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-19-ZCSDWMG5.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 19: Example of sine-cosine positional encoding</figcaption></div></figure>
<p>Let's take a look at the pros and cons of fixed positional encoding.</p>
<h5 id="pros">Pros:</h5>
<ul>
<li><strong>Efficiency:</strong> Fixed encodings do not add extra trainable parameters to the model. This makes them computationally more efficient.</li>
<li><strong>Support for long sequences:</strong> Fixed methods can map any position into a representation. This flexibility allows the model to handle longer sequences beyond the model's training data.</li>
</ul>
<h5 id="cons">Cons:</h5>
<ul>
<li><strong>Predefined limits:</strong> Some fixed encoding methods require a predefined maximum position, thus limiting their applicability to sequences below that maximum.</li>
<li><strong>Suboptimal performance:</strong> In certain tasks, fixed encodings may not capture the positional relationships as effectively as learned methods. This can lead to suboptimal performance.</li>
</ul>
<h5 id="learned-positional-encoding">Learned positional encoding</h5>
<p>In this method, the positional representations are learned during the training process. Specifically, a weight matrix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">P \in \mathbb{R}^{N \times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7224em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">P</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8491em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8491em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.10903em;">N</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span> is initialized, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span> is the maximum sequence length and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> is the dimensionality of the embeddings. This matrix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">P</span></span></span></span> is treated as a trainable parameter, and it is optimized alongside the model's other parameters.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="The image represents a completely blank or empty space.  There are no visible components, no arrangement, no connections, and no information flow of any kind.  The image is simply a solid black rectangle, devoid of any diagrams, text, labels, URLs, parameters, or any other visual elements." loading="lazy" width="250" height="230" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-20-N5Y5IQVA.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 20: Trainable matrix representing positional encodings</figcaption></div></figure>
<p>Learned positional encoding has the following pros and cons.</p>
<h5 id="pros-1">Pros:</h5>
<ul>
<li><strong>Optimal performance:</strong> Since the embeddings are learned based on the training data, learned positional encoding can lead to optimal position representation for the specific task.</li>
</ul>
<h5 id="cons-1">Cons:</h5>
<ul>
<li><strong>Inefficiency:</strong> Requires additional parameters to be learned during the training, which can increase the training time and computational cost.</li>
<li><strong>Lack of generalization:</strong> Learned embeddings may overfit to specific sequence lengths seen during training. If the model mainly sees sequences of a certain length during training, it may not effectively represent other positions. This affects the model's ability to generalize across diverse positions.</li>
</ul>
<p>In summary, the choice between learned and fixed positional encodings depends on the constraints of the task, including the expected variability in sequence lengths. Some papers, including the original Transformer paper, employ fixed positional encoding due to its efficiency and better generalization. Following that, we employ fixed positional encoding, such as sine-cosine encoding, to train the Smart Compose feature.</p>
<h4 id="transformer">Transformer</h4>
<p>The Transformer component takes a sequence of embeddings as input and transforms them into an updated sequence of embeddings.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a diagram of a transformer-based architecture, likely used in a natural language processing (NLP) model.  The diagram shows an input sequence represented by three vertical rectangles labeled 'Input sequ...', each representing a sequence element. These feed upwards into two stacked transformer blocks, each containing a 'Multi-head...' layer (represented by an orange rectangle) followed by a 'Feed Forward' layer (represented by a light blue rectangle).  The 'Multi-head...' layers likely represent multi-head attention mechanisms, and the 'Feed Forward' layers represent fully connected feed-forward networks.  Arrows indicate the flow of information between layers.  The output of the second transformer block, also represented by three vertical rectangles labeled 'Output...', is shown at the top, indicating the processed sequence.  The dashed lines enclose each transformer block, highlighting their modular structure.  The text 'Transformer...' is placed to the left of each transformer block, indicating that the entire block represents a single transformer unit." loading="lazy" width="267" height="529" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-21-NAIYTDR4.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 21: A simplified Transformer structure</figcaption></div></figure>
<p>The Transformer architecture consists of a stack of blocks. Each block contains the following:</p>
<ul>
<li><strong>Multi-head attention:</strong> This layer updates each embedding by using the attention mechanism. The attention mechanism captures the relationships in the sequence by allowing each embedding to attend to its preceding embeddings. Due to the nature of its mechanism, multi-head attention is commonly known as self-attention, a term we'll use throughout the rest of this book.</li>
<li><strong>Feed forward:</strong> This layer applies two linear transformations, with a ReLU activation in between, to each embedding in the sequence independently.</li>
</ul>
<p>Transformer architecture includes details such as residual connections, layer normalization, and dropout layers. For a deep understanding of these components, refer to the paper "Attention Is All You Need" [3] and [21].</p>
<h4 id="prediction-head">Prediction head</h4>
<p>The prediction head—the final component in a decoder-only Transformer—translates the Transformer's output into probabilities for every token in the vocabulary (Figure 22). These probabilities are used to choose the most likely next token.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a diagram illustrating the process of text generation in a language model.  At the bottom, the input text 'How are' is fed into a 'Text Embedding' layer, which converts the words into numerical representations. These embeddings are then passed through a 'Positional Encoding' layer, adding information about the word order.  The output of this layer is fed into a 'Transformer' layer, the core of the model, which processes the encoded text to understand its meaning and context. The Transformer's output is then passed to a 'Prediction Head,' which predicts the probability of the next word.  The diagram shows a sequence of predicted words with associated probabilities: 'you' (0.94 probability) and 'zebra' (0.01 probability), with '&lt;EOS&gt;' (end of sequence) and 'able' (0.04 probability) appearing earlier in the sequence. A curved arrow points from the 'you' prediction to the text '94% probability fo...', indicating that the model assigns a high probability to 'you' as the next word in the sequence.  The entire architecture is a bottom-up flow, with information moving from the input text through the layers to the prediction head, which then outputs the predicted words and their probabilities." loading="lazy" width="340" height="483" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-22-MVLM5X72.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 22: Prediction head output probabilities</figcaption></div></figure>
<h3 id="training">Training</h3>
<p>Training adjusts the decoder-only Transformer's parameters using email data. Once the training process is complete, the model can suggest likely completions.</p>
<p>However, directly training the model on a task-specific dataset, such as email data, is not a good strategy. This direct training has several challenges:</p>
<ul>
<li><strong>Lack of large training data:</strong> Task-specific datasets are usually limited in size. This limitation can hinder the model's ability to learn effectively.</li>
<li><strong>Risk of overfitting:</strong> When a model is trained on a task-specific dataset, it runs a high risk of overfitting. Overfitting occurs when a model memorizes the training data to the extent that it cannot generalize to unseen data.</li>
<li><strong>Expensive and lengthy training:</strong> Training a large model from scratch requires significant computational resources and time. This is because the model has to learn different aspects of language, which is a complex and resource-intensive process.</li>
</ul>
<p>To address the above issues, a two-stage training strategy is commonly employed: pretraining, followed by finetuning. In the pretraining stage, the model is trained on a large amount of general data to learn the structure of the language. In the finetuning stage, the pretrained model is then finetuned on data specific to the task at hand (e.g., email completion).</p>
<p>This two-stage strategy harnesses a form of transfer learning, as the general knowledge gained during the pretraining stage is transferred to the finetuning stage. This transfer is beneficial because the model doesn't have to start from scratch when learning a new task. Instead, it adjusts its pretrained weights, which is more efficient.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a two-stage machine learning model training pipeline.  Two cylindrical database icons, labeled 'General...' and 'Email...', represent the source data for the model.  Arrows indicate data flow.  'General...' data feeds into a rectangular box labeled '1. Pretraining,' which then outputs to a cloud-shaped box labeled 'Base...'.  Similarly, 'Email...' data feeds into a rectangular box labeled '2. Finetuning.'  A connection from the 'Pretraining' box to the 'Finetuning' box shows that the output of the pretraining stage is used as input for the finetuning stage.  Finally, the 'Finetuning' stage outputs to a cloud-shaped box labeled 'Final...', representing the final trained model.  The 'Base...' and 'Final...' labels suggest that these represent intermediate and final model versions, respectively." loading="lazy" width="332" height="343" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-23-WIZ4MM6J.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 23: Two-stage training strategy</figcaption></div></figure>
<p>Let's take a closer look at each stage and examine the necessary training data, ML objectives, and loss functions for each.</p>
<h4 id="1-pretraining">1. Pretraining</h4>
<p>Pretraining involves training a model on a large volume of general text data. This data is usually diverse, covering a wide range of topics and language structures. The purpose of pretraining is to develop a model capable of understanding natural language, including syntax, common knowledge, and language structures.</p>
<h5 id="pretraining-data">Pretraining data</h5>
<p>The pretraining data for this stage usually consists of a large volume of general text data from various sources on the web, such as web pages, books, and social media. For example, Common Crawl [23] is a publicly available dataset collected by crawling a large number of web pages on the Internet. It contains petabytes of data that have been regularly collected since 2008.</p>
<h5 id="ml-objective-and-loss-function">ML objective and loss function</h5>
<p>An ML objective refers to the formalized goal that a training process aims to achieve. In the case of text generation, the most commonly used ML objective is "next-token prediction." In this ML objective, the model is tasked with predicting the next token given a sequence of previous tokens. For example, in the sentence "I hope you are __," the model should predict a high probability for "well" as the next token.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified illustration of a language model's prediction process.  A peach-colored rectangular box labeled 'Model' receives input from four smaller boxes containing the words 'I,' 'hope,' 'you,' and 'are.'  Arrows indicate the flow of information from these input words into the model. The model outputs a vertical column of numbers representing probabilities (0.02, 0.11, 0.86, 0.00, 0.01), which are then mapped to a bar chart titled 'Token probabilities.' This chart displays the probability distribution for four potential next words: '&lt;EOS&gt;' (end of sentence), 'able,' 'well,' and 'zebra.'  The bar for 'well' is significantly taller than the others, indicating an 86% probability, while 'able' has a 2% probability, and '&lt;EOS&gt;' and 'zebra' have much lower probabilities. A curved arrow connects the model's probability output to the bar chart, visually demonstrating how the model's numerical probabilities are translated into a probability distribution over possible next tokens." loading="lazy" width="453" height="232" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-24-SMZGJOWR.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 24: Probability distribution in next-token prediction</figcaption></div></figure>
<p>Next-token prediction is well suited for text generation tasks because, after the training process, the model can construct sentences incrementally. For example, given the input “I ordered food because I,” the model might predict <code>was'' as the next word. Subsequently, this process repeats with the new sequence </code>I ordered food because I was,'' leading to the next prediction, perhaps, ``hungry.'' This iterative process continues until the model predicts “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo></mrow><annotation encoding="application/x-tex">\langle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⟨</span></span></span></span>EOS<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mclose">⟩</span></span></span></span>,” a special token that indicates the end of the sequence. Figure 25 shows the incremental process of generating text using next-token prediction.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a sequence of autoregressive language models generating a sentence.  Each numbered section (1, 2, 3, and implied continuation) depicts a model's processing step.  A rectangular box labeled 'Model' (peach-colored with a gold outline) represents the core language model.  Below the 'Model' box are smaller, dashed-line boxes containing individual words ('How,' 'are,' 'you,' 'doing') which serve as input tokens to the model.  Arrows indicate the flow of information:  the model processes the input tokens and generates a new word as output, shown as a single word in a box above the 'Model' box.  Section 1 shows the model receiving 'How' as input and generating 'are' as output. Section 2 shows the model receiving 'How' and 'are' as input and generating 'you' as output. Section 3 shows the model receiving 'How,' 'are,' and 'you' as input and generating 'doing' as output.  The ellipsis (...) indicates that this process continues, with the model progressively generating the sentence word by word, using previously generated words as additional input in subsequent steps." loading="lazy" width="524" height="212" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-25-CUBDO24M.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 25: Incremental generation of text</figcaption></div></figure>
<p>To optimize the model for correctly predicting the next token, we define a loss function to guide the training process. Cross-entropy loss [24] is a commonly used loss function for the next-token prediction objective. This loss function measures the differences between the predicted probabilities and the correct token. This loss allows the optimizer to update the model's parameters to produce more accurate probabilities in the future.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified model of a machine learning process, specifically focusing on the prediction and loss calculation.  At the bottom, two input tokens, 'How' and 'are,' feed into a 'Model' (represented as a peach-colored rectangle). The model processes these inputs and outputs a vector of predicted probabilities ('Predicted p...') represented as a column of five numbers: 0.02, 0.11, 0.86, 0.00, and 0.01.  These probabilities correspond to different possible outputs or classes. Simultaneously, a 'Correct...' vector (a column of five 0s and a single 1) represents the ground truth or actual target values.  A 'loss' arrow connects the predicted and correct vectors, indicating that a loss function compares these two vectors to quantify the difference between the model's prediction and the correct answer. This loss value is then used to adjust the model's parameters in subsequent training iterations (not shown in the image)." loading="lazy" width="252" height="268" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-26-JF3IB7WU.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 26: Loss calculation</figcaption></div></figure>
<p>In practice, the model processes all token lengths within a sequence in parallel. This allows it to compute the loss for each token position simultaneously. Parallelizing this step speeds up training by handling multiple tokens at once, instead of sequentially.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a diagram illustrating the training process of a decoder-only Transformer model for text generation.  At the bottom, an 'Input sentence,' 'How are you?', feeds into the model.  The model processes this sentence, represented by the tokens '&lt;BOS&gt;', 'How', 'are', 'you', and '?'. These tokens are input to a horizontally oriented, orange-filled box labeled 'Decoder-only Transformer.'  The transformer processes each token individually, and outputs a set of predicted probability distributions, visually represented as vertically stacked boxes labeled 'Predicted pro...'.  These predictions are compared to the 'Correct tokens' ('How', 'are', 'you', '?', '&lt;EOS&gt;'), also represented as vertically stacked boxes. The difference between the predicted and correct tokens is calculated as a 'loss' for each token, represented by arrows pointing upwards from the predicted tokens to the corresponding correct tokens.  These individual losses are then used to update the weights of the Decoder-only Transformer during the training process, aiming to minimize the difference between predicted and correct token distributions.  The '&lt;BOS&gt;' token represents the beginning of the sentence, and '&lt;EOS&gt;' represents the end of the sentence." loading="lazy" width="320" height="396" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-27-PJZ3T2PM.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 27: Parallelizing loss computations over different lengths</figcaption></div></figure>
<h4 id="2-finetuning">2. Finetuning</h4>
<p>Finetuning involves adapting the base model from the pretraining stage to a specific task such as email completion. This stage focuses on making the model proficient at a particular task by training it on a smaller, task-specific dataset. During finetuning, the model retains its language understanding from the pretraining stage but adapts to the nuances of the task.</p>
<h5 id="finetuning-data">Finetuning data</h5>
<p>We use a dataset of approximately one billion email conversations, as specified in the requirements section. This data includes various email formats, both formal and informal tones, and specific vocabularies that are more common in email conversations.</p>
<h5 id="ml-objective-and-loss-function-1">ML objective and loss function</h5>
<p>In the finetuning stage, both the ML objective and loss function remain unchanged. The ML objective is next-token prediction, and the cross-entropy loss function guides the training process. The only difference from the pretraining stage is that the loss is calculated based on email data, focusing on predicting the next token in an email context.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified system for generating email content.  At the bottom is a rectangular box labeled 'Partial email body' containing the text 'Hi Alex, I hope you a...', representing a fragment of an email's body text. An upward arrow connects this box to a larger, horizontally oriented, light orange box labeled 'Model,' indicating that this partial email body serves as input to the model.  A second upward arrow connects the 'Model' box to a smaller, rectangular box labeled 'work,' suggesting that the model's output is used for work-related tasks. The overall flow depicts a process where a partial email body is fed into a model, which then generates a complete email (implied by the connection to 'work').  The arrangement visually emphasizes the model as the central component processing the input and producing output for a specific task." loading="lazy" width="177" height="255" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-28-U42B5TXH.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 28: Example of email completion</figcaption></div></figure>
<p>However, relying on the email's body as the sole input is not very effective, because it is not always possible to predict the next token this way. Imagine a user who wants to reply to an email from John. When the user types "Dear," the model should, ideally, suggest "John." However, if that information is not provided as input, the model cannot predict "John" as the likely next token.</p>
<p>To address this limitation, we include more information in the input. For example, we can use the email's subject, the recipient, and previous emails, if available. This adds depth to the context and helps the model make more relevant predictions.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified architecture diagram of a model, likely a machine learning model used for email processing or generation.  A large, horizontally oriented, light orange rectangle labeled 'Model' sits at the top, representing the core model itself.  Below it are five smaller, vertically oriented, white rectangles, each connected to the 'Model' rectangle via upward-pointing arrows, indicating data flow into the model. These rectangles represent input features to the model: two are labeled 'Email...', suggesting email content as input; one is labeled 'Sender...', indicating sender information as input; one is labeled 'Recipien...', likely representing recipient information; and the last is labeled 'Previous...', possibly representing previous email interactions or context.  The arrows show that the model receives these five types of data as input for processing or prediction." loading="lazy" width="332" height="121" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-29-PMG3GGHC.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 29: Providing more context as the input for improved model predictions</figcaption></div></figure>
<h4 id="combining-various-inputs">Combining various inputs</h4>
<p>In traditional ML, the model's architecture typically depends on the type of data it processes. This requires customized preprocessing and feature engineering for different data types like text, images, or tables.</p>
<p>In the era of GenAI, however, the model architecture is often decoupled from the input structure. This decoupling increases flexibility, allowing the same model architecture to handle diverse inputs with a unified architecture, thus streamlining development and enhancing the versatility of GenAI systems. This decoupling is done through techniques like prompt engineering [25]. In Chapter 6, we examine prompt engineering in detail.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a comparison of traditional Machine Learning (ML) and the Generative AI (GenAI) era.  The left side depicts traditional ML, showing a 'Model' at the top receiving input from multiple 'Features' (1 to N). Each feature is preprocessed individually ('Preprocessing +...') before being fed into the model.  Each preprocessing step receives an 'Input type...' as input.  The right side illustrates the GenAI era, where a 'Model' similarly sits at the top, but its input is a 'Long sequence of tokens.'  This sequence is generated by a 'Prompt Engineering' step, which in turn receives multiple 'Input type...' inputs.  Arrows indicate the flow of data, showing how preprocessed features are combined to feed the model in traditional ML, while in GenAI, multiple inputs are processed through prompt engineering to create a single token sequence for the model.  The overall structure highlights the shift from feature engineering in traditional ML to prompt engineering in the GenAI era." loading="lazy" width="636" height="359" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-30-SIMI5D2S.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 30: Combining various inputs in traditional ML vs. GenAI era</figcaption></div></figure>
<p>To combine various inputs in Gmail Smart Compose, as shown in Figure 31, we combine multiple text inputs into one sequence with tags using a prompt template. We don't need to worry about missing optional fields if our training set includes such examples. The model handles various input combinations regardless of whether they include all details or only partial information. This flexibility demonstrates the model's robust design, allowing it to generate contextually appropriate outputs even with incomplete inputs. By including diverse scenarios in the training data, we ensure the model generalizes well across different input structures and still produces reliable results.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents two rectangular boxes placed side-by-side, labeled 'Example 1' and 'Example 2' respectively, at the bottom.  Each box contains the text 'Inputs:...' centrally positioned, indicating that they represent placeholders for input data.  There are no visible connections or information flow between the two boxes; they are presented independently as two separate examples, likely illustrating different input scenarios or data structures for a system.  The boxes are empty except for the 'Inputs:...' text, suggesting that the specific input details are omitted for illustrative purposes." loading="lazy" width="574" height="169" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(574px, 100vw), (max-width: 1200px) min(574px, 80vw), min(574px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-31-3RP2PNZJ.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-31-3RP2PNZJ.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-31-3RP2PNZJ.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-31-3RP2PNZJ.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-31-3RP2PNZJ.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-31-3RP2PNZJ.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-31-3RP2PNZJ.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-31-3RP2PNZJ.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-31-3RP2PNZJ.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 31: Examples of combining text inputs</figcaption></div></figure>
<h4 id="the-benefits-of-two-stage-training">The benefits of two-stage training</h4>
<p>The two-stage training strategy has several benefits, including:</p>
<ul>
<li><strong>Adaptability:</strong> The same base model obtained from the pretraining stage can be adapted for different tasks.</li>
<li><strong>Improved generalization:</strong> Pretraining on large and diverse text data enables the model to develop a broad understanding of language. This helps to generalize better to various tasks.</li>
<li><strong>Fast finetuning:</strong> The model learns general knowledge during the pretraining stage. This makes the subsequent finetuning process faster.</li>
<li><strong>Handling data scarcity:</strong> For tasks where large datasets are unavailable, the knowledge gained during pretraining can compensate for this lack of data. This allows the model to perform well even with limited task-specific data.</li>
<li><strong>Mitigating overfitting:</strong> If we train a model from scratch on a smaller, task-specific dataset, there is a risk it will overfit. In two-stage training, pretraining acts as regularization. The model first learns to understand language broadly before focusing on the specifics of a particular task.</li>
<li><strong>Resource optimization:</strong> By separating the training process into two stages, we perform the computationally expensive pretraining once and can reuse the same model to adapt to different tasks. This reduces computational costs since we do not need to repeat the pretraining stage for each task.</li>
</ul>
<h3 id="sampling">Sampling</h3>
<p>Generative models are trained to capture the underlying distribution of the training data. Once trained, these models can generate new samples that are similar to the data they were trained on. Sampling is the process of using a trained generative model to generate new data.</p>
<p>In the context of Smart Compose, sampling involves generating a likely email completion given the user’s partial email body and other relevant information. As Figure 32 shows, sampling is achieved by generating tokens one at a time. For example, when “Hi Alex, does today” is given to the model, the “work” token is selected as the next token based on the predicted probabilities. Next, “Hi Alex, does today work” is provided to the model as input, and the “for” token is chosen as the next token. This process continues until the model predicts the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo></mrow><annotation encoding="application/x-tex">\langle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⟨</span></span></span></span>EOS<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mclose">⟩</span></span></span></span> token.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified model of text generation, likely for email composition.  A large, horizontally oriented, peach-colored rectangle labeled 'Model' represents the core generative model. Below the model are several white boxes representing input tokens: an unlabeled box signifying initial context, followed by 'Hi,' 'Alex,' ',', 'does,' and 'today,' grouped and labeled 'Partial email body.'  Solid black arrows indicate the flow of these input tokens into the model. Above the model are more white boxes representing output tokens: 'work,' 'for,' 'you,' '?', and '&lt;EOS&gt;', with '&lt;EOS&gt;' signifying the end of the sequence. Dashed black arrows show the model's output tokens flowing upwards.  The arrangement visually depicts the model processing the input ('Initial context...' and 'Partial email body') and generating the output ('work,' 'for,' 'you,' '?', '&lt;EOS&gt;'), suggesting a sequential, left-to-right generation process." loading="lazy" width="604" height="238" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-32-F2QOXITI.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 32: Sampling email completion token by token</figcaption></div></figure>
<p>There are primarily two types of strategies to generate new text in generative models: deterministic and stochastic. Let's have a look at each.</p>
<h4 id="deterministic">Deterministic</h4>
<p>Deterministic methods generate text in a deterministic way, that is, without randomness or variability in the output. For example, at each step of token generation, the model selects the token with the highest probability from the predicted distribution. This method ensures that the generated text will always be the same for a given input, thus providing consistency and reproducibility. Figure 33 illustrates "greedy search," a simple deterministic method to generate text by iteratively choosing the next token based on the highest predicted probability.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a directed acyclic graph illustrating word probabilities in a sentence.  A thick horizontal line labeled 'How' connects to a box labeled '0.56' representing the word 'are'.  From '0.56', a thick line labeled 'you' connects to a box labeled '0.91'.  From '0.91', a thick line labeled 'doing' connects to a box labeled '0.39'.  Dashed lines represent weaker connections with associated probabilities.  A dashed line from '0.56' labeled 'am' connects to a box labeled '0.03'. Another dashed line from '0.56' labeled 'dog' connects to a box labeled '0.01'. A dashed line from 'How' labeled 'do' connects to a box labeled '0.26'. A dashed line from 'How' labeled 'come' connects to a box labeled '0.14'. A dashed line from '0.91' labeled 'work' connects to a box labeled '0.001'. A dashed line from '0.91' labeled '?' connects to a box labeled '0.38'.  The boxes contain numerical values, presumably representing probabilities or weights associated with the transitions between words in the sentence.  The graph visually depicts the probabilistic relationships between words, showing stronger connections with thicker lines and higher numerical values." loading="lazy" width="479" height="282" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-33-FIXHVQB3.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 33: Greedy search</figcaption></div></figure>
<h5 id="pros-2">Pros:</h5>
<ul>
<li><strong>Consistency:</strong> The generated text is always the same for the same input – a desirable property for systems requiring predictable results.</li>
<li><strong>Predictable outputs</strong>: Fewer surprising outputs are generated because it always chooses the most probable token at each iteration.</li>
</ul>
<h5 id="cons-2">Cons:</h5>
<ul>
<li><strong>Lack of diversity:</strong> The model may miss less probable but more interesting tokens; thus, there will be less creativity in the generated text. For example, when generating a story, the model always choose the most common phrases, resulting in a predictable but less interesting narrative.</li>
<li><strong>Repetitive text:</strong> The text may become repetitive, as the same high-probability token is always selected. For example, if the model generates a lengthy article, it might repeatedly use certain phrases. A real example of this is shown in Figure 34.</li>
</ul>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simple text generation system.  At the top is a rectangular box containing the input text prompt: 'I enjoy walking with my cute dog, but I'm not sure if I'll ever...'.  Below this, a vertical arrow points downwards labeled 'Greedy search,' indicating the search method used. This arrow connects to a light peach-colored rectangular box labeled 'GPT-2,' representing the GPT-2 language model used for text generation. The arrow's direction shows that the input prompt is fed into the GPT-2 model via a greedy search algorithm.  The overall structure depicts a straightforward pipeline where the input prompt is processed by the GPT-2 model using a greedy search to generate text, although the generated text itself is not shown in the image." loading="lazy" width="408" height="268" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-34-WCEAM765.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 34: Text generated by GPT-2 language model using greedy search</figcaption></div></figure>
<h4 id="stochastic-sampling">Stochastic sampling</h4>
<p>Stochastic sampling methods introduce randomness into the generation process. For example, at each step of token generation, the model samples from the predicted distribution based on the probabilities assigned to each token. This means that each time text is generated, even with the same initial inputs, the generated text may vary.</p>
<p>Figure 35 shows two instances of sampling using the same initial token "How." The first time, the sequence of generated tokens leads to "How are you,"; the second time, a different sequence is generated using the same initial token due to the randomness inherent in sampling.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents two examples of stochastic sampling. Each example shows a directed acyclic graph where nodes represent words ('How,' 'are,' 'come,' 'you,' 'am,' 'dog,' 'do') and edges represent probabilities.  The first example displays a 'How' node connected with a thick, solid line to an 'are' node (probability 0.56). From 'are,' a thick solid line connects to a 'you' node (probability 0.91), and a dashed line connects to an 'am' node (probability 0.03).  Dashed lines also connect 'How' to 'come' (probability 0.26) and 'are' to 'do' (probability 0.14), and 'are' to 'dog' (probability 0.01). The second example mirrors the structure of the first, but with different probabilities for the 'come' (0.26) and 'are' (0.56) nodes, and only shows the connections from 'How' to 'come' and 'are' and 'are' to 'do' (0.14).  Both examples are labeled 'Stochastic sampling example 1' and 'Stochastic sampling exampl...' respectively, indicating that they illustrate a concept of probabilistic word selection." loading="lazy" width="568" height="233" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-35-7HXT2NT7.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 35: Stochastic sampling randomness</figcaption></div></figure>
<h5 id="pros-3">Pros:</h5>
<ul>
<li><strong>Diversity:</strong> The presence of randomness allows for more varied outputs, which is particularly useful in applications such as dialogue generation.</li>
<li><strong>Novelty:</strong> By sampling from the distribution, the model can explore less probable but potentially more interesting tokens, thus resulting in creativity and novel outputs.</li>
</ul>
<h5 id="cons-3">Cons:</h5>
<ul>
<li><strong>Inconsistency:</strong> The output may vary each time a text is generated. This is less suitable for applications that require precise, repeatable results.</li>
<li><strong>Unexpected outputs:</strong> The randomness can lead to unexpected variations in the generated text, which might be inappropriate.</li>
</ul>
<h4 id="which-generation-method-is-suitable-for-the-smart-compose-feature">Which generation method is suitable for the Smart Compose feature?</h4>
<p>For Smart Compose, deterministic methods are preferred for several reasons:</p>
<ul>
<li><strong>Consistency:</strong> Consistency in generated text is crucial for applications such as email completion, for which users expect predictable and reliable suggestions. Utilizing a deterministic method means that users won't see dramatically different suggestions each time they begin to type the same thing.</li>
<li><strong>Better handling of common phrases:</strong> Deterministic methods are typically preferred in an email context, as more likely completions are prioritized over the novelty that stochastic methods offer.</li>
<li><strong>Reduced risk of inappropriate suggestions:</strong> Stochastic methods might occasionally generate inappropriate suggestions due to their inherent randomness. This behavior is not desired in an email completion feature.</li>
</ul>
<p>These reasons highlight why deterministic methods are preferred in applications requiring consistency such as email completion. Now that we have chosen deterministic text generation, let's examine two primary algorithms:</p>
<ul>
<li>Greedy search</li>
<li>Beam search</li>
</ul>
<h4 id="greedy-search">Greedy search</h4>
<p>Greedy search is the simplest deterministic algorithm. It always selects the token with the highest probability as the next token. As was shown in Figure 34, greedy search can lead to repetitive patterns in the generated text. This occurs because it follows a narrow path based on the highest probability tokens without considering alternative paths that might lead to more coherent sentences. Due to this limitation, greedy search is rarely used in practice.</p>
<h4 id="beam-search">Beam search</h4>
<p>Beam search [26] is a popular deterministic algorithm for generating text from a trained model. The core idea is to track multiple potential sequences of tokens simultaneously. At each step, the model calculates the probabilities for the next possible tokens for each sequence and selects the "top-k" most probable sequences. The value of k, known as beam width, is configurable.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a probabilistic context-free grammar (PCFG) tree illustrating word probabilities in a sentence.  A central node labeled 'How' branches into three main paths, each representing a different word choice: 'come,' 'are,' and 'do.'  These words connect with probabilities (0.24, 0.31, and 0.26 respectively) to subsequent nodes. Each of these nodes further branches out to other words with associated probabilities, indicated by dashed lines. For example, the 'are' node connects to 'plants' (0.21), 'animals' (0.36), and 'you' (0.91) with their respective probabilities. Similarly, the 'come' node connects to 'are' (0.001) with a probability. The 'do' node connects to 'you' (0.63), 'the' (0.001), and 'people' (0.21).  The 'are' node also connects to 'am' (0.03) and 'dog' (0.01).  The probabilities on the branches represent the likelihood of each word following the preceding word in the sentence, forming a probabilistic model of sentence structure.  The thicker lines represent higher probability connections." loading="lazy" width="362" height="424" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-36-62LYCKID.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 36: Beam search calculating the top three most probable sequences (beam width=3 )</figcaption></div></figure>
<p>Here is a brief step-by-step process for generating text using beam search assuming a beam width of 3:</p>
<ol>
<li><strong>Initialization:</strong> Start with the user's partial email as the input to the trained model. The model predicts the probability distribution for the next token. Beam search selects the top three tokens with the highest probabilities.</li>
<li><strong>Expansion:</strong> For each top three sequence, pass it to the model and obtain the probabilities of the next token.</li>
<li><strong>Pruning:</strong> Select the top three sequences based on their cumulative probabilities.</li>
</ol>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a three-stage process visualized as directed graphs, illustrating the evolution of a probabilistic language model.  The first stage, 'Initialization,' shows a simple tree with a central node 'How' connected to 'are' (with weight 0.31) and 'do' (with weight 0.26), and 'come' (with weight 0.24).  The second stage, 'Expansion,' expands upon the previous structure.  The 'are' node now connects to 'am' (0.03), 'dog' (0.01), 'you' (0.91), and the 'come' node connects to 'plants' (0.21) and 'animals' (0.36).  The 'do' node connects to 'the' (0.001) and 'people' (0.21).  All connections are represented by dashed lines with associated weights.  The third stage, 'Pruning,' simplifies the graph from stage two.  Less probable connections are removed, resulting in a graph where 'How' connects to 'are' (0.31), 'come' (0.24), and 'do' (0.26).  'Are' connects to 'you' (0.91), and 'do' connects to 'you' (0.63).  'Come' connects to 'animals' (0.36).  The weights represent the probabilities of the connections, with thicker lines in the first and third stages indicating stronger connections.  The overall image demonstrates a process of building and refining a probabilistic model, likely for natural language processing." loading="lazy" width="632" height="356" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-37-HMY7FIVA.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 37: First iteration of a beam search with beam width=3</figcaption></div></figure>
<p>The expansion and pruning steps are repeated until all three potential sentences reach the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo></mrow><annotation encoding="application/x-tex">\langle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⟨</span></span></span></span>EOS<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mclose">⟩</span></span></span></span> token or a maximum length. Once the beam search algorithm has stopped, we select the sequence with the highest cumulative probability as the output.</p>
<p>Beam search is effective in practice since it tracks several potential sequences simultaneously instead of the most probable sequence. However, beam search has two main drawbacks:</p>
<ul>
<li><strong>Limited diversity:</strong> Beam search often leads to similar outputs, which is not ideal for applications requiring diverse responses.</li>
<li><strong>Struggle with long sequences:</strong> Beam search struggles with longer sequences because tracking too many sequences simultaneously can become computationally expensive.</li>
</ul>
<p>The suggestions made by the Smart Compose feature are typically short; hence, capturing long-range dependencies is less critical. In addition, diversity in the email completions is not desired. For these reasons, we choose beam search as the primary sampling algorithm for generating suggestions.</p>
<h2 id="evaluation">Evaluation</h2>
<p>Evaluation is essential in ML system design interviews. Interviewers will check if candidates can effectively test and validate the ML system they design. An ideal answer should cover both online and offline evaluations and discuss popular metrics for measuring a model's performance in each setting.</p>
<p>Let's explore some common metrics for evaluating the Smart Compose feature.</p>
<h3 id="offline-evaluation-metrics">Offline evaluation metrics</h3>
<p>Offline evaluation uses pre-collected and historical data to evaluate a model's performance. Its purpose is to ensure the model's performance is acceptable before deploying it to production. For example, we test a recommendation system on historical user interaction data to see how well it predicts user preferences. Similarly, we evaluate the performance of our trained model for the Smart Compose feature using historical email data. Two commonly used metrics are:</p>
<ul>
<li>Perplexity</li>
<li>ExactMatch@N</li>
</ul>
<h4 id="perplexity">Perplexity</h4>
<p>Perplexity [27] is a standard metric used extensively in the offline evaluation of language models. This metric measures how accurately the model predicts the exact sequence of tokens present in text data. In mathematical terms, perplexity is defined as the exponential of the average "negative log-likelihood" of the predicted probability given the previous tokens in a sequence:</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a mathematical formula for calculating Perplexity, labeled 'Perplexity(X)' on the left side. The formula is set equal to the exponential function, denoted by 'exp'. Inside the parentheses of the exponential function, there is a negative sign followed by a fraction '1/N', where N is an uppercase letter. This fraction is multiplied by a summation from i=1 to N. The term being summed is 'log P(x_i | x_{1:i-1})', which represents the logarithm of the conditional probability of the i-th element x_i given the preceding elements from x_1 to x_{i-1}. The entire sum multiplied by -1/N is the negative average log-likelihood of the sequence X. Therefore, the formula calculates the perplexity of a sequence X as the exponential of the negative average log-likelihood of that sequence according to a probability model P." loading="lazy" width="500" height="109" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(500px, 100vw), (max-width: 1200px) min(500px, 80vw), min(500px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-5-RFADEBGC.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-5-RFADEBGC.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-5-RFADEBGC.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-5-RFADEBGC.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-5-RFADEBGC.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-5-RFADEBGC.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-5-RFADEBGC.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-5-RFADEBGC.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-5-RFADEBGC.png&amp;w=3840&amp;q=75" style="color: transparent;"></div></figure>
<p>In this equation:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.07847em;">X</span></span></span></span> is a tokenized sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(x_1, x_2, \cdots, x_N\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span> in the text data that is used to evaluate how accurately the model predicts the sequence.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span> is the number of tokens in the sequence.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∣</mo><msub><mi>x</mi><mrow><mn>1</mn><mo>:</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">P\left(x_i \mid x_{1: i-1}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">P</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span> is the conditional probability of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>-th token given the preceding tokens, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mn>1</mn><mo>:</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{1: i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6389em; vertical-align: -0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span></span></span></span></span></span></span></span></span></span>, that is, how likely the model is to predict the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>-th token given the previous tokens.</li>
</ul>
<p>Figure 38 illustrates a concrete example to better understand perplexity.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="The image is completely black and contains no visible components, arrangement, connections, or information flow.  Therefore, no description of its structure or interaction between components is possible." loading="lazy" width="560" height="560" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-38-UBBDHIAA.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 38: Example of perplexity calculation</figcaption></div></figure>
<p>A lower perplexity value indicates that the model has assigned higher probabilities, on average, to the tokens that appear in the text data. Therefore, a lower perplexity means the model is better at predicting the next tokens.</p>
<h4 id="exactmatchn">ExactMatch@N</h4>
<p>ExactMatch@N measures the percentage of generated phrases that are exactly N words long and that match the first N words of the ground-truth text. Figure 39 shows ExactMatch@3 calculations for three generated sequences. In practice, there are usually more than three sequences to evaluate.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a diagram illustrating a model's performance evaluation. Three input sentences ('Hi Jessica, what...', 'It was nice', 'I hope you') are fed into three separate instances of a 'Model,' each producing a prediction ('was our appointment,' 'meeting you today,' 'are doing well,' respectively).  These predictions are then compared to corresponding 'ground-truth' statements ('was our appointment today?', 'seeing you today', 'are doing well') in a separate column.  A final column, 'ExactMatch@3?', indicates whether each prediction exactly matches its ground truth (Yes or No).  Finally, at the bottom, the overall ExactMatch@3 score is calculated as 2/3 = 0.66, representing the proportion of exact matches out of the three input sentences.  The diagram visually shows the flow of information from input sentences through the model, to predictions, comparison with ground truth, and finally to the overall accuracy metric." loading="lazy" width="564" height="307" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-39-ZIHVWGKQ.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 39: Example of calculating ExactMatch@3 for three sequences</figcaption></div></figure>
<p>Calculating ExactMatch@N for different values of N allows us to measure how the model performs at different suggestion lengths. To measure the overall performance of the model, we calculate the ExactMatch for all lengths up to a specific length and then take the average.</p>
<p>While Perplexity and ExactMatch@N have traditionally been used to evaluate Gmail Smart Compose, other metrics such as BLEU score and ROUGE-N, introduced more recently, have been found to be helpful. We examine these metrics in more detail in Chapter 3.</p>
<h3 id="online-evaluation-metrics">Online evaluation metrics</h3>
<p>Online evaluation measures how a model performs in real time as users interact with the system. To evaluate the Smart Compose feature in an online environment, we use additional metrics beyond Perplexity and ExactMatch@N. These online metrics measure user engagement, the model's latency, and the overall impact on user experience.</p>
<p>Unlike offline metrics, which are usually standard, online evaluation metrics are defined based on specific requirements and needs. Companies often use hundreds of metrics for online evaluation. However, in an interview setting, we typically discuss the most common ones. In this section, we focus on the following metrics:</p>
<ul>
<li>User engagement metrics</li>
<li>Effectiveness metrics</li>
<li>Latency metrics</li>
<li>Quality metrics</li>
</ul>
<h4 id="user-engagement-metrics">User engagement metrics</h4>
<ul>
<li><strong>Acceptance rate:</strong> The percentage of suggestions made by the Smart Compose feature that are accepted by users. A higher acceptance rate indicates that the suggestions are relevant and useful to users.</li>
<li><strong>Usage rate:</strong> The percentage of all composed emails that have utilized the Smart Compose feature. High usage rates typically indicate that users trust the feature.</li>
</ul>
<h4 id="effectiveness-metrics">Effectiveness metrics</h4>
<ul>
<li><strong>Average completion time:</strong> Tracks the average time taken by users to compose emails with and without the aid of Smart Compose. A reduced average completion time using Smart Compose will indicate that the feature is speeding up the email writing process.</li>
</ul>
<h4 id="latency-metrics">Latency metrics</h4>
<ul>
<li><strong>System response time:</strong> Measures the time it takes for the Smart Compose suggestions to appear after the user begins typing. It's important to ensure this metric stays below a certain threshold so the suggestions are made before the user types them.</li>
</ul>
<h4 id="quality-metrics">Quality metrics</h4>
<ul>
<li><strong>Feedback rate:</strong> Measures the rate at which users provide feedback on the suggestions. Feedback is helpful for continuous improvement of the system.</li>
<li><strong>Human evaluation:</strong> Qualitative assessments through user studies are employed to evaluate the usefulness of suggestions. This metric reflects user satisfaction with the Smart Compose feature.</li>
</ul>
<p>These online metrics are essential for evaluating how well Smart Compose feature works in production. By monitoring these metrics, the stakeholders can obtain a holistic view of feature's performance.</p>
<h2 id="overall-ml-system-design">Overall ML System Design</h2>
<p>In this section, we propose a design for a simplified Smart Compose feature.</p>
<p>When designing such a feature, we should consider more than just the underlying model that predicts the next token. The system's effectiveness depends on various components working together to ensure the system is responsive, generates relevant suggestions, and maintains ethical standards. For the Smart Compose feature, we examine the following key components:</p>
<ul>
<li>Triggering service</li>
<li>Phrase generator</li>
<li>Post-processing service</li>
</ul>
<p>Let's explore each in more detail.</p>
<h3 id="triggering-service">Triggering service</h3>
<p>The triggering service activates the Smart Compose feature by monitoring user activity such as keystrokes. It decides when to activate the feature based on criteria such as the number of characters typed or the entering of specific keywords in the text. For example, if a user types "I," the service might not activate Smart Compose because it's too early to predict the user's intent. However, if the user types "I hope," the service will activate Smart Compose, as the additional context allows for more useful suggestions.</p>
<p>The triggering service ensures suggestions are not too frequent. Once the service determines that activating the Smart Compose feature will be useful, it triggers the phrase generator component, which we discuss next.</p>
<h3 id="phrase-generator">Phrase generator</h3>
<p>The phrase generator is the core of the Smart Compose feature. It generates the most likely completion based on the partial text the user has already typed.</p>
<p>To achieve this, the phrase generator interacts with the trained model and employs beam search to generate the top-k most probable completions. Each completion ends with the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo></mrow><annotation encoding="application/x-tex">\langle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⟨</span></span></span></span>EOS<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mclose">⟩</span></span></span></span> token and an associated score that indicates how confident the model is about the completion.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a text generation system.  A rectangular box labeled 'Input text' containing the text '[Text] Hi Petra, it was...' feeds into a purple rectangular box labeled 'Phrase Generator.'  An arrow indicates this data flow. The 'Phrase Generator' then sends its output to a language model represented by a cloud labeled 'Model' via a process called 'Beam search,' indicated by an upward arrow. The model processes the input and returns a table of 'Top-5 completions' and their corresponding 'Score.'  The table lists five different text completions ('nice seeing you!', 'nice meeting you!', 'a pleasure to discuss th...', 'last Friday! Hopefully y...', 'good.') with associated numerical scores (0.28, 0.22, 0.13, 0.06, and 0.05 respectively), suggesting a ranking based on probability or relevance.  The arrow from the 'Phrase Generator' to the table shows the flow of generated text to the scoring and ranking system." loading="lazy" width="868" height="315" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(868px, 100vw), (max-width: 1200px) min(868px, 80vw), min(868px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-40-AHFDFPCK.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-40-AHFDFPCK.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-40-AHFDFPCK.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-40-AHFDFPCK.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-40-AHFDFPCK.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-40-AHFDFPCK.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-40-AHFDFPCK.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-40-AHFDFPCK.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Ffigure-2-40-AHFDFPCK.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 40: Beam search outputs top five potential completions (beam width = 5)</figcaption></div></figure>
<p>Given the possible completions, two critical considerations are necessary:</p>
<ul>
<li>Removing long suggestions</li>
<li>Removing low-confidence suggestions</li>
</ul>
<h4 id="removing-long-suggestions">Removing long suggestions</h4>
<p>As shorter suggestions are easier for the author to read as they are typing, we remove suggested phrases that are too long. For example, if a user types "Can you please," the phrase generator might suggest "help me with this?" Longer suggestions, such as "help me with this project that is due next week," will be too specific and, therefore, less likely to predict what the author intends to write.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a diagram illustrating a text generation process and its re-ranking.  The diagram shows two tables, each with 'Top-5 completions' and 'Score' columns, flanking a central rectangular box labeled 'Long-sequence...'. The left table lists five text completions ('nice seeing you!', 'nice meeting you!', 'pleasure to discuss t...', 'last Friday! Hopefull...', 'good.') with associated scores (0.28, 0.22, 0.13, 0.06, 0.05 respectively).  A black arrow points from this table to the 'Long-sequence...' box, indicating that these completions are input to a longer sequence generation process. The right table also displays 'Top-5 completions' and 'Score' columns, but the completions are re-ordered.  Red lines connect the completions in the left table to their corresponding positions in the right table, showing how the ranking has changed after the 'Long-sequence...' process.  The scores in the right table remain the same as in the left table, indicating that the re-ranking doesn't alter the individual completion scores, only their relative positions within the top-5.  The 'Long-sequence...' box likely represents a model or process that considers the context of a longer sequence to refine the ranking of the initial completions." loading="lazy" width="580" height="220" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-41-D5BCCFYL.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 41: Removing long suggestions</figcaption></div></figure>
<h4 id="removing-low-confidence-suggestions">Removing low-confidence suggestions</h4>
<p>We remove suggestions with confidence scores below a certain threshold. This ensures we do not present suggestions if the model is not confident enough about it.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a process illustrating a low-confidence scenario in a text generation system.  The diagram shows two identical tables on either side of a central rectangular box labeled 'Low-confidence...'. Each table has two columns: 'Top-5 completions' and 'Score'. The left table displays three text completions ('nice seeing you!', 'nice meeting you!', 'good.') with corresponding scores (0.28, 0.22, 0.05 respectively).  A unidirectional arrow connects this table to the 'Low-confidence...' box, indicating that the table's data is input to the box. The 'Low-confidence...' box represents a stage where the system assesses the confidence level of the generated text.  Another unidirectional arrow connects the 'Low-confidence...' box to the right table. The right table is identical in structure to the left table, but the scores are altered.  Red lines connect the scores in the right table to different completions in the left table, showing a re-ranking or re-scoring of the completions after the low-confidence assessment.  Specifically, the score of 'good.' is increased, while the scores of 'nice seeing you!' and 'nice meeting you!' are decreased, suggesting a change in the system's confidence in the initial rankings." loading="lazy" width="629" height="146" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-42-3WLHRXT5.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 42: Removing low-confidence suggestions</figcaption></div></figure>
<p>Finally, if the final list of suggestions is not empty, the phrase generator will pass the one with the highest confidence score to the post-processing service.</p>
<h3 id="post-processing-service">Post-processing service</h3>
<p>The post-processing service addresses potential biases before suggestions are presented to the user. This component follows predefined rules to detect and correct bias efficiently. Common strategies to achieve this include:</p>
<ul>
<li><strong>Pronoun replacement:</strong> Replace gender-specific pronouns to ensure neutrality. For example, "he" or "she" might be replaced with "they" in contexts where gender is not specified.</li>
<li><strong>Gender-neutral word replacement:</strong> Replace gendered words with gender-neutral alternatives where appropriate. This includes changing words like "chairman" to "chairperson" or "policeman" to "police officer."</li>
<li><strong>Lexical analysis for sensitive terms:</strong> Use a predefined list of flagged terms that, if identified, can be replaced with neutral alternatives. For example, terms that might imply age, race, or disability biases are adjusted to ensure the suggestions will be perceived as respectful and neutral.</li>
<li><strong>NSFW (Not Safe For Work) content filtering</strong>: Implement automated filters that scan for and flag explicit language. These filters use predefined lists of NSFW keywords, phrases, and patterns to detect and remove problematic content.</li>
</ul>
<p>By implementing these rules, the post-processing service maintains ethical standards in the Smart Compose feature, thus ensuring that the suggestions provided are relevant, respectful, and inclusive.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a flowchart illustrating a generative AI system's response generation process.  The process begins with an input message ('Subject: Thanks\nHi Xue,...') which is processed by a 'Triggering...' block (1). This block's output feeds into a 'Phrase...' block (2), which in turn interacts with a 'Model' (a cloud-shaped component representing the underlying AI model) via a 'Beam search' (3) process. The 'Beam search' refines the output from the 'Phrase...' block, potentially addressing issues of length or confidence, as indicated by the 'Long and Low-confidence...' block (4) which receives feedback from the process. The refined output from the 'Phrase...' block then proceeds to a 'Post...' block (5) before finally generating the output message ('Subject: Thanks!\nHi Xue,...') (6).  The numbered circles (1-6) indicate the sequential flow of information between the blocks.  The system appears designed to generate a response to an input message, potentially improving the quality and conciseness of the response through iterative refinement using the model and beam search." loading="lazy" width="620" height="331" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/gmail-smart-compose/figure-2-43-OAKMWA2E.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 43: Smart Compose feature overall design</figcaption></div></figure>
<p>Here is a brief step-by-step workflow of the overall ML system employed by the Smart Compose feature:</p>
<ol>
<li><strong>Monitoring:</strong> The triggering service monitors the user's activity as they type.</li>
<li><strong>Triggerring:</strong> The service triggers the phrase generator once it identifies specific patterns.</li>
<li><strong>Beam search:</strong> The phrase generator employs beam search to get top-k potential completions from the trained model.</li>
<li><strong>Filtering:</strong> The phrase generator interacts with the filtering component to remove long suggestions and those with low confidence scores.</li>
<li><strong>Post-processing:</strong> The completion with the highest score is picked and passed to the post-processing service. The service replaces gender-specific pronouns and adjusts sensitive terms.</li>
<li><strong>Display suggestion:</strong> The suggestion is displayed to the user for their consideration.</li>
</ol>
<h2 id="other-talking-points">Other Talking Points</h2>
<p>If there's extra time at the end of the interview, you may face follow-up questions or be asked to discuss advanced topics. This depends on factors such as the interviewer's preference, your expertise, and the requirements of the role. For senior roles, here are some topics you should prepare for:</p>
<ul>
<li>Supporting Smart Compose in multiple languages [28].</li>
<li>Personalizing suggestions [28].</li>
<li>Incorporating additional context for better predictions [28].</li>
<li>Understanding how different tokenization algorithms work, such as BPE [11], SentencePiece [12], and WordPiece [29].</li>
<li>Understanding different ML objectives such as masked language modeling (MLM) and its variations [18].</li>
<li>The multi-token prediction objective and its pros and cons [30].</li>
<li>Balancing quality and inference latency [28].</li>
</ul>
<h2 id="summary">Summary</h2>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a mind map summarizing the key aspects of generative AI system design.  The central node is labeled 'Summary,' branching out into seven main categories represented by differently colored lines:  'Clarifying requirements,' 'Framing as ML,' 'Data preparation,' 'Model development,' 'Evaluation,' 'Overall system components,' and 'Other talking points.'  'Model development' further branches into 'Architecture,' 'Training,' and 'Sampling,' each with multiple sub-branches.  'Architecture' details choices like 'Transformer,' 'Encoder-only,' 'Decoder-only,' and 'Encoder-decoder,' along with 'Text embedding' and 'Positional encoding' options. 'Training' includes 'Pretraining' and 'Finetuning,' while 'Sampling' offers 'Deterministic' and 'Stochastic' methods, including 'Greedy search' and 'Beam search.' 'Evaluation' is divided into 'Offline' metrics like 'Perplexity' and 'Exact Match@N,' and 'Online' metrics such as 'User engagement,' 'Effectiveness,' 'Latency,' and 'Quality,' with sub-metrics like 'Acceptance rate,' 'Average completion time,' and 'Human evaluation.'  'Overall system components' includes 'Triggering service,' 'Phrase generator,' and 'Post-processing service.'  Finally, 'Clarifying requirements' and 'Framing as ML' detail initial considerations like specifying input/output and choosing between RNNs and Transformers, while 'Data preparation' covers text cleaning, normalization, and tokenization methods including character, word, and subword levels (with examples like Byte-Pair Encoding, SentencePiece, and WordPiece)." loading="lazy" width="566" height="796" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(566px, 100vw), (max-width: 1200px) min(566px, 80vw), min(566px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-13-V5LM3DXM.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-13-V5LM3DXM.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-13-V5LM3DXM.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-13-V5LM3DXM.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-13-V5LM3DXM.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-13-V5LM3DXM.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-13-V5LM3DXM.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-13-V5LM3DXM.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fgmail-smart-compose%2Fimage-2-13-V5LM3DXM.png&amp;w=3840&amp;q=75" style="color: transparent;"></div></figure>
<h2 id="reference-material">Reference Material</h2>
<p>[1] Gmail's Smart Compose feature. <a href="https://research.google/pubs/gmail-smart-compose-real-time-assisted-writing/" target="_blank" rel="noopener noreferrer">https://research.google/pubs/gmail-smart-compose-real-time-assisted-writing/</a>.<br>
[2] Fundamentals of Recurrent Neural Network. <a href="https://arxiv.org/abs/1808.03314" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1808.03314</a>.<br>
[3] Attention Is All You Need. <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1706.03762</a>.<br>
[4] Gated recurrent unit. <a href="https://en.wikipedia.org/wiki/Gated_recurrent_unit" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Gated_recurrent_unit</a>.<br>
[5] Long Short-Term Memory. <a href="https://deeplearning.cs.cmu.edu/F23/document/readings/LSTM.pdf" target="_blank" rel="noopener noreferrer">https://deeplearning.cs.cmu.edu/F23/document/readings/LSTM.pdf</a>.<br>
[6] RITA: Group Attention is All You Need for Timeseries Analytics. <a href="https://arxiv.org/abs/2306.01926" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2306.01926</a>.<br>
[7] FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness. <a href="https://arxiv.org/abs/2205.14135" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2205.14135</a>.<br>
[8] Language identification. <a href="https://en.wikipedia.org/wiki/Language_identification" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Language_identification</a>.<br>
[9] FastText model for language identification. <a href="https://huggingface.co/facebook/fasttext-language-identification" target="_blank" rel="noopener noreferrer">https://huggingface.co/facebook/fasttext-language-identification</a>.<br>
[10] Transformer-XL. <a href="https://arxiv.org/abs/1901.02860" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1901.02860</a>.<br>
[11] Byte-Pair Encoding tokenization. <a href="https://huggingface.co/learn/nlp-course/en/chapter6/5" target="_blank" rel="noopener noreferrer">https://huggingface.co/learn/nlp-course/en/chapter6/5</a>.<br>
[12] SentencePiece tokenization. <a href="https://arxiv.org/abs/1808.06226" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1808.06226</a>.<br>
[13] Tiktoken library. <a href="https://github.com/openai/tiktoken" target="_blank" rel="noopener noreferrer">https://github.com/openai/tiktoken</a>.<br>
[14] Google's Gemini. <a href="https://gemini.google.com/" target="_blank" rel="noopener noreferrer">https://gemini.google.com/</a>.<br>
[15] SentencePiece library. <a href="https://github.com/google/sentencepiece" target="_blank" rel="noopener noreferrer">https://github.com/google/sentencepiece</a>.<br>
[16] Summary of tokenizers. <a href="https://huggingface.co/docs/transformers/en/tokenizer_summary" target="_blank" rel="noopener noreferrer">https://huggingface.co/docs/transformers/en/tokenizer_summary</a>.<br>
[17] OpenAI's tokenizers. <a href="https://tiktokenizer.vercel.app/?model=gpt-4-1106-preview" target="_blank" rel="noopener noreferrer">https://tiktokenizer.vercel.app/?model=gpt-4-1106-preview</a>.<br>
[18] BERT. <a href="https://arxiv.org/abs/1810.04805" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1810.04805</a>.<br>
[19] OpenAI's models. <a href="https://platform.openai.com/docs/models" target="_blank" rel="noopener noreferrer">https://platform.openai.com/docs/models</a>.<br>
[20] Meta's LLaMA. <a href="https://llama.meta.com/" target="_blank" rel="noopener noreferrer">https://llama.meta.com/</a>.<br>
[21] Introduction to Transformers by Andrej Karpathy. <a href="https://www.youtube.com/watch?v=XfpMkf4rD6E" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=XfpMkf4rD6E</a>.<br>
[22] Transformer visualized. <a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener noreferrer">https://jalammar.github.io/illustrated-transformer/</a>.<br>
[23] Common Crawl. <a href="https://commoncrawl.org/" target="_blank" rel="noopener noreferrer">https://commoncrawl.org/</a>.<br>
[24] Cross-entropy. <a href="https://en.wikipedia.org/wiki/Cross-entropy" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Cross-entropy</a>.<br>
[25] Prompt engineering. <a href="https://platform.openai.com/docs/guides/prompt-engineering" target="_blank" rel="noopener noreferrer">https://platform.openai.com/docs/guides/prompt-engineering</a>.<br>
[26] Beam search. <a href="https://en.wikipedia.org/wiki/Beam_search" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Beam_search</a>.<br>
[27] Perplexity. <a href="https://en.wikipedia.org/wiki/Perplexity" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Perplexity</a>.<br>
[28] Gmail Smart Compose: Real-Time Assisted Writing. <a href="https://arxiv.org/abs/1906.00080" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1906.00080</a>.<br>
[29] WordPiece tokenization. <a href="https://huggingface.co/learn/nlp-course/en/chapter6/6" target="_blank" rel="noopener noreferrer">https://huggingface.co/learn/nlp-course/en/chapter6/6</a>.<br>
[30] Better &amp; Faster Large Language Models via Multi-token Prediction. <a href="https://arxiv.org/abs/2404.19737" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2404.19737</a>.</p>
<section data-footnotes="true" class="footnotes"><h2 class="sr-only" id="footnote-label">Footnotes</h2>
<ol>
<li id="user-content-fn-1">
<p>Visit <a href="https://platform.openai.com/tokenizer" target="_blank" rel="noopener noreferrer">https://platform.openai.com/tokenizer</a> to see examples of different tokenizers. <a data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref" href="/courses/genai-system-design-interview/gmail-smart-compose#user-content-fnref-1">↩</a></p>
</li>
</ol>
</section>
        </article>
    </main>

    <div class="nav">
        <a href="../genai-system-design-interview.html">← Course Contents</a>
        <a href="introduction-and-overview.html">← Previous</a>
        <a href="google-translate.html">Next →</a>
    </div>

    <footer class="metadata">
        <p>Scraped on 10/10/2025</p>
    </footer>
</body>
</html>