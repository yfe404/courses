<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Resolution Image Synthesis - Genai System Design Interview</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Open Sans', Arial, sans-serif;
    font-size: 16px;
    line-height: 1.6;
    color: #454545;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    font-size: 2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.2;
}

h2 {
    font-size: 1.5em;
    margin: 1.2em 0 0.6em 0;
    line-height: 1.3;
}

h3 {
    font-size: 1.2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.4;
}

p {
    margin: 0.8em 0;
}

a {
    color: #0077aa;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

ul, ol {
    margin: 0.8em 0;
    padding-left: 2em;
}

li {
    margin: 0.4em 0;
}

code, pre {
    background: #f4f4f4;
    border: 1px solid #ddd;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
}

code {
    padding: 2px 5px;
}

pre {
    padding: 10px;
    overflow-x: auto;
    margin: 1em 0;
}

pre code {
    border: none;
    padding: 0;
}

img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 1.5em auto;
}

figure {
    margin: 1.5em 0;
    text-align: center;
}

figcaption {
    font-style: italic;
    font-size: 0.9em;
    color: #666;
    margin-top: 0.5em;
}

.chapter-number {
    font-weight: bold;
    color: #0077aa;
}

.nav {
    margin: 2em 0;
    padding: 1em 0;
    border-top: 1px solid #ddd;
    border-bottom: 1px solid #ddd;
}

.nav a {
    margin-right: 1em;
}

.toc {
    list-style: none;
    padding: 0;
}

.toc li {
    margin: 0.8em 0;
}

.course-section {
    margin: 2em 0;
}

.course-title {
    font-size: 1.3em;
    font-weight: bold;
    color: #0077aa;
    margin: 1.5em 0 0.8em 0;
}

.metadata {
    font-size: 0.9em;
    color: #888;
    margin: 2em 0 1em 0;
}

.breadcrumb {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 1em;
}

.breadcrumb a {
    color: #0077aa;
}

@media (max-width: 600px) {
    body {
        padding: 10px;
    }

    h1 {
        font-size: 1.5em;
    }

    h2 {
        font-size: 1.3em;
    }
}</style>
</head>
<body>
    <div class="breadcrumb">
        <a href="../../index.html">Home</a> /
        <a href="../genai-system-design-interview.html">Genai System Design Interview</a> /
        High-Resolution Image Synthesis
    </div>

    <div class="nav">
        <a href="../genai-system-design-interview.html">← Course Contents</a>
        <a href="realistic-face-generation.html">← Previous</a>
        <a href="text-to-image-generation.html">Next →</a>
    </div>

    <main>
        <h1>
            <span class="chapter-number">08</span> High-Resolution Image Synthesis
        </h1>

        <div class="metadata">
            <a href="https://bytebytego.com/courses/genai-system-design-interview/high-resolution-image-synthesis" target="_blank" rel="noopener">Original source</a>
        </div>

        <article>
            <header><strong class="style_chapter__grtAe">08</strong><h1>High-Resolution Image Synthesis</h1></header><h2 id="introduction">Introduction</h2>
<p>Generative AI offers a fascinating ability to create highly realistic and diverse images. In this chapter, we explore a technique that enables the generation of detailed and varied images in just seconds.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a placeholder indicating that an image, likely a diagram relevant to generative AI system design interview preparation, has been removed.  The placeholder consists solely of the word 'removed' in a sans-serif font, centrally positioned. Below this, a small, separate line of text reads 'Text is not SVG - cannot display,' explaining the reason for the image's absence.  No other components, connections, information flow, labels, URLs, or parameters are visible; the image is entirely textual and provides no visual information about the original diagram's content." loading="lazy" width="784" height="288" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(784px, 100vw), (max-width: 1200px) min(784px, 80vw), min(784px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Ffigure-8-1-7SJ24SOG.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Ffigure-8-1-7SJ24SOG.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Ffigure-8-1-7SJ24SOG.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Ffigure-8-1-7SJ24SOG.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Ffigure-8-1-7SJ24SOG.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Ffigure-8-1-7SJ24SOG.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Ffigure-8-1-7SJ24SOG.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Ffigure-8-1-7SJ24SOG.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Ffigure-8-1-7SJ24SOG.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 1: An image generated by VQGAN [1]</figcaption></div></figure>
<h2 id="clarifying-requirements">Clarifying Requirements</h2>
<p>Here is a typical interaction between a candidate and an interviewer:</p>
<p><strong>Candidate</strong>: Should the system focus on specific categories of images at the start?<br>
<strong>Interviewer</strong>: For simplicity, let's begin with natural scenes and urban landscapes. We can explore other categories later.</p>
<p><strong>Candidate</strong>: Do we have training data consisting of natural scenes? What's the dataset size?<br>
<strong>Interviewer</strong>: We have a large dataset with about 5 million high-resolution images of natural scenes and landscapes.</p>
<p><strong>Candidate:</strong> Should the system support additional conditioning, such as input text describing the desired image?<br>
<strong>Interviewer:</strong> Good question. We'll focus on image generation without input conditions. However, the system should be flexible to support input prompts.</p>
<p><strong>Candidate</strong>: What resolution range should we aim for when generating the images?<br>
<strong>Interviewer</strong>: The system should generate images with either 1024<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span>1024 or 2048<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span>2048 pixels, based on user requests.</p>
<p><strong>Candidate</strong>: Should the images be generated in real time, or is some delay acceptable?<br>
<strong>Interviewer</strong>: Real-time generation isn't necessary. However, a reasonable processing time is important. Let's aim for five seconds per image.</p>
<h2 id="frame-the-problem-as-an-ml-task">Frame the Problem as an ML Task</h2>
<h3 id="specifying-the-systems-input-and-output">Specifying the system’s input and output</h3>
<p>For high-resolution image synthesis, the user simply requests a new image. The output is a high-resolution image.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified workflow for image generation.  A user, depicted as a person icon labeled 'User,' initiates the process by submitting a request, indicated by the arrow and the text 'Requesting...'. This request flows into a rectangular box with rounded corners, colored peach and outlined in gold, labeled 'Image Generation...'. This box represents the core image generation process.  Finally, an arrow points from the 'Image Generation...' box to an empty square labeled 'Generated...', signifying the output of the process – the generated image.  The overall flow is linear, showing a sequential progression from user request to image generation and delivery." loading="lazy" width="404" height="97" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-2-7URMKUHE.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 2: Input and output of an image generation system</figcaption></div></figure>
<h3 id="choosing-a-suitable-ml-approach">Choosing a suitable ML approach</h3>
<p>As discussed in Chapter 7, there are several approaches to image generation, including VAEs, GANs, autoregressive models, and diffusion models. In this section, we choose the one best suited for the task.</p>
<p>Most variants of VAEs and GANs struggle to generate high-resolution images, such as those with resolutions of 512x512 pixels and above. They face a challenge known as posterior collapse. This occurs because, as the resolution increases, these models require a decoder with a higher capacity to capture additional details. During training, the decoder can become so powerful that it starts to ignore input from the latent space, as it can model the output independently. As a result, the latent variables contribute little to the generation process, reducing the diversity of the images.</p>
<p>While both autoregressive and diffusion models can generate high-resolution images, they differ significantly in complexity and resource requirements. Autoregressive models are often considered slow due to their sequential nature, where each pixel depends on the ones generated before it. This dependency leads to a time complexity that increases linearly with the number of pixels, resulting in an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> complexity for an image of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N\times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span>, and the process is difficult to parallelize. To address this limitation, autoregressive models generate images chunk by chunk instead of pixel by pixel. For example, generating a 1024<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span>1024 image using chunks of 64<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span>64 pixels requires only 256 steps or tokens, significantly reducing the computational overhead compared to traditional pixel-based methods.</p>
<p>On the other hand, the complexity of diffusion models increases super-linearly with image size, resulting in a computational complexity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(TN^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span> is the number of pixels and T represents the number of denoising steps. Larger images often require more refinement steps to maintain quality and coherence, which further escalates computational demand.</p>
<p>In practice, generating a high-resolution image using standard diffusion models can take several minutes<sup><a id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label" href="/courses/genai-system-design-interview/high-resolution-image-synthesis#user-content-fn-1">1</a></sup>. In contrast, Transformer-based autoregressive models can accomplish similar tasks in seconds due to their chunk-based generation approach. For this chapter, we focus on autoregressive models for educational purposes. In Chapter 9, we will cover diffusion models in detail. Let's now delve into autoregressive models and their key components.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a two-part system for image processing, divided into an 'Image Tokenizer' module on the top and an 'Image Generator' module below, both delineated by dashed lines. The 'Image Tokenizer' module takes an input image, depicted by an icon, and processes it through a sequence of components: first, it enters a green trapezoidal 'Encoder', then flows to a yellow rounded rectangular 'Quantizer'. Above the Quantizer is a codebook labeled 'codebook C', visually represented as a grid of dashed rectangles within a yellow/orange textured area, with elements labeled e1 through ek referenced below it and a vertical brace labeled C. The Quantizer interacts with this codebook. The output from the Quantizer goes to a red trapezoidal 'Decoder'. The Decoder outputs an image, depicted by another icon, representing the reconstructed image from the quantized representation. The 'Image Generator' module initiates with a grey rectangular input labeled 'e6 Sampled first token', which is fed into an orange rounded rectangular 'Transformer'. The Transformer generates a sequence of tokens, shown as horizontal grey rectangles labeled 'e11 ... e77 e13'. This sequence of tokens is then passed upwards via an arrow to the 'Decoder' within the 'Image Tokenizer' module. The output from the Decoder in this context is shown leading to a dashed-line box labeled 'Generated Image', depicted by an icon of a plant in a pot, illustrating the image synthesized from the generated token sequence. Black arrows throughout the diagram indicate the direction of data flow." loading="lazy" width="633" height="421" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-3-G72EMMUJ.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 3: Autoregressive image generation</figcaption></div></figure>
<p>Autoregressive models generate images by treating them as a sequence generation task. This approach relies on two primary components:</p>
<ul>
<li>Image tokenizer</li>
<li>Image generator</li>
</ul>
<h4 id="image-tokenizer">Image tokenizer</h4>
<p>Image tokenization refers to representing an image with a sequence of discrete tokens. This is crucial in autoregressive models, where the image is generated sequentially, chunk by chunk.</p>
<p>The image tokenizer is a separate model, trained independently. Its main functions are to encode an image into a sequence of discrete tokens and decode a sequence of discrete tokens back into an image.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a diagram illustrating an image tokenizer, split into encoding and decoding processes.  The encoding section shows an input (implied, not explicitly shown) flowing into a trapezoidal 'Encoder' (light green), which outputs to a rectangular 'Quantizer' (pale yellow). The Quantizer outputs to a trapezoidal 'Decoder' (light gray), which then outputs a sequence of numerical tokens represented by boxes labeled '6,' '11,' '381,' '...,' and '72.'  These tokens are then connected to a light blue square, representing the encoded image representation.  The decoding section mirrors this, starting with the same sequence of numerical tokens ('6,' '11,' '381,' '...,' and '72') as input. These tokens are fed into a trapezoidal 'Encoder' (light gray), then a rectangular 'Quantizer' (pale yellow), and finally a trapezoidal 'Decoder' (light red), which outputs a light blue square representing the decoded image.  The connections between components show the flow of information, with the encoded image representation from the encoding section being used as input for the decoding section.  The overall structure highlights the process of converting an image into a numerical token sequence (encoding) and reconstructing the image from that sequence (decoding)." loading="lazy" width="470" height="314" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-4-63PQYD35.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 4: Image tokenizer’s encoding and decoding</figcaption></div></figure>
<h4 id="image-generator">Image generator</h4>
<p>The image generator is the primary model for generating images chunk by chunk. While there are various architectures for sequence generation, the decoder-only Transformer is the most effective choice for two reasons. First, the decoder-only Transformer has a flexible architecture that can handle different modalities. In a chatbot, it takes text tokens as input and generates text tokens as output. In image captioning, it takes an image as input and outputs text tokens. For image generation, it generates a sequence of image tokens as output, which are then decoded into an image.</p>
<p>Second, the Transformer architecture is effective at capturing long-range dependencies through its attention mechanism, which is beneficial for generating coherent images.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a comparison of three different generative AI tasks: text completion/chatbots, image captioning, and image generation.  Each task is depicted as a vertical column.  Each column shows a similar architecture: a bottom layer representing input (text for the first two, image for the third), followed by multiple smaller boxes representing an encoder, then a larger, peach-colored box labeled 'Decoder-only...', and finally a top layer representing the output (text for the first two, image for the third).  Arrows indicate the flow of information: the input feeds into the encoder, the encoder's output feeds into the decoder, and the decoder's output becomes the final output.  In the text completion/chatbot column, both input and output are text. In the image captioning column, the input is an image, and the output is text. In the image generation column, the input is text, and the output is an image, represented by a light green square.  The 'Decoder-only...' boxes suggest the use of a decoder-only transformer architecture in all three tasks." loading="lazy" width="504" height="352" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-5-7BZVHBUQ.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 5: Decoder-only Transformer’s flexibility in handling various modalities</figcaption></div></figure>
<p>In summary, we approach image generation with a Transformer-based autoregressive model. First, an image generator (decoder-only Transformer) generates a sequence of discrete tokens. Then, an image tokenizer decodes these tokens into the final image. We will explore the architecture, training, and sampling processes of these components in detail in the model development section.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system for image tokenization and generation.  At the top, a light-blue square labeled 'Image' represents the input image.  This image is fed into an 'Image Tokenizer,' depicted as a rounded rectangle containing three trapezoidal components: a light-green 'Encoder,' a beige 'Quantizer,' and a light-red 'Decoder.' The image flows from the 'Image' square into the 'Encoder,' then through the 'Quantizer,' and finally into the 'Decoder.' The 'Quantizer' processes the encoded image, outputting a sequence of numerical tokens represented by a series of boxes containing numbers (6, 11, 381, ..., 72), indicating a variable-length token sequence. These tokens are then fed into an 'Image Generator' (a peach-colored rectangle at the bottom), which generates a new image based on the provided tokens.  The 'Image Generator' then sends the generated image back to the 'Decoder' to reconstruct the image.  The ellipsis (...) between 381 and 72 indicates that there are more tokens in the sequence than are explicitly shown." loading="lazy" width="251" height="411" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-6-F4GZP66Z.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 6: Autoregressive image generation</figcaption></div></figure>
<h2 id="data-preparation">Data Preparation</h2>
<p>The data preparation process involves two crucial steps:</p>
<ul>
<li>Image cleaning and normalization</li>
<li>Image tokenization</li>
</ul>
<h3 id="image-cleaning-and-normalization">Image cleaning and normalization</h3>
<p>In this step, we remove low-quality images from the training data and ensure the remaining ones are consistent. This is achieved by applying the following operations:</p>
<ul>
<li><strong>Remove low-quality images:</strong> We remove images with low resolution, excessive noise, or irrelevant content. We also ensure the dataset includes a wide range of styles, subjects, and compositions. This step is crucial for the generative model to produce diverse, high-quality images.</li>
<li><strong>Normalize images:</strong> Normalization involves scaling pixel values to a range, typically 0 to 1, to stabilize the training process.</li>
<li><strong>Resize images:</strong> Images often come in different sizes and aspect ratios. Resizing them to a uniform size ensures the model receives consistent inputs. Based on the interviewer’s requirements, we resize all images to <em>1024x1024</em>.</li>
</ul>
<h3 id="image-tokenization">Image tokenization</h3>
<p>The image generator requires images to be represented as a sequence of discrete tokens. To achieve this, after training the image tokenizer, we tokenize all images in our training dataset into discrete tokens. It's important to note that this data preparation step is intended primarily for the image generator, not the image tokenizer.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a data processing pipeline for preparing image data for training.  It begins with a cylindrical database labeled 'Raw...' representing raw image data. This data flows right into a rectangular processing unit containing three vertically stacked steps: 'Filtering,' 'Normalization,' and 'Resizing.' The output of this unit is a second cylindrical database labeled 'Preprocessed...' containing the processed images.  This database is connected to an 'Image Tokenizer,' depicted as a bow-tie shape, composed of three sections: a green 'Encoder' on the left, a yellow 'Quantizer' in the center, and a pink 'Decoder' on the right. The preprocessed image data flows into the Encoder. The Quantizer processes the Encoder's output, and this output then flows into the Decoder. Finally, the Decoder's output is a table labeled 'Prepared training data,' which contains columns labeled 'ID' and 'Token sequence,' representing the structured data ready for model training.  The table shows multiple rows of token sequences, indicated by '...', signifying a variable number of tokens." loading="lazy" width="480" height="475" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-7-U4EVDN3X.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 7: Data preparation process</figcaption></div></figure>
<p>These two steps ensure the training data is high-quality, consistent, and represented as a sequence of numerical inputs.</p>
<h2 id="model-development">Model Development</h2>
<h3 id="architecture">Architecture</h3>
<p>In this section, we explore the architecture of both the image tokenizer and the image generator.</p>
<h4 id="image-tokenizer-1">Image tokenizer</h4>
<p>The image tokenizer model has two functions:</p>
<ol>
<li>Encoding an image into a sequence of discrete tokens</li>
<li>Decoding a sequence of discrete tokens back into an image</li>
</ol>
<p>A common architecture specifically designed for image tokenization is the Vector-Quantized VAE (VQ-VAE) [2], which is a variant of the standard VAE discussed in Chapter 7. The VQ-VAE consists of three components:</p>
<ul>
<li>Encoder</li>
<li>Quantizer</li>
<li>Decoder</li>
</ul>
<h5 id="encoder">Encoder</h5>
<p>The encoder maps the input image into a lower-dimensional latent space. This component encodes important features of the image into an encoded representation.</p>
<p>The encoder's architecture is a deep convolutional neural network (CNN) with several convolution layers, each followed by a ReLU [3] activation function. These layers process the input image and extract visual features.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified convolutional neural network (CNN) architecture for image encoding.  The process begins with an 'Image' input, depicted as a square. This image data flows rightward through a series of three convolutional layers. The first two layers, labeled 'Conv2D + ReLU,' are identical, each performing a 2D convolution followed by a Rectified Linear Unit (ReLU) activation function.  These layers are represented by light green rectangles.  The output of each layer is a 3D tensor, visually shown as progressively shrinking cubes above the layers, illustrating the dimensionality reduction that occurs through convolution and pooling (implied by the shrinking size). The third layer, simply labeled 'Conv2D,' performs only a 2D convolution, and its output is a final 3D tensor, represented by a taller, narrower cuboid labeled 'c' (likely representing the number of channels) and described as the 'Encoded representation...'. Arrows indicate the unidirectional flow of data from the input image through each layer to the final encoded representation." loading="lazy" width="584" height="189" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-8-HCJEHNBO.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 8: The encoder converts an input image into an encoded representation containing 9 features, each with c channels</figcaption></div></figure>
<h5 id="quantizer">Quantizer</h5>
<p>The quantizer converts continuous latent vectors into discrete tokens. There are two main reasons why VQ-VAE introduces a quantizer component to a standard VAE:</p>
<ul>
<li>Avoiding posterior collapse</li>
<li>Reducing the learning space</li>
</ul>
<h6 id="avoiding-posterior-collapse">Avoiding posterior collapse</h6>
<p><em>Posterior collapse</em> is a common issue in standard VAEs where the latent variables contribute little or are ignored because the decoder generates accurate outputs without using the latent space. The quantization step addresses this by discretizing the latent variables, thus forcing the model to use them during reconstruction. This ensures the decoder doesn't overpower the latent space and keeps the latent variables actively involved in shaping the output.</p>
<h6 id="reducing-the-learning-space">Reducing the learning space</h6>
<p>Continuous vectors are difficult to predict sequentially because they have endless possibilities and small differences. By turning these vectors into discrete tokens, the quantizer simplifies the process by allowing the Transformer to focus on fewer options.</p>
<p>The quantizer uses an internal codebook to convert continuous latent vectors into discrete tokens. This codebook contains learnable embeddings that represent different patterns in the input images. Each embedding acts as a token, represented by an integer from 1 to k. The quantizer replaces each continuous vector with the closest token in the codebook based on Euclidean distance [4].</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified illustration of a quantization process likely within a generative AI system.  A three-dimensional data cube, appearing as a stack of smaller cubes, represents the input data. This cube is connected to a labeled 'Quantizer' box, suggesting a transformation process. The quantizer takes the input data and outputs a smaller, two-dimensional matrix (a grid of numbers: 1 2 7 8; 4 3 6 3; 7 9 6 8), representing the quantized version of the input.  Above the quantizer, a larger, rectangular grid divided into six vertical sections, each further subdivided into smaller cells, likely represents the memory or storage location where the quantized data is stored or processed further. The overall arrangement shows the flow of data from a high-dimensional input (the cube) through a quantization step (the quantizer box) resulting in a lower-dimensional, compressed representation (the matrix) stored in a designated memory area (the large grid).  The style suggests a conceptual diagram rather than a precise technical representation." loading="lazy" width="423" height="370" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(423px, 100vw), (max-width: 1200px) min(423px, 80vw), min(423px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-1-MVLDLKYX.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-1-MVLDLKYX.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-1-MVLDLKYX.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-1-MVLDLKYX.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-1-MVLDLKYX.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-1-MVLDLKYX.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-1-MVLDLKYX.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-1-MVLDLKYX.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-1-MVLDLKYX.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 9: Quantization process</figcaption></div></figure>
<p>Note that the quantizer is an embedding table. Its sole parameter is the codebook, which is learned during training. The quantizer’s single responsibility is to map each continuous vector with the closest token in the codebook; therefore, the output is a collection of token IDs.</p>
<h5 id="decoder">Decoder</h5>
<p>The decoder converts discrete tokens back into the original image. It typically uses a deep CNN with transposed convolutions (<em>ConvTranspose2d</em>) to gradually transform the representation to the original image size. To learn more about convolutions and transposed convolutions, refer to [5].</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a process flow starting with a grid of numbers, which is transformed into an image using a codebook. At the top is a box labeled 'Codebook', depicted as a grid of vertical segments labeled e1 through ek, representing embedding vectors, with a vertical brace labeled c indicating dimension. The process begins with a 3x3 grid of numbers (1, 27, 8, 43, 6, 33, 7, 96, 81) which is input into a purple rounded rectangle labeled 'Embedding Lookup'. An arrow points from 'Embedding Lookup' upwards to the 'Codebook', indicating that the numbers in the grid are used to look up embeddings from the codebook. The output of the 'Embedding Lookup' is represented by a 3D block composed of a 3x3 grid of smaller cubes, with a vertical brace labeled c on the left. This block is then processed sequentially through three red rounded rectangles, each labeled 'Transposed conv + ReLU'. Arrows connect the output of one stage to the input of the next. Intermediate outputs between the 'Transposed conv + ReLU' blocks are shown as larger 3D cuboids, growing in size and filled with grey or left unfilled, suggesting spatial upsampling. The final output after the third 'Transposed conv + ReLU' block is an outline of a square with an image icon inside, labeled 'Image' below, representing the resulting generated image. The diagram illustrates the process of converting a grid of discrete indices (numbers) into a continuous representation (embeddings) from a codebook, and then using transposed convolutions and ReLU activation functions to upsample this representation into a full image." loading="lazy" width="600" height="360" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-10-BLFPCVZB.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 10: Decoding process</figcaption></div></figure>
<h4 id="image-generator-1">Image generator</h4>
<p>The image generator generates a sequence of discrete tokens representing an image. As mentioned earlier, a decoder-only Transformer is often used for sequence generation tasks, which includes the following components:</p>
<ul>
<li><strong>Embedding lookup:</strong> Replaces each discrete token with its embedding from the codebook.</li>
<li><strong>Projection:</strong> Projects each token embedding into a dimensionality that matches the Transformer's internal representation.</li>
<li><strong>Positional encoding:</strong> Adds positional encodings to the sequence to provide spatial information.</li>
<li><strong>Transformer:</strong> Processes the input sequence and outputs an updated sequence of vectors.</li>
<li><strong>Prediction head:</strong> Utilizes the updated embeddings to predict the next token.</li>
</ul>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a generative model architecture, likely for text generation.  On the left, a 'Codebook' is depicted as a collection of vectors (represented by columns of cells labeled with '$e...') which are indexed by 'c'.  A thick arrow indicates these vectors are input to an 'Embedding Lookup' layer. This layer receives input from 'Previously genera...' (presumably previously generated tokens) and outputs embeddings.  These embeddings then pass through a 'Projection' layer and a 'Positional Encoding' layer before entering a 'Transformer' block. The Transformer consists of stacked layers of 'Multi-head...', 'Normalization', 'Feed Forward', and another 'Normalization' layer, repeated 'Nx' times.  The output of the Transformer feeds into a 'Prediction Head' layer, which ultimately produces the 'Predicted n...' (presumably the next token in the sequence).  The overall flow is sequential, with information moving from the codebook, through embedding and transformer layers, culminating in a prediction." loading="lazy" width="465" height="413" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-11-BIXTWXD2.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 11: Decoder-only Transformer components</figcaption></div></figure>
<h3 id="training">Training</h3>
<p>In autoregressive image generation, we have two training stages:</p>
<ul>
<li>Stage I: Training the image tokenizer</li>
<li>Stage II: Training the image generator</li>
</ul>
<h4 id="stage-i-training-the-image-tokenizer">Stage I: Training the image tokenizer</h4>
<p>The training process involves optimizing the encoder, decoder, and codebook so the model can accurately reconstruct the original images. This process can be described in three steps:</p>
<ol>
<li>The encoder processes an input image and converts it into a continuous representation.</li>
<li>The quantizer replaces the continuous representation with discrete tokens using its internal codebook.</li>
<li>The decoder uses the discrete tokens to reconstruct the original image.</li>
</ol>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system for compressing and reconstructing an image using a codebook-based quantization approach. The diagram shows a flow from an input image to a reconstructed image. The process begins with an 'Image', depicted as a square with a landscape icon, which is fed into a green rounded rectangular 'Encoder'. The output of the Encoder is a 3D block structure labeled with a vertical brace 'c', representing a compressed or feature space representation. This output is then processed by a yellow rounded rectangular 'Quantizer'. Above the Quantizer is a large box labeled 'Codebook', visually represented as a grid of vertical segments representing embeddings (e1 through ek) within a yellow textured area, with a vertical brace 'c' indicating dimension. An arrow points from the Quantizer upwards to the Codebook, suggesting the Quantizer interacts with the Codebook. Additionally, an arrow points from the Codebook downwards to the 3D block output of the Encoder, implying the Codebook is used in relation to the encoded representation, likely for finding the nearest embedding vectors. The Quantizer outputs a 3x3 grid of numbers (specifically showing the values 6, 28, 3 in the top row, 16, 97, 41 in the middle row, and 26, 39, 7 in the bottom row), representing the quantized indices from the Codebook. This grid of numbers is then input into a red rounded rectangular 'Decoder'. The Decoder takes these indices and outputs a square with a landscape icon, labeled 'Reconstructed image', completing the compression and reconstruction cycle. Arrows indicate the direction of data flow through the system components." loading="lazy" width="472" height="340" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-12-ANHE7F3R.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 12: Image tokenizer training process</figcaption></div></figure>
<p>Since the quantizer lookup operation lacks a well-defined gradient for backpropagation, the VQ-VAE paper proposes approximating the gradient by copying it from the decoder input directly to the encoder output. This approach means that only the selected tokens receive gradients from the decoder, while unselected tokens do not receive any gradients.</p>
<h5 id="training-data">Training data</h5>
<p>We train the image tokenizer with 5 million images. Since the training is self-supervised and doesn't require image labels, we include other publicly available image datasets to enhance the tokenizer's robustness. In particular, we use the <em>LAION-400M</em> dataset [6], which contains 400 million images. This results in a richer codebook that captures diverse visual patterns.</p>
<h5 id="ml-objective-and-loss-function">ML objective and loss function</h5>
<p>The ML objective of the image tokenizer is to accurately reconstruct original images from their quantized tokens. To achieve this ML objective, the following loss functions are typically employed during the training process:</p>
<ul>
<li>Reconstruction loss</li>
<li>Quantization loss</li>
</ul>
<p><strong>Reconstruction loss:</strong> The reconstruction loss measures the difference between the original image and its reconstruction from the quantized tokens. It is typically calculated using the mean squared error (MSE) formula:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Reconstruction&nbsp;loss</mtext><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mover accent="true"><mi>x</mi><mo>^</mo></mover><mi>i</mi></msub><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\text {Reconstruction loss}=\frac{1}{n} \sum_{i=1}^n\left(x_i-\hat{x}_i\right)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">Reconstruction&nbsp;loss</span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.9291em; vertical-align: -1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3214em;"><span style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span style="top: -1.8723em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal">x</span></span><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.954em;"><span style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>
<p>Where:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span> is the pixel value of the original image,</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>x</mi><mo>^</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\hat{x}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal">x</span></span><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span> is the pixel value of the reconstructed image,</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is the total number of pixels in the image.</li>
</ul>
<p><strong>Quantization loss:</strong> The quantization loss measures the distance between the encoder’s outputs and the nearest embedding in the codebook. This loss encourages the encoder to produce outputs that are closer to the codebook embeddings.</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Quantization&nbsp;loss</mtext><mo>=</mo><msubsup><mrow><mo fence="true">∥</mo><mi mathvariant="normal">sg</mi><mo>⁡</mo><mo stretchy="false">[</mo><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>−</mo><msub><mi>z</mi><mi>q</mi></msub><mo fence="true">∥</mo></mrow><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mrow><mo fence="true">∥</mo><mi mathvariant="normal">sg</mi><mo>⁡</mo><mrow><mo fence="true">[</mo><msub><mi>z</mi><mi>q</mi></msub><mo fence="true">]</mo></mrow><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo fence="true">∥</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\text {Quantization loss}=\left\|\operatorname{sg}[E(x)]-z_q\right\|_2^2+\left\|\operatorname{sg}\left[z_q\right]-E(x)\right\|_2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord text"><span class="mord">Quantization&nbsp;loss</span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.2898em; vertical-align: -0.3358em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top: 0em;">∥</span><span class="mop"><span class="mord mathrm" style="margin-right: 0.01389em;">sg</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)]</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">∥</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.954em;"><span style="top: -2.3642em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.2898em; vertical-align: -0.3358em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top: 0em;">∥</span><span class="mop"><span class="mord mathrm" style="margin-right: 0.01389em;">sg</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">]</span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose delimcenter" style="top: 0em;">∥</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.954em;"><span style="top: -2.3642em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3358em;"><span></span></span></span></span></span></span></span></span></span></span>
<p>Where:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> is the continuous latent vector produced by the encoder, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.05764em;">E</span></span></span></span>, from the input <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">z_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span></span></span></span></span></span></span></span></span></span> is the quantized latent vector selected from the codebook <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.07153em;">Z</span></span></span></span>,</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">sg</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{sg}(.)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop"><span class="mord mathrm" style="margin-right: 0.01389em;">sg</span></span><span class="mopen">(</span><span class="mord">.</span><span class="mclose">)</span></span></span></span> represents the stop-gradient operation that blocks the gradients from flowing through the term. It is used here to prevent the codebook from being updated when optimizing the encoder.</li>
</ul>
<p>For more details on the quantization loss formula, refer to the <em>VQGAN</em> paper [1].</p>
<p>In practice, using both reconstruction loss and quantization loss during training works well for reconstructing low-resolution images. However, for high-resolution images, the model may still produce artifacts. To improve reconstruction quality at high resolutions, two additional loss functions are typically employed:</p>
<ul>
<li>Perceptual loss</li>
<li>Adversarial loss</li>
</ul>
<p><strong>Perceptual loss:</strong> Perceptual loss measures the difference between the features of the original and reconstructed images extracted from a specific layer of a pretrained model such as <em>VGG</em> [7]. The formula is:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>&nbsp;Perceptual&nbsp;loss&nbsp;</mtext><mo>=</mo><munder><mo>∑</mo><mi>l</mi></munder><msubsup><mrow><mo fence="true">∥</mo><msub><mi>ϕ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>ϕ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo fence="true">∥</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\text { Perceptual loss }=\sum_l\left\|\phi_l(x)-\phi_l(\hat{x})\right\|_2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord text"><span class="mord">&nbsp;Perceptual&nbsp;loss&nbsp;</span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.3521em; vertical-align: -1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span style="top: -1.8479em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.01968em;">l</span></span></span><span style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top: 0em;">∥</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal">x</span></span><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose delimcenter" style="top: 0em;">∥</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.954em;"><span style="top: -2.4003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2997em;"><span></span></span></span></span></span></span></span></span></span></span>
<p>Where:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">\phi_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span> denotes the feature map of the layer, l, from a pretrained VGG model,</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is the original image,</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal">x</span></span><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.2222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> is the reconstructed image.</li>
</ul>
<p>The perceptual loss encourages the model to reconstruct images that are perceptually similar to the original images. <em>VGG</em> features encode high-level details such as content and style. The perception loss guides the training process so that the model can better preserve these details in the reconstructed images.</p>
<p><strong>Adversarial loss:</strong> Adversarial loss is derived from <em>GANs</em> [8], where a discriminator tries to distinguish between real and reconstructed images. This loss is used to measure how well the image reconstructed by the image tokenizer can fool the discriminator. The formula, as we saw in Chapter 7, is:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Adversarial&nbsp;loss</mtext><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text {Adversarial loss}=-\log (D(\hat{x}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">Adversarial&nbsp;loss</span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.02778em;">D</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal">x</span></span><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span>
<p>Where:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">D</span></span></span></span> is the discriminator network,</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal">x</span></span><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.2222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> is the reconstructed image.</li>
</ul>
<p>This loss function encourages the model to produce reconstructed images that a trained discriminator cannot distinguish from real images. The <em>VQGAN</em> paper introduced a patch-based version of this loss to reduce unnatural artifacts and improve the realism of the reconstructions.</p>
<p><strong>Overall loss:</strong> The overall loss function is often a weighted sum of the individual losses described above. The weights <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>λ</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\lambda_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> are hyperparameters that need tuning based on specific performance goals and experiments.</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>&nbsp;Overall&nbsp;loss&nbsp;</mtext><mo>=</mo><msub><mi>λ</mi><mtext>rec&nbsp;</mtext></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>×</mo><mtext>&nbsp;reconstruction&nbsp;loss&nbsp;</mtext><mo>+</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>λ</mi><mtext>quant&nbsp;</mtext></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>×</mo><mtext>&nbsp;quantization&nbsp;loss&nbsp;</mtext><mo>+</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>λ</mi><mtext>perc&nbsp;</mtext></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>×</mo><mtext>&nbsp;perceptual&nbsp;loss&nbsp;</mtext><mo>+</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>λ</mi><mtext>adv&nbsp;</mtext></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>×</mo><mtext>&nbsp;adversarial&nbsp;loss&nbsp;</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
	\text { Overall loss }=  \lambda_{\text {rec }} &amp; \times \text { reconstruction loss }+ \\
	 \lambda_{\text {quant }} &amp;\times \text { quantization loss }+ \\
	 \lambda_{\text {perc }} &amp;\times \text { perceptual loss }+ \\
	 \lambda_{\text {adv }} &amp;\times \text { adversarial loss }
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 6em; vertical-align: -2.75em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 3.25em;"><span style="top: -5.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;Overall&nbsp;loss&nbsp;</span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">rec&nbsp;</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span><span style="top: -3.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.2806em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">quant&nbsp;</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">perc&nbsp;</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top: -0.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">adv&nbsp;</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.75em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 3.25em;"><span style="top: -5.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord text"><span class="mord">&nbsp;reconstruction&nbsp;loss&nbsp;</span></span><span class="mord">+</span></span></span><span style="top: -3.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord text"><span class="mord">&nbsp;quantization&nbsp;loss&nbsp;</span></span><span class="mord">+</span></span></span><span style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord text"><span class="mord">&nbsp;perceptual&nbsp;loss&nbsp;</span></span><span class="mord">+</span></span></span><span style="top: -0.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord text"><span class="mord">&nbsp;adversarial&nbsp;loss&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.75em;"><span></span></span></span></span></span></span></span></span></span></span></span>
<p>After training the image tokenizer, we convert all 5 million training images into
discrete tokens and cache them, as detailed in the data preparation section. This
step ensures that all images are represented as a sequence of discrete tokens, which
is required for training the image generator.</p>
<h4 id="stage-ii-training-the-image-generator">Stage II: Training the image generator</h4>
<p>Training the image generator, which is a decoder-only Transformer, is similar to the process described in earlier chapters. The training data consists of sequences of discrete tokens, and the model learns to predict these tokens sequentially during training.</p>
<p>We employ next-token prediction as our ML objective and cross-entropy as the loss function to measure how accurate the predicted probabilities are compared to the correct visual tokens.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified diagram of a generative model's training process.  At the top, a column labeled 'Correct nex...' displays a sequence of four numbers: 0, 0, 1, 0. This represents the target or ground truth output sequence. Below, a column labeled 'Predicted...' shows the model's predicted output sequence: 0.1, 0, 0.8, 0.1.  These are probability values, indicating the model's confidence in each predicted digit. An arrow labeled 'loss' connects these two columns, signifying the calculation of a loss function to quantify the difference between the predicted and correct sequences.  This loss value is then used to update the model's parameters. At the bottom, a rectangular box labeled 'Image Generator...' represents the core generative model. Four upward arrows connect this box to four smaller boxes containing the numbers 1, 27, 8, and 16, which likely represent input parameters or features fed into the image generator. The overall flow shows how input parameters are processed by the image generator to produce a predicted sequence, which is then compared to the correct sequence to calculate a loss, enabling model training through backpropagation (implied, not explicitly shown)." loading="lazy" width="206" height="352" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-13-TYIGS3YR.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 13: Image generator loss calculation</figcaption></div></figure>
<h3 id="sampling">Sampling</h3>
<p>In autoregressive models, generating a new image involves two steps:</p>
<ol>
<li>Generating a sequence of discrete tokens</li>
<li>Decoding discrete tokens into an image</li>
</ol>
<h4 id="1-generating-a-sequence-of-discrete-tokens">1. Generating a sequence of discrete tokens</h4>
<p>In the first step, the image generator produces a sequence of tokens. The autoregressive nature of the generation ensures that each token is conditioned on preceding tokens, leading to coherent images.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system for generating images.  On the left, a labeled box 'Codeb...' depicts a matrix or grid structure representing a codebook, with multiple cells (represented by smaller squares) containing unspecified values ('$$...$...') and labeled 'C' at the top left. A grey curved arrow connects this codebook to a rectangular box labeled 'Image Generator' in light orange.  This arrow is labeled 'Randomly selecting the f...', indicating a random selection of features from the codebook is fed into the Image Generator. The Image Generator receives input from three visible numbered squares (6, 27, 8) at the bottom, representing selected features.  Above the Image Generator, multiple vertical stacks of smaller squares labeled 'Predicted...' represent the generated image features. Each stack is topped by a numbered square (27, 8, 72), labeled 'Selected...', indicating the selected features for each generated image.  Dashed lines connect the input features (6, 27, 8) to the Image Generator and the Image Generator's output (Predicted...) to the selected features (27, 8, 72), suggesting a feedback loop or iterative process.  An ellipsis ('...') indicates that the system can handle more than three input features and generate more than three images." loading="lazy" width="524" height="339" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-14-ETCOCZBV.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 14: Generating a sequence of discrete tokens using the image generator</figcaption></div></figure>
<p>Here is a step-by-step process to autoregressively generate a sequence of tokens:</p>
<ol>
<li>Randomly select a token from the codebook as the first token. This initial token acts as a seed for the rest of the generation process.</li>
<li>Autoregressively generate tokens one by one. This involves:
<ol>
<li>Passing the current sequence of tokens to the image generator to predict the probability distribution over the codebook</li>
<li>Selecting the next token using a sampling method such as <em>top-p</em> sampling</li>
<li>Appending the chosen token to the current sequence</li>
</ol>
</li>
</ol>
<p>This process continues until the entire image is generated. The number of iterations depends on the resolution and size of the desired output image. For example, generating an image of 1024<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span>1024 pixels, with each visual token representing a 64<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span>64 pixel block, requires 256 tokens. The process continues until all 256 tokens are generated. Once the sequence of tokens is complete, it is transformed into an actual image, which is the focus of the next step.</p>
<h4 id="2-decoding-discrete-tokens-into-an-image">2. Decoding discrete tokens into an image</h4>
<p>In this step, the sequence of discrete tokens is transformed into an image by using the decoding functionality of the image tokenizer.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a two-step process for image generation.  Step 1 begins with a single numerical input '6', which feeds into an 'Image Generator'. This generator outputs a sequence of numbers (27, 8, 40, ..., 72), represented as a one-dimensional array.  A 'Reshape' operation then transforms this array into a two-dimensional matrix (3x3 in this example: 6, 27, 8; 40, 97, 41; 26, 39, 72). This matrix is then input into an 'Image Tokenizer', which consists of three components: an 'Encoder' (light green), a 'Quantizer' (beige), and a 'Decoder' (light red). The quantizer processes the matrix, and the decoder outputs a tokenized representation.  Step 2 involves this tokenized output being fed into a (blank) 'Generated...' box, implying the final image generation step.  The arrows indicate the flow of data between components, showing the transformation of the initial input '6' into a matrix, then a tokenized representation, and finally, a generated image." loading="lazy" width="452" height="492" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-15-63IZAYFF.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 15: Decoding tokens into an image</figcaption></div></figure>
<h2 id="evaluation">Evaluation</h2>
<p>The evaluation metrics for high-resolution image synthesis are similar to those in Chapter 7. We'll briefly review them in this section without going into detail.</p>
<h3 id="offline-evaluation-metrics">Offline evaluation metrics</h3>
<p>The following metrics are typically employed to measure the quality and diversity of the generated images:</p>
<ul>
<li><strong>Inception score:</strong> Measures how similar the generated images are to images of real-world objects by utilizing a pretrained <em>Inception v3</em> model. To learn more about the Inception score, refer to [9].</li>
<li><strong>Fréchet inception distance (FID):</strong> Compares the distribution of generated images to real images by comparing features extracted from a pretrained <em>Inception v3</em> model. This metric measures how similar the statistics of generated and real images are. To learn more about FID, refer to [10].</li>
<li><strong>Human evaluation:</strong> Human evaluators are presented with pairs of images and asked to judge their photorealism and aesthetic qualities. The votes provide a statistical measure of which models produce more realistic images over time.</li>
</ul>
<p>In addition to those metrics, it is common to evaluate other aspects of the model such as latency and cost.</p>
<ul>
<li><strong>Time to generate an image:</strong> Measures the time it takes for the model to generate an image. This metric is important to monitor since users generally expect quick results.</li>
<li><strong>Cost per generation:</strong> Calculates the cost to generate an image. This metric depends on factors such as model complexity, resolution, and infrastructure expenses. Monitoring the cost of generation is crucial as it impacts business revenue.</li>
</ul>
<h3 id="online-evaluation-metrics">Online evaluation metrics</h3>
<p>In practice, companies monitor various metrics to assess the system's real-time quality. Common metrics include:</p>
<ul>
<li><strong>User feedback:</strong> Collects direct feedback from users regarding generated images.</li>
<li><strong>Periodic surveys:</strong> Gathers user opinions on the quality and relevance of generated images.</li>
<li><strong>Subscription rate:</strong> Measures how often users subscribe to services or features related to image generation.</li>
<li><strong>Churn rate</strong>: Measures the rate at which users stop using the service.</li>
</ul>
<h2 id="overall-ml-system-design">Overall ML System Design</h2>
<p>Once we are satisfied with the performance of the image generator and image tokenizer models, we can integrate them to construct the image synthesis system. The primary components in a high-resolution image synthesis system are:</p>
<ul>
<li>Generation service</li>
<li>Decoding service</li>
<li>Super-resolution service</li>
</ul>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified architecture diagram of an image generation system.  A user icon initiates the process, sending a request to a 'Generation...' module (light orange), which likely generates a lower-resolution image. This image is then passed to a 'Decoding...' module (light purple).  Simultaneously, the 'Generation...' module receives input from a cloud-shaped 'Image...' component, suggesting feedback or pre-existing image data is used.  The 'Decoding...' module receives input from a trapezoidal 'Tokenizer...' component, likely processing textual input for image generation. The output of 'Decoding...' feeds into a 'Super-Resolution...' module (light blue), which upscales the image resolution.  The final output, a higher-resolution image (indicated by a large square labeled '2048 x 2048'), is produced.  Intermediate stages are labeled with dimensions '1024 x 1024,' indicating image size at those points.  Arrows show the unidirectional flow of data between modules.  A small grid of squares above the 'Decoding...' module might represent a tokenized text input." loading="lazy" width="632" height="255" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/genai-system-design-interview/high-resolution-image-synthesis/figure-8-16-RA4BP4II.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 16: High-resolution image synthesis ML design</figcaption></div></figure>
<p>Understanding the purpose of each component and their interactions will provide a holistic view of the system. Let’s explore each in more detail.</p>
<h3 id="generation-service">Generation service</h3>
<p>The generation service handles user requests and interacts with the trained image generator model to produce a sequence of visual tokens.</p>
<h3 id="decoding-service">Decoding service</h3>
<p>The decoding service interacts with the image tokenizer to convert the generated sequence of visual tokens into an image. Note that when we deploy the model, we don’t need the encoder in the image tokenizer – it is only used during training.</p>
<p>Separating generation and decoding services is crucial because the image generator and tokenizer are different models with distinct computational needs and latencies. This approach allows each service to scale independently and manage resources efficiently.</p>
<h3 id="super-resolution-service">Super-resolution service</h3>
<p>Super-resolution service uses a pretrained model to increase the resolution of generated images. For example, if the desired resolution is 2048<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span>2048 but the generator produces only 1024<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord">×</span></span></span></span>1024, we use a super-resolution model with a 2x upscale factor.</p>
<p>This service is crucial for applications requiring detailed and realistic visuals, such as medical imaging. There are many established solutions for super-resolution, from CNN-based [11] to GAN-improved [12]. To learn more about recent approaches, refer to [13].</p>
<h2 id="other-talking-points">Other Talking Points</h2>
<p>If there's time remaining at the end of the interview, you could explore these additional points:</p>
<ul>
<li>Extending autoregressive models to support text-based generation [14] [15].</li>
<li>Support applications such as image completion and image super-resolution [16].</li>
<li>Balancing diversity vs. fidelity in sampling, using techniques such as temperature scaling [17].</li>
<li>Enhancing the stability with adversarial training, gradient clipping, and learning rate scheduling [18][19].</li>
<li>Using progressive growing and multi-scale architectures to improve image quality and detail [20].</li>
<li>Creating interactive systems for users to refine and customize generated images [21].</li>
</ul>
<h2 id="summary">Summary</h2>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a mind map summarizing the key aspects of designing a generative AI system for image generation.  The central element is a box labeled 'Summary,' from which several main branches radiate, each representing a crucial stage or component.  These branches include 'Clarifying requirements' (further branching into 'Framing as ML' with sub-branches 'ML approach' and 'Autoregressive modeling,' and 'Specifying input and output'); 'Data preparation' (branching into 'Image cleaning and normalization' and 'Image tokenization'); 'Model development' (branching into 'Architecture' detailing components like 'Image tokenizer,' 'Image generator,' and 'Decoder-only Transformer,' and 'Training' specifying loss functions such as 'Reconstruction loss,' 'Quantization loss,' 'Perceptual loss,' 'Adversarial loss,' and 'Cross-entropy loss,' along with processes like 'Generating discrete tokens' and 'Decoding tokens into an image'); 'Evaluation' (dividing into 'Offline' with metrics like 'Inception score,' 'FID,' 'Human evaluation,' 'Time to generate an image,' and 'Cost per generation,' and 'Online' with metrics like 'User feedback,' 'Periodic surveys,' 'Subscription rate,' and 'Churn rate'); and 'Overall system components' (branching into 'Generation service,' 'Decoding service,' and 'Super-resolution service'). Finally, a branch labeled 'Other talking points' is also present.  Each branch uses color-coding for visual distinction, and the overall structure is hierarchical, showing the relationships between different stages and components in the design process." loading="lazy" width="677" height="926" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(677px, 100vw), (max-width: 1200px) min(677px, 80vw), min(677px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-14-4W6ENO2S.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-14-4W6ENO2S.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-14-4W6ENO2S.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-14-4W6ENO2S.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-14-4W6ENO2S.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-14-4W6ENO2S.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-14-4W6ENO2S.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-14-4W6ENO2S.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fgenai-system-design-interview%2Fhigh-resolution-image-synthesis%2Fimage-8-14-4W6ENO2S.png&amp;w=3840&amp;q=75" style="color: transparent;"></div></figure>
<h2 id="reference-material">Reference Material</h2>
<p>[1] Taming Transformers for High-Resolution Image Synthesis. <a href="https://arxiv.org/abs/2012.09841" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2012.09841</a>.<br>
[2] Neural Discrete Representation Learning. <a href="https://arxiv.org/abs/1711.00937" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1711.00937</a>.<br>
[3] Deep Learning using Rectified Linear Units (ReLU). <a href="https://arxiv.org/abs/1803.08375" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1803.08375</a>.<br>
[4] Euclidean distance. <a href="https://en.wikipedia.org/wiki/Euclidean_distance" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Euclidean_distance</a>.<br>
[5] A guide to convolution arithmetic for deep learning. <a href="https://arxiv.org/abs/1603.07285" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1603.07285</a>.<br>
[6] LAION data set 400 million <a href="https://laion.ai/blog/laion-400-open-dataset/" target="_blank" rel="noopener noreferrer">https://laion.ai/blog/laion-400-open-dataset/</a>.<br>
[7] Very Deep Convolutional Networks for Large-Scale Image Recognition. <a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1409.1556</a>.<br>
[8] Generative Adversarial Networks. <a href="https://arxiv.org/abs/1406.2661" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1406.2661</a>.<br>
[9] Inception score. <a href="https://en.wikipedia.org/wiki/Inception_score" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Inception_score</a>.<br>
[10] FID calculation. <a href="https://en.wikipedia.org/wiki/Fr%C3%A9chet_inception_distance" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Fr%C3%A9chet_inception_distance</a>.<br>
[11] Image Super-Resolution Using Very Deep Residual Channel Attention Networks. <a href="https://arxiv.org/abs/1807.02758" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1807.02758</a>.<br>
[12] ESRGAN: Enhanced Super-Resolution Generative Adversarial Networks. <a href="https://arxiv.org/abs/1809.00219" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1809.00219</a>.<br>
[13] NTIRE 2024 Challenge on Image Super-Resolution (×4): Methods and Results. <a href="https://arxiv.org/abs/2404.09790" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2404.09790</a>.<br>
[14] Muse: Text-To-Image Generation via Masked Generative Transformers. <a href="https://arxiv.org/abs/2301.00704" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2301.00704</a>.<br>
[15] VQGAN-CLIP: Open Domain Image Generation and Editing with Natural Language Guidance. <a href="https://arxiv.org/abs/2204.08583" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2204.08583</a>.<br>
[16] LAR-SR: A Local Autoregressive Model for Image Super-Resolution. <a href="https://openaccess.thecvf.com/content/CVPR2022/papers/Guo_LAR-SR_A_Local_Autoregressive_Model_for_Image_Super-Resolution_CVPR_2022_paper.pdf" target="_blank" rel="noopener noreferrer">https://openaccess.thecvf.com/content/CVPR2022/papers/ Guo_LAR-SR_A_Local_Autoregressive_Model_for_Image_Super-Resolution_CVPR_2022_paper.pdf</a>.<br>
[17] Long Horizon Temperature Scaling. <a href="https://arxiv.org/abs/2302.03686" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2302.03686</a>.<br>
[18] Learning Rate Scheduling. <a href="https://d2l.ai/chapter_optimization/lr-scheduler.html" target="_blank" rel="noopener noreferrer">https://d2l.ai/chapter_optimization/lr-scheduler.html</a>.<br>
[19] Adversarial Training. <a href="https://adversarial-ml-tutorial.org/adversarial_training/" target="_blank" rel="noopener noreferrer">https://adversarial-ml-tutorial.org/adversarial_training/</a>.<br>
[20] Progressive Growing of GANs for Improved Quality, Stability, and Variation. <a href="https://arxiv.org/abs/1710.10196" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1710.10196</a>.<br>
[21] CogView2: Faster and Better Text-to-Image Generation via Hierarchical Transformers. <a href="https://arxiv.org/abs/2204.14217" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2204.14217</a>.</p>
<section data-footnotes="true" class="footnotes"><h2 class="sr-only" id="footnote-label">Footnotes</h2>
<ol>
<li id="user-content-fn-1">
<p>Certain optimizations and techniques (e.g., latent diffusion model) can significantly speed up the generation process in diffusion models. These methods are discussed in detail in Chapter 10 and Chapter 11. <a data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref" href="/courses/genai-system-design-interview/high-resolution-image-synthesis#user-content-fnref-1">↩</a></p>
</li>
</ol>
</section>
        </article>
    </main>

    <div class="nav">
        <a href="../genai-system-design-interview.html">← Course Contents</a>
        <a href="realistic-face-generation.html">← Previous</a>
        <a href="text-to-image-generation.html">Next →</a>
    </div>

    <footer class="metadata">
        <p>Scraped on 10/10/2025</p>
    </footer>
</body>
</html>