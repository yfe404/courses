<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hotel reservation app - Mobile System Design Interview</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Open Sans', Arial, sans-serif;
    font-size: 16px;
    line-height: 1.6;
    color: #454545;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    font-size: 2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.2;
}

h2 {
    font-size: 1.5em;
    margin: 1.2em 0 0.6em 0;
    line-height: 1.3;
}

h3 {
    font-size: 1.2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.4;
}

p {
    margin: 0.8em 0;
}

a {
    color: #0077aa;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

ul, ol {
    margin: 0.8em 0;
    padding-left: 2em;
}

li {
    margin: 0.4em 0;
}

code, pre {
    background: #f4f4f4;
    border: 1px solid #ddd;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
}

code {
    padding: 2px 5px;
}

pre {
    padding: 10px;
    overflow-x: auto;
    margin: 1em 0;
}

pre code {
    border: none;
    padding: 0;
}

img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 1.5em auto;
}

figure {
    margin: 1.5em 0;
    text-align: center;
}

figcaption {
    font-style: italic;
    font-size: 0.9em;
    color: #666;
    margin-top: 0.5em;
}

.chapter-number {
    font-weight: bold;
    color: #0077aa;
}

.nav {
    margin: 2em 0;
    padding: 1em 0;
    border-top: 1px solid #ddd;
    border-bottom: 1px solid #ddd;
}

.nav a {
    margin-right: 1em;
}

.toc {
    list-style: none;
    padding: 0;
}

.toc li {
    margin: 0.8em 0;
}

.course-section {
    margin: 2em 0;
}

.course-title {
    font-size: 1.3em;
    font-weight: bold;
    color: #0077aa;
    margin: 1.5em 0 0.8em 0;
}

.metadata {
    font-size: 0.9em;
    color: #888;
    margin: 2em 0 1em 0;
}

.breadcrumb {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 1em;
}

.breadcrumb a {
    color: #0077aa;
}

@media (max-width: 600px) {
    body {
        padding: 10px;
    }

    h1 {
        font-size: 1.5em;
    }

    h2 {
        font-size: 1.3em;
    }
}</style>
</head>
<body>
    <div class="breadcrumb">
        <a href="../../index.html">Home</a> /
        <a href="../mobile-system-design-interview.html">Mobile System Design Interview</a> /
        Hotel reservation app
    </div>

    <div class="nav">
        <a href="../mobile-system-design-interview.html">← Course Contents</a>
        <a href="pagination-library.html">← Previous</a>
        <a href="google-drive-app.html">Next →</a>
    </div>

    <main>
        <h1>
            <span class="chapter-number">07</span> Hotel reservation app
        </h1>

        <div class="metadata">
            <a href="https://bytebytego.com/courses/mobile-system-design-interview/hotel-reservation-app" target="_blank" rel="noopener">Original source</a>
        </div>

        <article>
            <header><strong class="style_chapter__grtAe">07</strong><h1>Hotel reservation app</h1></header><p>In this chapter, we will design a hotel reservation system that empowers users to search, compare, and book hotels. Platforms like Booking.com and Hotels.com have transformed travel planning by integrating robust search capabilities and instant booking features into mobile applications. These systems must manage real-time room availability, prevent double bookings, and deliver accurate pricing.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a mobile phone screen displaying the Booking.com website.  At the top, a blue header shows 'Booking.com' prominently. Below, a search bar prompts 'Where do you want to go next?'.  Beneath the search bar are three horizontally aligned buttons: 'Sort,' 'Filter,' and 'Map,' each with corresponding icons. The main content area displays a list of hotels. Each hotel entry includes a small image, the hotel name (e.g., 'Hotel Villa Rosa'), a star rating (five stars in this case), a numerical rating (e.g., '8.9'), a descriptive adjective (e.g., 'Excellent'), and additional details like location ('In city center') or specific features ('Cleanliness 9.3').  A heart icon appears next to each hotel entry, presumably for saving favorites.  The hotels are listed vertically, one after another, with each hotel's information presented in a consistent format.  No URLs or specific parameters are visible beyond the website's domain name." width="225" height="349" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(225px, 100vw), (max-width: 1200px) min(225px, 80vw), min(225px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fmobile-system-design-interview%2Fhotel-reservation-app%2Ffigure-7-1-X2LGXXD4.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fmobile-system-design-interview%2Fhotel-reservation-app%2Ffigure-7-1-X2LGXXD4.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fmobile-system-design-interview%2Fhotel-reservation-app%2Ffigure-7-1-X2LGXXD4.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fmobile-system-design-interview%2Fhotel-reservation-app%2Ffigure-7-1-X2LGXXD4.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fmobile-system-design-interview%2Fhotel-reservation-app%2Ffigure-7-1-X2LGXXD4.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fmobile-system-design-interview%2Fhotel-reservation-app%2Ffigure-7-1-X2LGXXD4.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fmobile-system-design-interview%2Fhotel-reservation-app%2Ffigure-7-1-X2LGXXD4.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fmobile-system-design-interview%2Fhotel-reservation-app%2Ffigure-7-1-X2LGXXD4.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fmobile-system-design-interview%2Fhotel-reservation-app%2Ffigure-7-1-X2LGXXD4.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 1: The Booking.com mobile app, as shown in the Google Play Store</figcaption></div></figure>
<p>The architectural patterns we explore here are applicable to other booking systems as well, such as property rentals, flight reservations, or event ticketing.</p>
<h2 id="step-1-understand-the-problem-and-establish-design-scope">Step 1: Understand the problem and establish design scope</h2>
<p>Before diving into the design, we must first define its requirements and boundaries. Imagine we are discussing this with an interviewer to clarify the system's focus:</p>
<p><strong>Candidate</strong>: I'd like to understand the scope first. Are we focusing on a single hotel chain, or is this an aggregator platform, like Booking.com, that pulls together options from multiple providers?<br>
<strong>Interviewer</strong>: We're aiming for an aggregator model, where users can browse and book hotels from various sources.</p>
<p><strong>Candidate</strong>: That gives us a solid starting point. For the core features, I'd suggest users should be able to search for hotels by location or destination, view details such as room types and pricing, and finalize bookings within the app. Should we also consider real-time updates to reflect room availability as others book during a user's search?<br>
<strong>Interviewer</strong>: Those features work well as a foundation, but let's hold off on real-time updates for simplicity. While searching for hotels, we should include autocomplete suggestions. Another key requirement, though, is setting a time limit for users to complete their booking once they start entering payment details.</p>
<p><strong>Candidate</strong>: Great. That helps clarify the booking flow. Building on that, let's explore the feature set further. Will users need options such as canceling reservations or checking in through the app? And should we plan for authentication flows or push notifications, such as reminders for upcoming trips?<br>
<strong>Interviewer</strong>: Let's keep it focused. Assume users are already logged in, so no authentication flows. We'll also exclude cancellations and check-ins. For payments, include support for credit cards and third-party options such as PayPal. Push notifications aren't needed either.</p>
<p><strong>Candidate</strong>: Got it. To guide our technical choices, could you share the system's expected scale? What's the monthly active user base we're designing for?<br>
<strong>Interviewer</strong>: We're currently at around 5 million monthly active users worldwide, but the system should handle growth beyond that over time.</p>
<p>The conversation can continue, covering other topics we might consider interesting and relevant to the app. Let's summarize what we're building in this chapter.</p>
<h4 id="requirements">Requirements</h4>
<p>Based on our discussions, we're designing a hotel reservation app with the following <strong>functional requirements</strong>:</p>
<ul>
<li>Users can search for hotels by location or specific destination.</li>
<li>The app provides autocomplete suggestions during searches.</li>
<li>Users can view detailed hotel information and available room types.</li>
<li>Users can complete room reservations within the app.</li>
<li>Users can process payments through multiple providers (e.g., credit cards, PayPal).</li>
<li>Users can access confirmed reservations even when offline.</li>
<li>The system enforces a time limit for completing reservations.</li>
</ul>
<p>As for <strong>non-functional requirements</strong>, we need to build a system that ensures:</p>
<ul>
<li>High availability: The app must remain accessible and reliable, even during peak loads, such as holiday seasons when user traffic increases significantly.</li>
<li>Low latency: Booking confirmations should process within a few seconds to maintain a responsive user experience and minimize wait times during critical transactions.</li>
<li>Data consistency: The system must prevent concurrent bookings of the same room for overlapping time periods, ensuring reservation data remains accurate across all users.</li>
</ul>
<h3 id="ui-sketch">UI Sketch</h3>
<p>To visualize how users will interact with the system, Figure 2 presents the core screens of our hotel reservation app:</p>
<ul>
<li>The <strong>Hotel List screen</strong> (left) serves as the entry point, allowing users to search for hotels and displaying featured options initially. After a search, the screen shows the search results (middle) that update the list of available hotels.</li>
<li>The <strong>Hotel Details screen</strong> (right) offers comprehensive information about a selected hotel, including available rooms. Users can initiate the reservation process by tapping the "Book" button.</li>
</ul>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a three-screen mobile application workflow for hotel booking. The first screen displays a search bar with a 'Search' button. Below it, a section labeled 'Discover featured hotels' shows three hotel listings, each with a placeholder image, some text (likely hotel name and brief description), and a heart icon suggesting a 'favorite' functionality.  A curved arrow connects the 'Search' button to the second screen. The second screen is titled 'Your search' and displays three hotel search results, each with a placeholder image, text fields (likely hotel name, description, and price), and a heart icon. A filled circle on one of the results indicates the selected hotel. A curved arrow connects this selected hotel to the third screen. The third screen displays hotel details under the heading 'Hotel name,' followed by 'Amenities' and 'Available rooms' sections. Each 'Available rooms' entry shows a placeholder image, text (likely room type and price), and a 'Book' button.  The overall flow depicts a user searching for hotels, selecting one from the search results, and then viewing its details and booking options." loading="lazy" width="602" height="308" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/mobile-system-design-interview/hotel-reservation-app/figure-7-2-MZFQVQ32.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 2: Basic sketch of the hotel reservation app</figcaption></div></figure>
<h2 id="step-2-api-design">Step 2: API design</h2>
<p>With a clear understanding of the requirements and user interface in place, let's transition to designing the API that will facilitate communication between the mobile client and the backend server.</p>
<h3 id="network-protocol">Network protocol</h3>
<p>Since the system does not require real-time updates or push notifications, most interactions will be client-initiated. We will adopt <strong>HTTP with REST APIs</strong> for client-backend communication, using <strong>JSON</strong> as the data format.</p>
<h3 id="api-endpoints-and-data-models">API endpoints and data models</h3>
<p>Let's examine the RESTful endpoints our backend will expose. We'll focus on the most important endpoints and data models. Others can be explored in more detail if the interviewer requests.</p>
<div class="note-block"><p><strong>💡 Pro tip!</strong> During the interview, concentrate on defining endpoints and data models for the most critical requirements that typically align with the main user flows in the app.</p><p>While you should acknowledge that other functionality exists, you can describe it at a high level to show awareness without going into implementation details. This demonstrates you're considering the full scope while consciously prioritizing the most important aspects.</p></div>
<h4 id="hotel-endpoints">Hotel endpoints</h4>
<p>Hotels are the cornerstone of the app, and users need intuitive ways to find and explore them. Here are the primary endpoints to enable this:</p>
<ul>
<li><strong>GET /v1/hotels/search?page=<code>{page}</code>&amp;limit=<code>{limit}</code></strong> <strong>&amp;latitude=<code>{x}</code>&amp;longitude=<code>{y}</code>&amp;other_query_parameters</strong><br>
allows users to search hotels by location and travel dates<br>
<em>Response</em>: 200 OK with HotelSearchResponse<br>
<em>Other query parameters</em>:
<ul>
<li>check_in_date (Date): Desired arrival date</li>
<li>check_out_date (Date): Planned departure date</li>
<li>guests (Integer): Number of guests staying</li>
</ul>
</li>
</ul>
<div class="code-table"><table><thead><tr><th style="text-align: left;">Kotlin</th><th style="text-align: left;">Swift</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>data class HotelSearchResponse</strong><br>hotels: List&lt;HotelPreview&gt;<br>paging: PaginationMetadata</td><td style="text-align: left;"><strong>struct HotelSearchResponse</strong><br>hotels: [HotelPreview]<br>paging: PaginationMetadata</td></tr><tr><td style="text-align: left;"><strong>data class HotelPreview</strong><br>id: String<br>name: String<br>location: String<br>price: BigDecimal<br>lowResImageUrl: String <br>...</td><td style="text-align: left;"><strong>struct HotelPreview</strong><br>id: String<br>name: String<br>location: String<br>price: Decimal<br>lowResImageUrl: String <br>...</td></tr></tbody></table></div>
<div class="note-block"><p><strong>🛠️ Platform implementation details</strong></p><p>Throughout this book, we present API responses as Kotlin and Swift data models rather than raw JSON. In practice, these JSON payloads get converted to platform-specific data structures within the network layer (specifically in the network data sources shown in our architecture diagrams).</p><p>On Android, developers often rely on libraries such as kotlinx.serialization, or Moshi for JSON serialization and deserialization.</p><p>On iOS, Swift's built-in Codable protocol handles this elegantly, mapping JSON fields to Swift struct properties.</p></div>
<ul>
<li><strong>GET /v1/hotels/<code>{id}</code>?query_parameters</strong><br>
fetches details for a specific hotel<br>
<em>Response</em>: 200 OK with HotelDetailsResponse</li>
</ul>
<div class="code-table"><table><thead><tr><th style="text-align: left;">Kotlin</th><th style="text-align: left;">Swift</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>data class HotelDetailsResponse</strong> <br>hotel: HotelDetails</td><td style="text-align: left;"><strong>struct HotelDetailsResponse</strong> <br>hotel: HotelDetails</td></tr><tr><td style="text-align: left;"><strong>data class HotelDetails</strong> <br>id: String <br>name: String <br>location: String <br>imagesUrls: List&lt;String&gt; <br>amenities: List&lt;Amenity&gt; <br>curatedRooms: List&lt;RoomSummary&gt; <br>price: BigDecimal <br>...</td><td style="text-align: left;"><strong>struct HotelDetails</strong> <br>id: String <br>name: String <br>location: String <br>imagesUrls: [String] <br>amenities: [Amenity] <br>curatedRooms: [RoomSummary] <br>price: Decimal <br>...</td></tr><tr><td style="text-align: left;"><strong>data class Amenity</strong> <br>name: String <br>iconUrl: String <br>category: String</td><td style="text-align: left;"><strong>struct Amenity</strong> <br>name: String <br>iconUrl: String <br>category: String</td></tr><tr><td style="text-align: left;"><strong>data class RoomSummary</strong> <br>id: String <br>name: String <br>description: String? <br>imageUrl: String <br>maxOccupancy: Int <br>...</td><td style="text-align: left;"><strong>data class RoomSummary</strong> <br>id: String <br>name: String <br>description: String? <br>imageUrl: String <br>maxOccupancy: Int <br>...</td></tr></tbody></table></div>
<h4 id="reservations-endpoints">Reservations endpoints</h4>
<p>Booking a hotel is the natural next step, and we need endpoints to handle this process efficiently:</p>
<ul>
<li><strong>POST /v1/reservations</strong><br>
initiates a reservation by securing a room<br>
<em>Body</em>: ReservationRequest<br>
<em>Response</em>: 201 Created with ReservationResponse<br>
<em>Endpoint-specific errors</em>:
<ul>
<li>400 Bad Request if conditions such as HotelNotAvailable, RoomNotAvailable, TooManyGuests, or InvalidDates exceptions</li>
</ul>
</li>
</ul>
<div class="code-table"><table><thead><tr><th style="text-align: left;">Kotlin</th><th style="text-align: left;">Swift</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>data class ReservationRequest</strong> <br>requestId: String <br>hotelId: String <br>roomIds: List&lt;String&gt; <br>checkInDate: String <br>checkOutDate: String <br>guests: Int</td><td style="text-align: left;"><strong>struct ReservationRequest</strong> <br>requestId: String <br>hotelId: String <br>roomIds: [String] <br>checkInDate: String <br>checkOutDate: String <br>guests: Int</td></tr><tr><td style="text-align: left;"><strong>data class ReservationResponse</strong> <br>reservationId: String <br>hotelId: String <br>status: ReservationStatus <br>...</td><td style="text-align: left;"><strong>struct ReservationResponse</strong> <br>reservationId: String <br>hotelId: String <br>status: ReservationStatus <br>...</td></tr></tbody></table></div>
<p>The ReservationRequest model includes the requestId field, which acts as an <strong>idempotency key</strong>. <strong>This prevents accidental duplicate bookings</strong> if network issues cause the same request to be sent multiple times.</p>
<p>When the backend processes a reservation request, it responds with a ReservationResponse model. This response contains all the original request information, plus several additional fields:</p>
<ul>
<li>A backend-generated reservationId that serves as the definitive identifier for tracking and updating the reservation.</li>
<li>A status field indicating whether the reservation is pending, has failed, or has succeeded.</li>
</ul>
<div class="note-block"><p><strong>📌 Remember:</strong> Adding <strong>idempotency</strong> keys to POST requests helps the backend de-duplicate client requests.</p><p>In the hotel booking system, this is critical. The requestId field in ReservationRequest prevents double-booking rooms.</p></div>
<ul>
<li>
<p><strong>GET /v1/reservations/<code>{id}</code></strong><br>
returns the details of a reservation and its status</p>
</li>
<li>
<p><strong>PUT /v1/reservations/<code>{id}</code></strong><br>
updates an existing reservation with personal details, payment details, etc.<br>
<em>Endpoint-specific errors</em>:</p>
<ul>
<li>PaymentError, PaymentProviderNotAvailable, PriceMismatch, UserInfoIncomplete, or CurrencyNotSupported exceptions</li>
</ul>
</li>
</ul>
<h2 id="step-3-high-level-client-architecture">Step 3: High-level client architecture</h2>
<p>With the API design in place, let's shift our attention to the client-side architecture. Figure 3 sketches out the architecture of our hotel reservation app.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system architecture diagram for a mobile hotel booking application.  The diagram is divided into a client-side UI layer and a data layer, connected via an API Gateway. The UI layer contains screens for displaying a hotel list, hotel details, reservations, and making payments, each with a corresponding state holder managing its data.  A Navigator component controls the flow between these screens.  The data layer comprises repositories for hotels and reservations, each accessing both local and remote data sources.  A Network Dispatcher handles communication with the backend. The API Gateway communicates with the backend via HTTPS, which in turn interacts with a CDN for image loading and a third-party Payments Provider.  The data flow is primarily from the UI layer, through the data layer and API Gateway to the backend and third-party services, and back to the UI layer to update the screens.  HTTPS is used for secure communication between the client and the API Gateway, and between the API Gateway and the backend. The CDN provides image content to the API Gateway. Dependency Injection is shown as a mechanism for connecting the UI layer to the data layer." loading="lazy" width="602" height="471" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/mobile-system-design-interview/hotel-reservation-app/figure-7-3-MH7454NG.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 3: High-level architecture diagram of our hotel reservation app</figcaption></div></figure>
<p>Let's explore how the key components of our architecture work together.</p>
<h3 id="external-server-side-components">External server-side components</h3>
<p>Our system relies on several external services:</p>
<ul>
<li>The <strong>Backend</strong> serves as our primary communication point, handling client interactions through HTTP.</li>
<li>A <strong>CDN</strong> improves performance by efficiently delivering static content.</li>
<li>The <strong>API Gateway</strong> manages authentication and controls system access.</li>
<li><strong>External Payment Providers</strong> process and validate payment transactions.</li>
</ul>
<h3 id="client-architecture">Client architecture</h3>
<p>The client architecture follows a similar layered approach to our previous designs, with distinct UI and data layers working together to create a seamless hotel booking experience.</p>
<p>In the <strong>UI layer</strong>, we have three main screens: <strong>Hotel List, Hotel Detail,</strong> and <strong>Reservation</strong>, each with its own dedicated state holder that manages the screen's logic and data presentation. We've also introduced a <strong>Make Payment Screen component</strong> to handle payments flexibly, supporting both direct credit card processing and integration with third-party payment providers.</p>
<p>The <strong>Data layer</strong> orchestrates the core business logic through specialized repositories that manage our primary data types: hotels and reservations. Each repository works with both local and remote data sources to ensure efficient data handling. All network communications flow through a central <strong>Network Dispatcher component</strong>, which coordinates backend interactions and manages access control.</p>
<p>This architecture provides a solid foundation for our hotel booking system. Let's explore some of its key aspects in more detail.</p>
<h2 id="step-4-design-deep-dive">Step 4: Design deep dive</h2>
<p>With the high-level architecture in place, let's examine some key aspects of our system in more detail.</p>
<ul>
<li>Implementing reservation holds.</li>
<li>Enhancing search with autocomplete suggestions.</li>
<li>Processing payments.</li>
</ul>
<h3 id="implementing-reservation-holds">Implementing reservation holds</h3>
<p>In designing our hotel reservation app, we face the critical task of managing how long users can hold a room before finalizing their booking. This mechanism, often termed "reservation holds" in the industry, ensures that our system balances user convenience with the need to keep room inventory available for others.</p>
<p>Let's break down how this feature should work.</p>
<h4 id="requirements-1">Requirements</h4>
<p>Our reservation hold feature revolves around several key behaviors:</p>
<ul>
<li><strong>Fixed booking window</strong>: When a user starts a booking process, the backend temporarily holds the requested room for a fixed time window (typically 15 minutes). This countdown begins when the server acknowledges the initial reservation request via the POST /v1/reservations endpoint. The backend acts as the source of truth, providing an authoritative expiration timestamp.</li>
<li><strong>Automatic release</strong>: If a user fails to complete the reservation within this timeframe, the system automatically releases the hold, returning the room to the available inventory. The released room is then instantly bookable by other users.</li>
<li><strong>Visible countdown</strong>: Throughout the reservation process, the app provides clear, real-time feedback about the remaining reservation hold time, visually highlighting urgency.</li>
<li><strong>Expiration cleanup</strong>: Upon expiration, any unpaid reservations are automatically canceled. This keeps our inventory accurate, preventing stale holds from cluttering the system and ensuring that availability reflects the actual state of our resources.</li>
</ul>
<p>This combination of user-facing transparency and system-driven management maintains an equitable booking process while preserving the platform's responsiveness and accuracy.</p>
<h4 id="managing-reservation-hold-timers">Managing reservation hold timers</h4>
<p>Ensuring that the client and backend remain synchronized in tracking reservation time is a pivotal challenge. Mobile devices complicate timer management because:</p>
<ul>
<li>Unreliable device time: Users can manually set their device's clock, throwing off local timers.</li>
<li>Network delays: Latency between the client and server can skew when the hold appears to start or end.</li>
<li>App suspension: When the app is minimized or the phone locks, the timer must stay accurate without breaking.</li>
</ul>
<p>Relying on the device's clock alone won't work. We need a better approach that has the backend as the source of truth. Thus, <strong>the backend communicates the reservation expiration UTC timestamp to the client</strong>.</p>
<p>To display the most accurate representation of the remaining reservation time to the user on the client, regardless of device or network conditions, we use the <strong>device uptime</strong>.</p>
<p>The device's uptime ensures that timers remain accurate during app suspension (e.g., when the app is minimized or the phone locks) and is immune to user clock changes, unlike standard wall clock time, which can be manipulated.</p>
<div class="note-block"><p><strong>🛠️ Platform implementation details</strong></p><p>Both iOS and Android provide native APIs to handle time tracking and countdowns:</p><ul>
<li>
<p>On iOS, use ProcessInfo.processInfo.systemUptime to get system uptime, and create timers using the Timer class.</p>
</li>
<li>
<p>On Android, get system uptime via SystemClock.elapsedRealtime(), and implement countdowns with CountDownTimer.</p>
</li>
</ul></div>
<p>This choice ensures precision from the server while accommodating mobile-specific interruptions.</p>
<div class="note-block"><p><strong>✅ Decisions made!</strong></p><ul>
<li>
<p>Backend timestamps serve as the single source of truth for tracking reservation holds.</p>
</li>
<li>
<p>Client displays the countdown by combining the backend's expiration timestamp with local device uptime measurements.</p>
</li>
</ul></div>
<h4 id="architecture-changes-in-the-diagram">Architecture changes in the diagram</h4>
<ul>
<li>A <strong>Reservation Timing Controller</strong> in the data layer to handle the core reservation timing logic we discussed.</li>
<li>A <strong>Reservation Timer</strong> in the UI layer to display the countdown to users.</li>
</ul>
<p>The addition of separate components in different layers of the Architecture follows the Separation of Concerns principle (Figure 4). It creates clear responsibility boundaries, making the system more maintainable and testable. These components work together to keep users informed of their remaining reservation time.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a client-side architecture diagram for a reservation system.  The diagram is divided into two main layers: a UI layer and a data layer. The UI layer contains a `Navigator`, which controls the flow between three screens: `Reservation Timer`, `Reservation Screen`, and `Make Payment Screen`.  Data flows from `Reservation Timer` to `Reservation Screen`, and then to `Make Payment Screen`.  Below the screens, a `Reservation State Holder` manages the reservation's state.  The data layer, separated by a `Dependency Injection` layer, consists of a `Reservations Repository`, which interacts with both `Reservations Remote DataSource` and `Reservations Local DataSource`. The `Reservation Timing Controller` interacts with the `Reservations Repository`, suggesting data synchronization or validation.  Arrows indicate the direction of data flow and interaction between components.  The overall structure suggests a layered approach to mobile app design, separating user interface concerns from data management and persistence." loading="lazy" width="542" height="583" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/mobile-system-design-interview/hotel-reservation-app/figure-7-4-FQC7EAD6.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 4: Timer-related updates to the high-level architecture diagram</figcaption></div></figure>
<div class="note-block"><p><strong>🔍 Industry insights:</strong></p><p>Expedia's API explicitly supports a two-step booking: a client can put a room “on hold” (no charge) and then confirm the booking within a given time window [1].</p><p>To explore how to design the backend system, check out the "Hotel Reservation System" chapter of the <em>System Design Interview Volume 2</em> book [2].</p></div>
<h3 id="enhancing-search-with-autocomplete-suggestions">Enhancing search with autocomplete suggestions</h3>
<p>Autocomplete is a popular feature in mobile design interviews, especially for hotel booking apps. It helps users quickly find cities, destinations, or hotels as they type, but implementing it on mobile comes with technical challenges.</p>
<p>While autocomplete can get complex with advanced algorithms, personalization, and scalability, we'll keep it simple by focusing on efficiently loading autocomplete data.</p>
<h4 id="understanding-the-search-experience">Understanding the search experience</h4>
<p>Currently, our app relies on a basic search mechanism: users enter a query, press "Search," and the client retrieves results via a GET /v1/hotels/search request to the backend. While this approach works, it lacks the dynamic interactivity that modern mobile users expect.</p>
<p>Autocomplete makes things easier by showing suggestions as people type. However, to achieve this effectively, we must address several performance considerations:</p>
<ul>
<li><strong>Network latency and bandwidth</strong>: Autocomplete responses must be nearly instantaneous to feel responsive. Querying a server for every keystroke risks slow responses and excessive data usage, frustrating users on slow connections.</li>
<li><strong>Offline expectations</strong>: Users expect functionality even without a network. Autocomplete must offer meaningful suggestions offline, especially for frequent travelers in remote areas.</li>
<li><strong>Resource constraints</strong>: Mobile apps must minimize battery, CPU, and memory usage. Overly complex logic or frequent network calls can degrade performance.</li>
<li><strong>Input dynamics</strong>: Mobile keyboards lead to slower typing and more errors, making fast, forgiving autocomplete critical.</li>
</ul>
<p>With these considerations in mind, let's explore how we can effectively implement autocomplete within our app.</p>
<h4 id="implementing-autocomplete-search">Implementing autocomplete search</h4>
<p>To deliver meaningful autocomplete suggestions, our app must anticipate user intent, offering relevant matches for countries, cities, and hotels as queries take shape. Table 1 explores multiple strategies for sourcing this data, each with its own merits and drawbacks:</p>
<div class="table-wrap" style="--table-min-width: 640px;"><table><thead><tr><th style="text-align: left;"><strong>Option</strong></th><th style="text-align: left;"><strong>Description</strong></th><th style="text-align: left;"><strong>Advantages</strong></th><th style="text-align: left;"><strong>Disadvantages</strong></th></tr></thead><tbody><tr><td style="text-align: left;">Local static dataset</td><td style="text-align: left;">Embed all autocomplete data within the app.</td><td style="text-align: left;">Works offline. Eliminates network delays. Ensures stable performance.</td><td style="text-align: left;">Expands app size. Demands updates for freshness. Impractical for evolving data.</td></tr><tr><td style="text-align: left;">Real-time remote API fetching</td><td style="text-align: left;">Retrieve suggestions from the backend with each keystroke.</td><td style="text-align: left;">Provides current data. Requires no local storage. Highly adaptable.</td><td style="text-align: left;">Latency can disrupt UX. Increases data usage. Needs strong error handling.</td></tr><tr><td style="text-align: left;">Third-party services</td><td style="text-align: left;">Leverage external APIs (e.g., Google Places) for suggestions.</td><td style="text-align: left;">Access to rich, curated datasets. Reduces maintenance burden.</td><td style="text-align: left;">May incur costs. Raises privacy concerns over data sharing. Ties us to external providers.</td></tr><tr><td style="text-align: left;">Pre-fetch popular data</td><td style="text-align: left;">Load common search terms (e.g., top cities, hotels) in advance.</td><td style="text-align: left;">Speeds up frequent queries. Optimizes network use.</td><td style="text-align: left;">Risks of storing unused data. Requires periodic refreshes.</td></tr><tr><td style="text-align: left;">On-demand data loading</td><td style="text-align: left;">Retrieve suggestions from the backend after users complete their search.</td><td style="text-align: left;">Conserves resources. Delivers tailored results. Keeps storage lean.</td><td style="text-align: left;">Offers limited initial suggestions. It may feel sparse for new searches.</td></tr></tbody></table></div>
<p class="tableCaption"><p>Table 1: Trade-offs for providing autocomplete data</p></p>
<p>As you can see, each approach has its pros and cons. For this exercise, we'll go with a hybrid solution: <strong>pre-fetching popular data combined with on-demand loading for user-specific searches</strong>. This method finds a middle ground, and here's why it works well:</p>
<ul>
<li>Keeping the app lean and avoiding a bulky embedded dataset helps preserve a manageable installation size.</li>
<li>Minimizing network load, such as pre-fetching common terms at startup, reduces real-time requests.</li>
<li>Personalizing the experience with on-demand fetches that adapt to users’ search patterns over time, delivering tailored suggestions based on their history.</li>
</ul>
<p>This strategy assumes that users often search within popular regions, starting with broad suggestions that become more personalized over time. By preloading commonly searched terms and incrementally updating the cache based on user interaction, we achieve immediate responsiveness while maintaining flexibility and relevance.</p>
<h4 id="search-autocomplete-data-flow">Search autocomplete data flow</h4>
<p>Our autocomplete system operates through a three-step process:</p>
<ol>
<li><strong>Initial data loading</strong>. When our app launches, it checks the current version of the cached autocomplete data. If the server indicates newer data exists, the app downloads and updates the local cache accordingly. For this process, we can implement patterns such as the ChangeList pattern or timestamp-based synchronization.</li>
<li><strong>Local query processing</strong>. As the user types, the app queries the local autocomplete dataset. To avoid overwhelming the system with rapid-fire database requests, we introduce a brief input debounce delay (typically 200–300 ms). This means the app waits briefly after the user pauses typing before performing the search, balancing responsiveness and performance.</li>
<li><strong>Network-based refinement</strong>. When users select a suggestion or finalize a search, the app fetches additional data for that region in the background. This newer data is cached locally with a shorter time-to-live (TTL), ensuring freshness without excessive network load.</li>
</ol>
<p>Next, let's consider how to store this data effectively.</p>
<h4 id="storage-solution">Storage solution</h4>
<p>For autocomplete to shine, we need a storage system optimized for rapid text retrieval. Given our focus on names and locations, <strong>Full-Text Search (FTS)</strong> [3] proves ideal, offering:</p>
<ul>
<li>The system uses fast prefix matching to find terms that begin with the user's input, which is great for providing autocomplete suggestions.</li>
<li>Smart text tokenization that improves search accuracy.</li>
<li>Built-in result ranking based on relevance.</li>
<li>Fuzzy search capability that handles common mobile typing mistakes.</li>
</ul>
<p>While FTS demands extra storage for indexes and adds some complexity, its benefits to the user experience might justify the investment. SQLite with FTS extensions emerges as our choice, leveraging its strengths across platforms.</p>
<div class="note-block"><p><strong>🛠️ Platform implementation details</strong></p><p>Both Android and iOS can implement Full-text search (FTS) through SQLite.</p><ul>
<li>
<p>On Android, the Jetpack Room persistence library provides built-in FTS support [4], making implementation straightforward. Room handles the complexity of FTS configuration and query optimization, allowing you to focus on your search functionality.</p>
</li>
<li>
<p>iOS developers have a few options, as Core Data doesn't natively support FTS. You can either work directly with SQLite to implement FTS capabilities or use wrapper libraries such as GRDB [5] that simplify SQLite integration while maintaining full FTS functionality.</p>
</li>
</ul></div>
<h4 id="potential-challenges-and-considerations">Potential challenges and considerations</h4>
<p>While autocomplete significantly enhances usability, it also introduces complexities we must carefully address:</p>
<ul>
<li><strong>Data synchronization</strong>: Efficient updates via ChangeList or similar methods require careful versioning to avoid conflicts. Fetching only deltas since the last sync optimizes bandwidth.</li>
<li><strong>Throttle tuning</strong>: A 200–300ms delay suits most users, but we might refine this dynamically based on typing speed or device capability to enhance responsiveness.</li>
<li><strong>Data freshness</strong>: For volatile data such as hotel availability, shorter expiration times maintain accuracy without excessive network calls.</li>
<li><strong>Request optimization</strong>: On-demand loading could strain the server during peak use. Background syncing over Wi-Fi or predictive pre-fetching can mitigate this.</li>
</ul>
<p>To recap, our autocomplete storage implementation leverages FTS via SQLite, offering robust performance optimized for fast queries. This setup, complemented by intelligent caching and synchronization strategies, ensures a responsive and intuitive user experience across mobile clients.</p>
<div class="note-block"><p><strong>🔍 Industry insights:</strong></p><p>If you're interested in how other companies solved this problem, you can read how:</p><ul>
<li>
<p>Traveloka.com supports multiple languages and incorporates geographic location awareness to improve search relevance and reduce typos [6].</p>
</li>
<li>
<p>Tiket.com developed a machine learning model that improved the quality of autocomplete ranking results by 4% to 7.5% [7].</p>
</li>
</ul></div>
<h3 id="processing-payments">Processing payments</h3>
<p>Handling payments securely is an essential aspect of hotel reservation apps. Designing a payment integration requires careful consideration of user experience, data security, compliance with industry regulations, and reliable interaction with external services.</p>
<p>Our hotel reservation app supports two primary payment methods:</p>
<ul>
<li>Direct credit card payments, where users manually enter their card details (name, number, expiry, CVV).</li>
<li>Third-party payment providers, such as PayPal, Apple Pay, or Google Pay, facilitate quick and secure transactions.</li>
</ul>
<p>In this section, we will focus on integrating these payment methods within the mobile app.</p>
<h4 id="credit-card-payments">Credit card payments</h4>
<p>When processing credit card payments, security must remain a top priority. Integrating credit card payments securely into our app involves specific considerations:</p>
<ul>
<li><strong>Avoid storing sensitive data on the device</strong>. Card details should reside only briefly in volatile memory during active transactions.</li>
<li><strong>HTTPS communication with TLS encryption</strong> ensures secure data transmission.</li>
<li><strong>Tokenization</strong> [8] securely stores credit card information by replacing sensitive details with tokens that reference the actual data safely stored by a payment processor. Tokenization enables users to reuse previously entered payment methods securely, enhancing convenience without compromising security.</li>
</ul>
<p>With tokenization, we can maintain minimal client-side storage for saved payment methods by retaining only a unique id that references the card securely, and the last four digits of the card number to help users quickly identify saved payment methods without exposing sensitive details.</p>
<h5 id="integrating-credit-card-payments-in-our-design">Integrating credit card payments in our design</h5>
<p>Once the credit card information is sent to the server as part of the PUT /v1/reservations/<code>{id}</code> endpoint, we face two viable paths:</p>
<ol>
<li><strong>Direct integration with payment processors</strong> [9]. Here, our backend connects directly to services such as Worldpay, Fiserv, or Global Payments. This grants us control but requires substantial effort to meet PCI DSS compliance, a demanding and resource-heavy task.</li>
<li><strong>Leveraging Payment Service Providers (PSPs)</strong> [10]. Partnering with PSPs such as Stripe or PayPal offloads compliance and security responsibilities. Their SDKs streamline integration across our backend and mobile clients, aligning with industry best practices.</li>
</ol>
<div class="note-block"><p><strong>⚠️ Important security note:</strong></p><p>Directly handling credit card data and communicating with Payment Processors requires extensive security measures. This approach demands significant investment in infrastructure and ongoing maintenance to comply with PCI DSS standards [11].</p><p>For most applications, it's safer and more practical to use established Payment Service Providers that already handle these security requirements.</p></div>
<p>Recognizing the complexity of direct integration, we've <strong>chosen to collaborate with trusted PSPs</strong>. This decision simplifies our development efforts and reinforces user trust by aligning with recognized payment experts, setting a solid foundation as we explore broader integration options.</p>
<h4 id="integrating-with-third-party-payment-service-providers">Integrating with third-party Payment Service Providers</h4>
<p>Integrating third-party Payment Service Providers (PSPs) enables secure, user-friendly payment processing. Modern PSPs, such as Stripe or PayPal, handle not only basic card payments but also offer comprehensive solutions, including digital wallets and alternative payment methods (e.g., Klarna).</p>
<p>When integrating PSPs into mobile apps, one key architectural choice we must consider is whether to route payments directly from the client or channel them through our backend server. Table 2 explores different approaches that come with unique benefits and trade-offs.</p>
<div class="table-wrap" style="--table-min-width: 640px;"><table><thead><tr><th style="text-align: left;"><strong>Aspect</strong></th><th style="text-align: left;"><strong>Backend integration</strong></th><th style="text-align: left;"><strong>Client-side integration</strong></th></tr></thead><tbody><tr><td style="text-align: left;">Implementation</td><td style="text-align: left;">Backend orchestrates PSP interactions.</td><td style="text-align: left;">Clients engage PSPs directly, managing payment interfaces.</td></tr><tr><td style="text-align: left;">Performance</td><td style="text-align: left;">Additional latency from backend processing.</td><td style="text-align: left;">Lower latency. Faster payments due to direct client–PSP communication.</td></tr><tr><td style="text-align: left;">Security</td><td style="text-align: left;">Sensitive data is handled exclusively server-side, improving overall security.</td><td style="text-align: left;">Sensitive data managed client-side, increasing complexity in securing client apps.</td></tr><tr><td style="text-align: left;">Maintenance</td><td style="text-align: left;">Easier PSP integration management. Changes are centralized.</td><td style="text-align: left;">Multiple platform-specific integrations. Requires client updates for PSP changes.</td></tr><tr><td style="text-align: left;">User Experience</td><td style="text-align: left;">Uniform user experience across platforms, limited by backend implementation.</td><td style="text-align: left;">Richer, more native experience with full PSP features such as biometric authentication.</td></tr><tr><td style="text-align: left;">Development</td><td style="text-align: left;">Increased backend complexity. Simpler client-side implementation.</td><td style="text-align: left;">Increased client complexity due to direct PSP SDK integration.</td></tr></tbody></table></div>
<p class="tableCaption">Table 2: Trade-offs for integrating with PSPs</p>
<p>After evaluating these trade-offs, <strong>integrating PSPs directly on the client</strong> provides users with a richer, native payment experience and access to advanced payment options, including device-specific biometric authentication methods. Although this adds complexity in client-side management, it aligns with the expectations of a high-quality, modern mobile experience.</p>
<div class="note-block"><p><strong>✅ Decisions made!</strong></p><p>The hotel reservation system processes all payment transactions from the <strong>client UI through third-party Payment Service Providers</strong>.</p></div>
<h4 id="architecture-updates">Architecture updates</h4>
<p>Integrating payments into the mobile architecture (Figure 5) requires minimal adjustments to the architecture diagram:</p>
<ul>
<li>The <strong>Make Payment State Holder</strong> component handles all payment logic, connecting third-party payment SDKs with our Reservations repository.</li>
<li>The <strong>PSP Payment UI components</strong> from an external SDK manage the user-facing aspects of payments, securely collecting payment details and offering convenient options.</li>
</ul>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a client-side architecture for a mobile payment system.  The diagram shows a client application, labeled 'Client,' containing a UI layer with three components: a 'Navigator,' a 'Make Payment Screen,' and a 'Make Payment State Holder.'  The 'Navigator' component likely controls navigation within the UI. The 'Make Payment Screen' displays the payment interface to the user, and it interacts with the 'Make Payment State Holder,' which manages the application's payment-related data.  The 'Make Payment Screen' communicates with a 'Third Party client SDK' (Software Development Kit), which acts as an interface to a Payment Service Provider (PSP).  This interaction is represented by a unidirectional arrow from the 'Make Payment Screen' to the 'Third Party client SDK.' The SDK, in turn, interacts with the PSP's 'PSP Payment UI,' which likely handles the actual payment processing.  The entire PSP interaction is enclosed within a dashed box labeled 'Third Party client SDK.'  The data flow is primarily from the client's UI components to the PSP via the SDK, suggesting a process where the client initiates a payment, and the PSP handles the transaction." loading="lazy" width="542" height="361" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/mobile-system-design-interview/hotel-reservation-app/figure-7-5-FGIG4FMV.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 5: Payment client-related updates to the UI layer</figcaption></div></figure>
<p>These additions to our architecture clearly delineate payment responsibilities, improving maintainability and ensuring secure and reliable handling of sensitive user transactions.</p>
<h4 id="payment-data-flow">Payment data flow</h4>
<p>To understand how payment data travels through our system, consider the following end-to-end flow when a user books a hotel room, as illustrated in Figure 6.</p>
<p>After the initial reservation, when the client sends a POST /v1/reservations request with booking details and the server returns a successful response with a reservationId, the following steps take place:</p>
<ul>
<li><strong>Payment collection</strong>. The client calls the PSP's SDK to gather payment details, keeping sensitive data off our servers (step 1).</li>
<li><strong>Submit payment confirmation for the reservation</strong>. Post-payment, the client submits a PUT request to/v1/reservations/<code>{id}</code> with tokenized transaction identifiers provided by the PSP (step 2).</li>
<li><strong>Backend verification</strong>. The backend confirms the payment with the PSP (step 3), locks in the reservation upon success, and returns the confirmation to the client (step 4).</li>
</ul>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system architecture diagram for a mobile payment system within a reservations application.  A user (labeled 'User') initiates a payment (labeled 'Makes payment') which flows into a 'Make Payment Screen'. This screen interacts with a 'Third Party client SDK' (labeled 'PSP Payment UI'), specifically a Payment Service Provider's (PSP) client-side software development kit, indicated by the numbered connection '1'.  The 'Make Payment Screen' also interacts with a 'Make Payment State Holder', which in turn communicates with a 'Reservations Repository'. The 'Reservations Repository' is connected to a 'Reservations Remote DataSource' via bidirectional arrows, indicating data persistence and retrieval.  The 'Make Payment State Holder' also receives data from and sends data to the 'Reservations Repository'.  The numbered connection '2' shows data flow from the 'Reservations Remote DataSource' to a 'Backend' component, and connection '4' shows the reverse flow.  Finally, the 'Backend' interacts with the 'PSP Payment Server Provider' (labeled 'PSP Payment Server Provider'), a third-party payment processing service, via bidirectional arrows labeled '3', completing the payment processing loop.  The entire PSP interaction is enclosed in a dashed box, clearly separating the third-party components from the application's internal components." loading="lazy" width="602" height="396" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/mobile-system-design-interview/hotel-reservation-app/figure-7-6-QPDCRMFM.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 6: Payment data flow</figcaption></div></figure>
<div class="note-block"><p><strong>📝 Note:</strong></p><p>Payment Service Providers (PSPs) typically handle transactions in two steps:</p><ul>
<li>
<p>Authorization: Reserve the funds in the customer's account.</p>
</li>
<li>
<p>Capture: Move the money when the transaction is confirmed.</p>
</li>
</ul><p>This process makes payments more reliable. If something goes wrong before the transaction is confirmed, the money is still in the customer's account, since it has only been reserved, not taken.</p><p>When using a PSP's SDK, to ensure everything stays in sync, the backend should always verify the reservation before capturing the payment.</p></div>
<h4 id="integrating-third-party-psp-sdks-in-the-client">Integrating third-party PSP SDKs in the client</h4>
<p>Popular PSPs such as Stripe, PayPal, or Apple Pay offer extensive SDKs, making client-side integration more straightforward.</p>
<p>When integrating PSP SDKs into our app, we should carefully handle common mobile-specific payment implementation challenges, including:</p>
<ul>
<li><strong>Error handling</strong>: Implement robust handling for common payment-related exceptions, such as declined transactions, timeouts, or network issues. Clearly communicate payment status and potential actions to the user.</li>
<li><strong>Transaction retries</strong>: Use exponential backoff strategies to manage retries efficiently, preventing excessive load on PSP servers in case of temporary failures.</li>
<li><strong>User feedback</strong>: Consistently update users with clear, real-time feedback on their payment progress and status, ensuring transparency throughout the process.</li>
</ul>
<p>Addressing these considerations enhances overall reliability, resulting in a secure, transparent, and user-friendly payment experience.</p>
<div class="note-block"><p><strong>🔍 Industry insights:</strong></p><p>If you're interested in how other companies solved this problem, you can read how:</p><ul>
<li>
<p>Expedia migrated to a cloud-based microservices payment platform for flexibility and speed [12].</p>
</li>
<li>
<p>Stripe explains payment tokenisation [13] and handles fraud prevention with 3D Secure [14].</p>
</li>
</ul></div>
<h2 id="step-5-wrap-up">Step 5: Wrap-up</h2>
<p>Throughout this chapter, we've designed a comprehensive hotel reservation system from the ground up. At its core, our system enables seamless hotel search, browsing, and booking. We took special care to address critical aspects such as managing booking timeouts, optimizing search performance, and ensuring smooth payment flows.</p>
<p>If you have extra time in your interview or want to explore more advanced features, consider these additional requirements:</p>
<ul>
<li>Real-time availability updates: Implement live updates to room availability, ensuring users always see the current inventory.</li>
<li>Smart notifications: Design a system for timely push notifications about upcoming stays, check-in reminders, and booking confirmations.</li>
<li>Reservation management: Enable users to modify or cancel bookings, with appropriate handling of cancellation policies and refunds.</li>
<li>Promotional system: Design a flexible framework for handling various types of discounts, loyalty programs, and seasonal offers.</li>
</ul>
<h2 id="resources">Resources</h2>
<p>[1] Expedia booking hold and resume APIs: <a href="https://developers.expediagroup.com/docs/products/rapid/lodging/booking/hold-resume" target="_blank" rel="noopener noreferrer">https://developers.expediagroup.com/docs/products/rapid/lodging/booking/hold-resume</a><br>
[2] System Design Interview – An Insider's Guide: Volume 2 by Alex Xu and Sahn Lam: <a href="https://www.amazon.com/dp/1736049119/ref=sspa_dk_hqp_detail_aax_0?psc=1&amp;sp_csd=d2lkZ2V0TmFtZT1zcF9ocXBfc2hhcmVk" target="_blank" rel="noopener noreferrer">https://www.amazon.com/dp/1736049119/ref=sspa_dk_hqp_detail_aax_0?psc=1&amp;sp_csd=d2lkZ2V0TmFtZT1zcF9ocXBfc2hhcmVk</a><br>
[3] Full-text search: <a href="https://en.wikipedia.org/wiki/Full-text%5C_search" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Full-text\_search</a><br>
[4] Google's Room library FTS support: <a href="https://developer.android.com/training/data-storage/room/defining-data" target="_blank" rel="noopener noreferrer">https://developer.android.com/training/data-storage/room/defining-data</a><br>
[5] iOS GRDB library: <a href="https://github.com/groue/GRDB.swift" target="_blank" rel="noopener noreferrer">https://github.com/groue/GRDB.swift</a><br>
[6] Traveloka autocomplete search: <a href="https://medium.com/traveloka-engineering/high-quality-autocomplete-search-part-1-fcc1b0a4baa6" target="_blank" rel="noopener noreferrer">https://medium.com/traveloka-engineering/high-quality-autocomplete-search-part-1-fcc1b0a4baa6</a><br>
[7] Tiket.com autocomplete search ML model: <a href="https://medium.com/tiket-com/algorithm-behind-search-in-tiket-com-4bfaeb42980b" target="_blank" rel="noopener noreferrer">https://medium.com/tiket-com/algorithm-behind-search-in-tiket-com-4bfaeb42980b</a><br>
[8] Tokenization: <a href="https://en.wikipedia.org/wiki/Tokenization%5C_(data%5C_security)" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Tokenization\_(data\_security)</a><br>
[9] Payment Processor: <a href="https://en.wikipedia.org/wiki/Payment%5C_processor" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Payment\_processor</a><br>
[10] Payment Service Provider (PSP): <a href="https://en.wikipedia.org/wiki/Payment%5C_service%5C_provider" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Payment\_service\_provider</a><br>
[11] Payment Card Industry Data Security Standard (PCI DSS): <a href="https://en.wikipedia.org/wiki/Payment%5C_Card%5C_Industry%5C_Data%5C_Security%5C_Standard" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Payment\_Card\_Industry\_Data\_Security\_Standard</a><br>
[12] Expedia vendor payment transactions: <a href="https://aws.amazon.com/solutions/case-studies/expedia-aurora-case-study/" target="_blank" rel="noopener noreferrer">https://aws.amazon.com/solutions/case-studies/expedia-aurora-case-study/</a><br>
[13] Stripe payment tokenisation: <a href="https://stripe.com/en-es/resources/more/payment-tokenization-101" target="_blank" rel="noopener noreferrer">https://stripe.com/en-es/resources/more/payment-tokenization-101</a><br>
[14] Stripe 3D secure fraud prevention: <a href="https://docs.stripe.com/issuing/3d-secure" target="_blank" rel="noopener noreferrer">https://docs.stripe.com/issuing/3d-secure</a></p>
        </article>
    </main>

    <div class="nav">
        <a href="../mobile-system-design-interview.html">← Course Contents</a>
        <a href="pagination-library.html">← Previous</a>
        <a href="google-drive-app.html">Next →</a>
    </div>

    <footer class="metadata">
        <p>Scraped on 10/10/2025</p>
    </footer>
</body>
</html>