<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design a Unix File Search System - Object Oriented Design Interview</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Open Sans', Arial, sans-serif;
    font-size: 16px;
    line-height: 1.6;
    color: #454545;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    font-size: 2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.2;
}

h2 {
    font-size: 1.5em;
    margin: 1.2em 0 0.6em 0;
    line-height: 1.3;
}

h3 {
    font-size: 1.2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.4;
}

p {
    margin: 0.8em 0;
}

a {
    color: #0077aa;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

ul, ol {
    margin: 0.8em 0;
    padding-left: 2em;
}

li {
    margin: 0.4em 0;
}

code, pre {
    background: #f4f4f4;
    border: 1px solid #ddd;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
}

code {
    padding: 2px 5px;
}

pre {
    padding: 10px;
    overflow-x: auto;
    margin: 1em 0;
}

pre code {
    border: none;
    padding: 0;
}

img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 1.5em auto;
}

figure {
    margin: 1.5em 0;
    text-align: center;
}

figcaption {
    font-style: italic;
    font-size: 0.9em;
    color: #666;
    margin-top: 0.5em;
}

.chapter-number {
    font-weight: bold;
    color: #0077aa;
}

.nav {
    margin: 2em 0;
    padding: 1em 0;
    border-top: 1px solid #ddd;
    border-bottom: 1px solid #ddd;
}

.nav a {
    margin-right: 1em;
}

.toc {
    list-style: none;
    padding: 0;
}

.toc li {
    margin: 0.8em 0;
}

.course-section {
    margin: 2em 0;
}

.course-title {
    font-size: 1.3em;
    font-weight: bold;
    color: #0077aa;
    margin: 1.5em 0 0.8em 0;
}

.metadata {
    font-size: 0.9em;
    color: #888;
    margin: 2em 0 1em 0;
}

.breadcrumb {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 1em;
}

.breadcrumb a {
    color: #0077aa;
}

@media (max-width: 600px) {
    body {
        padding: 10px;
    }

    h1 {
        font-size: 1.5em;
    }

    h2 {
        font-size: 1.3em;
    }
}</style>
</head>
<body>
    <div class="breadcrumb">
        <a href="../../index.html">Home</a> /
        <a href="../object-oriented-design-interview.html">Object Oriented Design Interview</a> /
        Design a Unix File Search System
    </div>

    <div class="nav">
        <a href="../object-oriented-design-interview.html">← Course Contents</a>
        <a href="design-a-movie-ticket-booking-system.html">← Previous</a>
        <a href="design-a-vending-machine.html">Next →</a>
    </div>

    <main>
        <h1>
            <span class="chapter-number">06</span> Design a Unix File Search System
        </h1>

        <div class="metadata">
            <a href="https://bytebytego.com/courses/object-oriented-design-interview/design-a-unix-file-search" target="_blank" rel="noopener">Original source</a>
        </div>

        <article>
            <header><strong class="style_chapter__grtAe">06</strong><h1>Design a Unix File Search System</h1></header><p>In this chapter, we will explore the design of a Unix File Search system. The goal is to design classes that represent abstractions of the key entities in a file search system, such as directories, files, and filter criteria. We’ll aim to create a clear and functional structure that captures the essential interactions between these components, ensuring the search system is intuitive and scalable.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a code snippet, likely from a build script or IDE, showing a search command.  At the top are three shaded circles, possibly representing progress or status indicators. Below this, the command `$ find . -name '*.java'` is displayed. This command instructs the `find` utility to search the current directory (`.`) for all files ending with `.java`. The subsequent lines list the results of this search, indicating the location of four Java files within a directory structure: `/Movie_Ticket_Code/movie_ticket/rate/VIPRate.java`, `/Movie_Ticket_Code/movie_ticket/rate/NormalRate.java`, `/Movie_Ticket_Code/movie_ticket/rate/PremiumRate.java`, and `/Movie_Ticket_Code/movie_ticket/rate/PricingStrategy.java`.  These files are likely related to movie ticket pricing, with each `.java` file potentially representing a different pricing strategy (VIP, Normal, Premium) and a PricingStrategy class managing them. The overall structure suggests a project organized using a package hierarchy within the `Movie_Ticket_Code` directory." loading="lazy" width="538" height="179" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(538px, 100vw), (max-width: 1200px) min(538px, 80vw), min(538px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fobject-oriented-design-interview%2Fdesign-a-unix-file-search%2Fimage-6-1-GZDKBPWN.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fobject-oriented-design-interview%2Fdesign-a-unix-file-search%2Fimage-6-1-GZDKBPWN.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fobject-oriented-design-interview%2Fdesign-a-unix-file-search%2Fimage-6-1-GZDKBPWN.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fobject-oriented-design-interview%2Fdesign-a-unix-file-search%2Fimage-6-1-GZDKBPWN.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fobject-oriented-design-interview%2Fdesign-a-unix-file-search%2Fimage-6-1-GZDKBPWN.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fobject-oriented-design-interview%2Fdesign-a-unix-file-search%2Fimage-6-1-GZDKBPWN.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fobject-oriented-design-interview%2Fdesign-a-unix-file-search%2Fimage-6-1-GZDKBPWN.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fobject-oriented-design-interview%2Fdesign-a-unix-file-search%2Fimage-6-1-GZDKBPWN.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fobject-oriented-design-interview%2Fdesign-a-unix-file-search%2Fimage-6-1-GZDKBPWN.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Unix file search</figcaption></div></figure>
<p>Let’s gather the specific requirements through a simulated interview scenario.</p>
<h2 id="requirements-gathering">Requirements Gathering</h2>
<p>Here is an example of a typical prompt an interviewer might give:</p>
<p>“Imagine you’re a developer trying to find specific files on a Unix system, like files owned by a user, or text files matching a pattern, buried deep in a directory structure. You run a search command, specify your criteria, and the system returns matching files quickly. Behind the scenes, it’s recursively traversing directories, evaluating file attributes, and applying your filters efficiently. Let’s design a Unix File Search system that handles this process.”</p>
<h3 id="requirements-clarification">Requirements clarification</h3>
<p>Here is an example of how a conversation between a candidate and an interviewer might unfold:</p>
<p><strong>Candidate:</strong> What attributes does the find command use to search for files?<br>
<strong>Interviewer:</strong> It could be based on criteria like size, file type, filename, and owner.</p>
<p><strong>Candidate:</strong> Does it need to handle directories?<br>
<strong>Interviewer:</strong> Yes, directories are considered as files too, with a distinct file type.</p>
<p><strong>Candidate:</strong> What types of comparisons does the command support?<br>
<strong>Interviewer:</strong> That depends on the type of attribute. For strings, we support ‘equals’ and ‘regex match’. For numbers, we support ‘greater than’, ‘equals’, and ‘less than’.</p>
<p><strong>Candidate:</strong> Can we combine multiple criteria, even on the same attribute?<br>
<strong>Interviewer:</strong> Yes, with multiple criteria, using ‘and’, ‘or’, and ‘not’ conditions.</p>
<p><strong>Candidate:</strong> I assume we’re designing a system to search a directory and its sub-directories, returning files that match the given conditions.<br>
<strong>Interviewer:</strong> Yes, that's a fair assumption.</p>
<h3 id="constructing-concrete-examples">Constructing concrete examples</h3>
<p>With the requirements for our Unix File Search system in hand, let’s see them in action through some real-world command-line searches. These examples will show what the system needs to handle and set the stage for designing our classes:</p>
<ul>
<li><strong>Start with a Simple Search</strong>: Find files recursively within / where size &gt; 10.</li>
<li><strong>Scale Up to a Complex Search</strong>: Find files recursively within / where ((size &gt; 10 and size &lt; 1000 and owner = "alice") or (size &gt; 1000 and !(filename matches /prefix.*/))).</li>
</ul>
<h3 id="requirements">Requirements</h3>
<p>Based on the questions and answers, the following functional requirements can be identified:</p>
<ul>
<li>The search system can search for files based on attributes such as size, type, filename, and owner.</li>
<li>The search system supports comparison types depending on the attribute: ‘equals’ and ‘regex match’ for strings, and ‘greater than’, ‘equals’, and ‘less than’ for numbers.</li>
<li>The system can combine multiple search criteria using logical operators (and, or, not).</li>
<li>The file search system can perform recursive searches within directories.</li>
<li>The search system can apply search criteria to directories as well as files.</li>
</ul>
<p>Below are the non-functional requirements:</p>
<ul>
<li><strong>Scalability</strong>: Efficiently handle large directory trees with thousands or millions of files using resource-efficient traversal strategies.</li>
<li><strong>Extensibility</strong>: Support adding new attributes (e.g., modification time) and comparison operators without altering core traversal or filtering logic.</li>
<li><strong>Separation of concerns</strong>: Keep traversal logic separate from filtering logic for a modular and maintainable design.</li>
</ul>
<p>With these requirements established, let’s move on to identifying the core objects that will bring this system to life.</p>
<h2 id="identify-core-objects">Identify Core Objects</h2>
<p>Now that we’ve seen how Unix file searches work, it’s time to design a system that can handle them. Let’s break it down into core objects, each with a clear role, to create a file search system that’s both modular and easy to maintain. Here’s what we’ll need:</p>
<ul>
<li><strong>FileSearch:</strong> The central entity managing the search process, serving as the entry point into our application logic. It recursively traverses the filesystem from a starting File (directory) and returns matches based on a FileSearchCriteria object.</li>
<li><strong>File:</strong> Models a file or directory in the filesystem, storing attributes like size, type, filename, and owner. It supports a hierarchical structure with entries for subdirectories or files.</li>
</ul>
<div class="info-box"><img alt="Design Choice" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/design-choice-T3SCDB4L.svg" style="color: transparent;"><p><strong>Design choice:</strong> The File object represents files and directories as a single
entity. This enables FileSearch to perform consistent traversal and evaluation.
This design aligns with the Unix principle that treats everything as a file for
uniform handling.</p></div>
<ul>
<li><strong>FileSearchCriteria:</strong> Encapsulates a search condition and determines whether a given File matches it by delegating to a Predicate. This wrapper class decouples the search execution logic (FileSearch) from the condition evaluation logic (Predicate), promoting separation of concerns and greater flexibility.</li>
<li><strong>Predicate:</strong> An interface defining the contract for evaluating whether a File matches a condition, enabling both simple checks (e.g., "size &gt; 10") and composite conditions (e.g., AND, OR, NOT). We separate Predicate from FileSearchCriteria to isolate comparisons and logical combinations from how FileSearch uses the criteria. This keeps FileSearchCriteria a lightweight wrapper, while Predicate manages the complex logic.</li>
<li><strong>SimplePredicate:</strong> Implements Predicate to compare one file attribute (e.g., "size &gt; 10") against a value with an operator (e.g., equals, greater than).</li>
<li><strong>CompositePredicate:</strong> Extends Predicate for combining conditions (e.g., AND, OR, NOT) with implementations like AndPredicate, OrPredicate, and NotPredicate. It supports complex queries, such as "size &gt; 10 AND owner = 'bob'".</li>
<li><strong>ComparisonOperator:</strong> An interface defining how attribute values are compared, with implementations like EqualsOperator, RegexMatchOperator, GreaterThanOperator, and LessThanOperator.</li>
</ul>
<p><strong>Alternative approach:</strong> We could merge FileSearchCriteria and Predicate into a single class, embedding the matching logic directly in FileSearch. This simplifies the design by removing one layer but reduces modularity, as the search logic would be tightly coupled to condition evaluation, making it harder to swap criteria. For instance, switching the condition from "size &gt; 10" to "owner = 'bob'" would require updating FileSearch.</p>
<h2 id="design-class-diagram">Design Class Diagram</h2>
<p>We’ve mapped out the core objects, such as File and FileSearch, for our Unix File Search system. Now, let’s define their classes, pinning down their roles and methods to keep everything clear and modular.</p>
<h3 id="file">File</h3>
<p>To model a filesystem for searching, we need a way to represent files and directories. Rather than relying on a standard library like Java’s java.io.File, we define a custom File class as the core entity, capturing key attributes and supporting hierarchical traversal. It’s paired with a FileAttribute enum for attributes used in search conditions.</p>
<p>Below is the representation of this class and the enum.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a class diagram showing the design of a `File` class and its relationship with an enumeration `FileAttribute`.  The `FileAttribute` enumeration, denoted by 'E', lists four possible attributes: `IS_DIRECTORY`, `SIZE`, `OWNER`, and `FILENAME`.  The `File` class, denoted by 'C', contains private member variables corresponding to these attributes: a boolean `isDirectory`, an integer `size`, and strings `owner` and `filename`.  Additionally, it has a private `Set&lt;File&gt;` named `entries`, suggesting it can contain other `File` objects. The `File` class also includes three public methods: `extract(FileAttribute attributeName)`, which returns an object based on the provided `FileAttribute`; `addEntry(File entry)`, which adds a `File` object to the `entries` set; and `getEntries()`, which returns the entire `entries` set as a `Set&lt;File&gt;`.  There is no explicit connection drawn between the `File` class and the `FileAttribute` enumeration, but the `extract` method implies a dependency, where the `File` class uses the `FileAttribute` enumeration to access its internal data." loading="lazy" width="544" height="187" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/image-6-2-75BM2SDZ.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">File class</figcaption></div></figure>
<div class="info-box"><img alt="Design Choice" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/design-choice-T3SCDB4L.svg" style="color: transparent;"><p><strong>Design choice:</strong> We define FileAttribute as an enum to provide a fixed, type-safe
set of attributes (e.g., size, owner) for search conditions. This ensures that
only valid, predefined attributes are used when evaluating files, preventing runtime
errors from invalid attribute names. It also supports scalability: adding a new
attribute, such as modification time, requires simply extending the enum, keeping
the system extensible without altering existing logic.</p></div>
<h3 id="filesearch">FileSearch</h3>
<p>The FileSearch class is responsible for traversing the file system from a given File, using a FileSearchCriteria object to select matching files and return them. By separating traversal from filtering logic, the design remains modular, maintainable, and easy to extend. The UML diagram below illustrates this structure.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a class diagram depicting a single class named `FileSearch`.  The class is represented by a rectangle divided into two sections. The top section contains a large, grey circle with the letter 'C' inside, indicating that it's a class, followed by the class name 'FileSearch'. The bottom section lists a single public method, `search(File, FileSearchCriteria)`, which takes two parameters: a `File` object and a `FileSearchCriteria` object.  This method returns a `List&lt;File&gt;`, implying it returns a list of `File` objects that match the provided search criteria.  There are no other attributes or methods shown for the `FileSearch` class in this diagram.  The overall structure is simple and clearly shows the class's name, a single method signature, and its return type, providing a concise representation of the class's functionality." loading="lazy" width="424" height="104" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/image-6-3-A3COBR3Q.svg" style="color: transparent;"></div></figure>
<h3 id="filesearchcriteria">FileSearchCriteria</h3>
<p>The FileSearchCriteria class decides which files match our search by connecting FileSearch to Predicate. It tells FileSearch what qualifies as a match, using Predicate to check each File against the conditions.</p>
<p>Here is the representation of this class.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a class diagram depicting the `FileSearchCriteria` class.  The diagram is a rectangular box with three internal horizontal sections. The top section displays a large 'C' inside a gray circle, indicating a class, followed by the class name 'FileSearchCriteria'. The second section shows a private member variable declared as  `Predicate predicate`, suggesting a `Predicate` object is stored within the class.  The third section shows a public method `boolean isMatch(File)`, indicating a method that takes a `File` object as input and returns a boolean value, presumably true if the file matches the search criteria and false otherwise.  No connections or information flow to or from the class are depicted in this diagram; it solely describes the internal structure of the `FileSearchCriteria` class." loading="lazy" width="253" height="128" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/image-6-4-GMJOJPIP.svg" style="color: transparent;"></div></figure>
<div class="info-box"><img alt="Design Choice" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/design-choice-T3SCDB4L.svg" style="color: transparent;"><p><strong>Design choice:</strong> We designed FileSearchCriteria to work alongside Predicate,
allowing it to evaluate whether a file meets the search conditions without handling
all the logic itself. This keeps responsibilities clean and modular. For example,
FileSearchCriteria delegates to a Predicate to check if a file’s size is greater
than 10 or if the owner is “bob.” This delegation enables flexibility. We can change
or combine filtering logic (like checking different attributes or using complex
conditions) without modifying either FileSearch or FileSearchCriteria. By decoupling
the search traversal from condition evaluation, we preserve the separation of concerns
and make the system easier to extend and maintain.</p></div>
<h3 id="predicate-and-simplepredicate">Predicate and SimplePredicate</h3>
<p>A key part of our design is the ability to define conditions that determine whether a file should be included in the search results. These conditions can range from simple to complex. For example, we might want files whose names follow a regular expression like report.*, or files with sizes exceeding 10 bytes. To manage this, we introduce the Predicate interface as the foundation for evaluating files. It defines a single method that takes a File object and returns a boolean: true if the file satisfies the condition, false otherwise.</p>
<p>For straightforward conditions, we implement the SimplePredicate class. This concrete class evaluates a single file attribute, such as size or owner, against a specified value using a comparison operator (like greater than or equal). For instance, it can check "is the size bigger than 10?" or "is the owner 'bob'?" by leveraging the FileAttribute enum and a ComparisonOperator instance. The UML diagram below illustrates how these pieces fit together.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a UML class diagram illustrating an inheritance relationship.  The diagram shows an interface named `Predicate` at the top, defined by a single method: `boolean isMatch(File)`.  Below this, connected by a dashed line indicating implementation, is a class named `SimplePredicate`.  `SimplePredicate` implements the `isMatch(File)` method from the `Predicate` interface.  Internally, `SimplePredicate` contains three private member variables: `FileAttribute attributeName`, `ComparisonOperator operator`, and `String expectedValue`. These variables likely store the file attribute to check, the comparison operator (e.g., equals, greater than), and the expected value for the comparison, respectively.  The `isMatch(File)` method in `SimplePredicate` presumably uses these internal variables to perform the file attribute comparison.  The `I` and `C` symbols preceding `Predicate` and `SimplePredicate` respectively denote that `Predicate` is an interface and `SimplePredicate` is a class." loading="lazy" width="288" height="288" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/image-6-5-HE7Y2UUG.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Predicate interface and concrete class</figcaption></div></figure>
<h3 id="comparisonoperator">ComparisonOperator</h3>
<p>The ComparisonOperator interface defines a contract for comparing a file’s attribute value (like size or name) to an expected value, answering questions like "is the size greater than 10?" or "does the filename match the pattern log.*?" It declares a method that takes two values (the attribute’s actual value and the target value), and returns a boolean indicating whether the comparison holds. We implement this interface with concrete classes, such as:</p>
<ul>
<li>EqualsOperator confirms if two attribute values are the same, like "is the owner 'bob'?"</li>
<li>GreaterThanOperator verifies if one attribute value is larger, like "is the size over 10?"</li>
<li>LessThanOperator ensures one attribute value is smaller, like "is the size under 5?"</li>
<li>RegexMatchOperator evaluates whether a string attribute value satisfies a regular expression pattern, such as checking if the filename matches log.* (e.g., log.txt or logger would return true).</li>
</ul>
<p>This interface-based design allows SimplePredicate to delegate comparisons to specialized classes like EqualsOperator or RegexMatchOperator, each optimized for its operation, enabling precise and efficient file filtering in FileSearchCriteria.</p>
<p>The UML diagram below shows how this structure comes together.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a class diagram illustrating an inheritance hierarchy in object-oriented programming.  At the top is an interface named `ComparisonOperator`, denoted by the 'I' in a circle. This interface declares a single method, `boolean isMatch(Object, Object)`, which takes two objects as input and returns a boolean value indicating whether they match according to a specific comparison logic.  Below the interface, four classes—`EqualsOperator`, `GreaterThanOperator`, `LessThanOperator`, and `RegexMatchOperator`—are shown, each represented by a 'C' in a circle.  Dashed lines with arrowheads point from the `ComparisonOperator` interface to each of these classes, indicating that these classes implement the `ComparisonOperator` interface, thereby providing concrete implementations for the `isMatch` method. Each implementation would define its own comparison logic (e.g., equality check, greater-than comparison, less-than comparison, or regular expression matching).  The diagram shows a clear relationship where the classes inherit the functionality defined in the interface, providing different ways to compare two objects." loading="lazy" width="624" height="191" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/image-6-6-CLM3LGF5.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">ComparisonOperator interface and concrete classes</figcaption></div></figure>
<p><strong>Alternative approaches:</strong> We could represent operations with strings such as "equals" or "&gt;". This simplifies initial implementation but shifts validation to runtime. Each string must be parsed and mapped to a comparison function, which increases execution time and risks runtime exceptions if an invalid operator (e.g., "equals") is left unchecked.</p>
<p>Another option is to use enums like EQUALS or GREATER_THAN to represent comparison operations. This makes the code safer and faster because the operations are checked at compile time, not at runtime. However, if you want to add a new operation, like case-insensitive equality for owner names, you would need to change the enum itself. In contrast, with the interface-based approach, you can just create a new class for the new operation without touching existing code.</p>
<h3 id="composite-predicate">Composite Predicate</h3>
<p>With SimplePredicate and its ComparisonOperator implementations in place, we can already test files against single conditions like size &gt; 10 or owner = 'alice'. But real-world searches often demand more, combining multiple conditions with logical operators. To tackle this, we use the Composite design pattern, enabling us to build complex predicates from simpler ones.</p>
<p><em>Note</em>: To learn more about the Composite Pattern and its common use cases, refer to the <strong><a href="/courses/object-oriented-design-interview/design-a-unix-file-search#further-reading-composite-design-pattern">Further Reading</a></strong> section at the end of this chapter.</p>
<p>Consider a search like this:</p>
<p>Find files where ((size &gt; 10 and size &lt; 1000 and owner = "alice") or (size &gt; 1000 and !(filename matches /prefix.*/))).</p>
<p>If we label each simple condition:</p>
<ul>
<li>A for "size &gt; 10"</li>
<li>B for "size &lt; 1000"</li>
<li>C for "owner = 'alice'"</li>
<li>D for "size &gt; 1000"</li>
<li>"filename matches 'prefix.*'"</li>
<li>It becomes: ((A and B and C) or (D and !(E)))</li>
</ul>
<p>This structure uses "and," "or," and "not" operators, with brackets indicating the order of nested evaluations. This tree-like hierarchy needs a systematic way to evaluate files.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a decision tree illustrating a search query's logical structure.  The top node is labeled 'OR,' indicating that the entire query will be satisfied if either of its two subtrees evaluates to true.  The left subtree is an 'AND' node, meaning all three of its child nodes must be true for the subtree to be true. These child nodes are rounded rectangles representing conditions: 'size &gt; 10,' 'size &lt; 1000,' and 'owner = \'alice\'.' The right subtree also contains an 'AND' node, requiring both its children to be true. One child is the condition 'size &gt; 1000.' The other child is a 'NOT' node, which negates its child condition.  This child condition, in a rounded rectangle, is 'filename matches /prefix.*/,' a regular expression indicating that the filename should *not* match the pattern 'prefix.*'.  Therefore, the entire query is satisfied if either (size &gt; 10 AND size &lt; 1000 AND owner = 'alice') OR (size &gt; 1000 AND NOT (filename matches /prefix.*/)) is true." loading="lazy" width="624" height="211" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/image-6-7-O4ALO4E7.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Tree evaluation</figcaption></div></figure>
<p>To handle this, we define the CompositePredicate interface, extending Predicate, with concrete implementations: AndPredicate, OrPredicate, and NotPredicate. These classes compose multiple predicates into a single unit, evaluated recursively:</p>
<ul>
<li>AndPredicate takes a list of predicates (e.g., A, B, C) and returns true only if all succeed for a given file.</li>
<li>OrPredicate takes a list (e.g., the AndPredicate result and another group) and returns true if at least one succeeds.</li>
<li>NotPredicate wraps a single predicate (e.g., E) and inverts its result.</li>
</ul>
<p>In our example:</p>
<ul>
<li>AndPredicate combines "size &gt; 10", "size &lt; 1000", and "owner = 'alice'" into one check.</li>
<li>Another AndPredicate pairs "size &gt; 1000" with a NotPredicate that negates "filename matches 'prefix.*'".</li>
<li>OrPredicate links these two groups, returning true if either holds.</li>
</ul>
<p>This structure, rooted in CompositePredicate, delivers a boolean result to FileSearchCriteria efficiently by distributing evaluation across the tree, avoiding redundant checks.</p>
<p>The UML diagram below illustrates this recursive composition.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a class diagram illustrating a composite pattern for predicates.  At the top is an interface `Predicate` with a single method `boolean isMatch(File)`.  This interface is implemented by `SimplePredicate`, which has attributes `FileAttribute attributeName`, `ComparisonOperator operator`, and `String expectedValue`, and also implements the `isMatch(File)` method.  `Predicate` is also implemented by `CompositePredicate`, an interface representing a combination of other predicates.  `CompositePredicate` is further implemented by three concrete classes: `AndPredicate`, which contains a `List&lt;Predicate&gt; operands` and an `isMatch(File)` method; `OrPredicate`, similarly containing a `List&lt;Predicate&gt; operands` and an `isMatch(File)` method; and `NotPredicate`, which has a `Predicate operand` and an `isMatch(File)` method.  Dashed lines indicate implementation relationships, showing how the concrete classes implement the interfaces.  Solid lines show inheritance relationships. The diagram shows how simple predicates can be combined using composite predicates to create more complex filtering logic." loading="lazy" width="624" height="417" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/image-6-8-M7TNT6W6.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">CompositePredicate interface and concrete classes</figcaption></div></figure>
<p>With all classes defined, let’s review how they fit together in the complete class diagram.</p>
<h3 id="complete-class-diagram">Complete Class Diagram</h3>
<p>Having built our classes, from the hierarchical File structure to the intricate predicate logic, we’re ready to see the complete system in a UML class diagram below. The detailed methods and attributes are skipped to make the diagram more readable.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a class diagram illustrating a file search system.  The `FileSearch` class, containing a `search` method that takes a `File` and `FileSearchCriteria` as input and returns a list of `File` objects, is at the top.  `FileSearch` uses `FileSearchCriteria` to evaluate the search and `traverses` a collection of `File` objects.  `FileSearchCriteria` uses a `Predicate` to determine if a file matches the criteria.  `Predicate` is an interface with an `isMatch` method.  This interface is implemented by `SimplePredicate`, `AndPredicate`, `OrPredicate`, and `NotPredicate`, forming a composite pattern. `SimplePredicate` uses a `ComparisonOperator` and `FileAttribute` to perform simple comparisons (e.g., file size &gt; 10KB). `FileAttribute` is an enumeration representing file properties (IS_DIRECTORY, SIZE, OWNER, FILENAME).  `CompositePredicate` classes combine simpler predicates using logical AND, OR, and NOT operations.  The `File` class has methods to extract `FileAttribute` values, add entries, and retrieve all entries as a set.  Dashed lines indicate inheritance or implementation relationships, while solid lines with filled diamonds represent composition.  The `0..*` notation indicates a one-to-many relationship between `File` and `FileSearchCriteria`." loading="lazy" width="624" height="641" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/image-6-9-KA2ZDXCM.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Class Diagram of File Search</figcaption></div></figure>
<h2 id="code---unix-file-search">Code - Unix File Search</h2>
<p>Now that the design is in place, we can move on to implementing the core components: defining files and their attributes, applying conditions to evaluate matches, and performing the actual file search across the directory structure.</p>
<h3 id="file-1">File</h3>
<p>The File class models both files and directories in our search system, encapsulating attributes such as size, name, owner, and a boolean flag indicating directory status. It maintains a hierarchical structure through a set of child File objects, which represent the contents of subdirectories. Built for immutability, it offers no setters. Attributes are set at construction and remain unchanged, ensuring data consistency throughout the search process.</p>
<p>Tied to this, the FileAttribute enum defines the searchable properties, such as SIZE or OWNER, enabling SimplePredicate to extract the correct value (e.g., size for a "size &gt; 10" condition) during evaluation.</p>
<p>Below is the code implementation:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Represents a file or directory in the file system</span>
<span class="hljs-comment">// Contains basic file attributes and supports hierarchical structure</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isDirectory;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> size;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String owner;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String filename;
    <span class="hljs-comment">// Set of directory entries (files and subdirectories)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;File&gt; entries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

    <span class="hljs-comment">// Creates a new file with the specified attributes</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(
            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isDirectory,
            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> size,
            <span class="hljs-keyword">final</span> String owner,
            <span class="hljs-keyword">final</span> String filename)</span> {
        <span class="hljs-built_in">this</span>.isDirectory = isDirectory;
        <span class="hljs-built_in">this</span>.size = size;
        <span class="hljs-built_in">this</span>.owner = owner;
        <span class="hljs-built_in">this</span>.filename = filename;
    }

    <span class="hljs-comment">// Extracts the value of a specified file attribute</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">extract</span><span class="hljs-params">(<span class="hljs-keyword">final</span> FileAttribute attributeName)</span> {
        <span class="hljs-keyword">switch</span> (attributeName) {
            <span class="hljs-keyword">case</span> SIZE -&gt; {
                <span class="hljs-keyword">return</span> size;
            }
            <span class="hljs-keyword">case</span> OWNER -&gt; {
                <span class="hljs-keyword">return</span> owner;
            }
            <span class="hljs-keyword">case</span> IS_DIRECTORY -&gt; {
                <span class="hljs-keyword">return</span> isDirectory;
            }
            <span class="hljs-keyword">case</span> FILENAME -&gt; {
                <span class="hljs-keyword">return</span> filename;
            }
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"invalid filter criteria type"</span>);
    }

    <span class="hljs-comment">// Adds a file or directory entry to this directory</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File entry)</span> {
        entries.add(entry);
    }

    <span class="hljs-comment">// getter methods omitted for brevity</span>
}

<span class="hljs-comment">// Represents the different attributes that can be checked for a file</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FileAttribute</span> {
    IS_DIRECTORY,
    SIZE,
    OWNER,
    FILENAME
}
</code></pre>
<ul>
<li>The extract method retrieves a specific attribute’s value by mapping a FileAttribute enum constant (like SIZE or OWNER) to its corresponding field. This provides SimplePredicate with the value needed to evaluate a condition, such as size for "size &gt; 10".</li>
<li>Complementing this, the addEntry method builds the directory hierarchy by adding a File instance to the entries set, enabling the recursive structure essential for file system traversal.</li>
</ul>
<h3 id="predicate">Predicate</h3>
<p>The Predicate interface defines the contract for evaluating whether a File satisfies a search condition, serving as the cornerstone of our system’s filtering logic. It declares a single method, isMatch, which accepts a File instance and returns a boolean: true if the file meets the condition, false otherwise. Here’s its implementation:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Base interface for all file search predicates</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span> {
    <span class="hljs-comment">// Checks if the given file matches the search condition</span>
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File inputFile)</span>;
}
</code></pre>
<p>This method powers FileSearchCriteria by providing the yes-or-no decision needed to filter files during traversal. Its abstract nature ensures flexibility, supporting everything from simple checks like "size &gt; 10" to complex combinations, laying the groundwork for both SimplePredicate and CompositePredicate implementations.</p>
<h3 id="comparisonoperator-1">ComparisonOperator</h3>
<p>The ComparisonOperator interface specifies a contract for comparing a file’s attribute value to an expected value, enabling precise condition checks, such as "is the size greater than 10?" or "does the filename match log.*?". It defines an isMatch method that takes two parameters (the attribute’s actual value and the target value) and returns a boolean indicating if the comparison holds.</p>
<p>We use generics (&lt;T&gt;) to enforce type safety, ensuring that numeric attributes (e.g., Double for size) are compared only with numbers, and string attributes (e.g., String for names) are compared only with strings.</p>
<p>Below is the implementation of this interface:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Base interface for all comparison operations in the file search system</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ComparisonOperator</span>&lt;T&gt; {
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T attributeValue, <span class="hljs-keyword">final</span> T expectedValue)</span>;
}
</code></pre>
<p>Concrete implementations, such as EqualsOperator, GreaterThanOperator, LessThanOperator, and RegexMatchOperator, encapsulate the logic for equality, ordering, and pattern matching, each tailored to its respective type. These are shown below.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Implements exact equality comparison between values</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EqualsOperator</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComparisonOperator</span>&lt;T&gt; {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T attributeValue, <span class="hljs-keyword">final</span> T expectedValue)</span> {
        <span class="hljs-keyword">return</span> Objects.equals(attributeValue, expectedValue);
    }
}

<span class="hljs-comment">// Implements greater than comparison for numeric values</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterThanOperator</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComparisonOperator</span>&lt;T&gt; {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T attributeValue, <span class="hljs-keyword">final</span> T expectedValue)</span> {
        <span class="hljs-keyword">return</span> Double.compare(attributeValue.doubleValue(), expectedValue.doubleValue()) &gt; <span class="hljs-number">0</span>;
    }
}

<span class="hljs-comment">// Implements less than comparison for numeric values</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LessThanOperator</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComparisonOperator</span>&lt;T&gt; {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T attributeValue, <span class="hljs-keyword">final</span> T expectedValue)</span> {
        <span class="hljs-keyword">return</span> Double.compare(attributeValue.doubleValue(), expectedValue.doubleValue()) &lt; <span class="hljs-number">0</span>;
    }
}

<span class="hljs-comment">// Implements regular expression pattern matching for string values</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexMatchOperator</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">String</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComparisonOperator</span>&lt;T&gt; {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T attributeValue, <span class="hljs-keyword">final</span> T expectedValue)</span> {
        <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(expectedValue);
        <span class="hljs-keyword">return</span> p.matcher(attributeValue).matches();
    }
}
</code></pre>
<p>The isMatch method takes an actual value (from a File attribute) and an expected value (set in SimplePredicate), and returns true if they satisfy the operator’s rule.</p>
<p><strong>Implementation choice:</strong> We leverage generics (&lt;T&gt;) in this design to enforce type safety at compile time, ensuring that attribute values and expected values align in type, such as Double for size or String for filename, making the code robust and readable.</p>
<h3 id="simplepredicate">SimplePredicate</h3>
<p>The SimplePredicate class implements the Predicate interface to test a File against a single condition, such as whether its size exceeds 10 or its owner is "bob". Designed with generics (&lt;T&gt;), it pairs a FileAttribute enum value (e.g., SIZE, OWNER) with a ComparisonOperator&lt;T&gt; and an expected value of type T to define the check.</p>
<p>Here’s how it’s structured:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// A basic predicate that compares a file attribute with an expected value</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplePredicate</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Predicate</span> {
    <span class="hljs-comment">// The name of the file attribute to check</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FileAttribute attributeName;
    <span class="hljs-comment">// The operator to use for comparison (equals, contains, greater than, etc.)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ComparisonOperator&lt;T&gt; operator;
    <span class="hljs-comment">// The expected value to compare against</span>
    T expectedValue;

    <span class="hljs-comment">// Creates a new simple predicate with the specified attribute, operator, and</span>
    <span class="hljs-comment">// expected value</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimplePredicate</span><span class="hljs-params">(
            <span class="hljs-keyword">final</span> FileAttribute attributeName,
            <span class="hljs-keyword">final</span> ComparisonOperator&lt;T&gt; operator,
            <span class="hljs-keyword">final</span> T expectedValue)</span> {
        <span class="hljs-built_in">this</span>.attributeName = attributeName;
        <span class="hljs-built_in">this</span>.operator = operator;
        <span class="hljs-built_in">this</span>.expectedValue = expectedValue;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File inputFile)</span> {
        <span class="hljs-comment">// Extract the actual value of the attribute from the file</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">actualValue</span> <span class="hljs-operator">=</span> inputFile.extract(attributeName);
        <span class="hljs-comment">// Check if the actual value is of the correct type</span>
        <span class="hljs-keyword">if</span> (expectedValue.getClass().isInstance(actualValue)) {
            <span class="hljs-comment">// Perform the comparison using the specified operator</span>
            <span class="hljs-keyword">return</span> operator.isMatch((T) actualValue, expectedValue);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<p>This implementation of SimplePredicate ensures type safety and modularity, allowing FileSearchCriteria to apply precise, single-attribute filters across the filesystem traversal.</p>
<h3 id="compositepredicate">CompositePredicate</h3>
<p>The CompositePredicate interface extends Predicate to combine multiple predicates into complex conditions, such as "size &gt; 10 and owner = 'bob'". We follow the Composite design pattern, which organizes predicates into a tree where simple ones (like SimplePredicate) act as leaves and combinations (like AndPredicate) act as nodes, all sharing the Predicate interface. This lets us evaluate them recursively, treating single and combined conditions the same way.</p>
<p>Here’s the code:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CompositePredicate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Predicate</span> {
    <span class="hljs-comment">// This interface is intentionally empty as it serves as a marker</span>
    <span class="hljs-comment">// to identify predicates that combine multiple other predicates (AND, OR, NOT)</span>
}

<span class="hljs-comment">// Implements logical AND operation between multiple predicates</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompositePredicate</span> {
    <span class="hljs-comment">// List of predicates that must all match for this predicate to match</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Predicate&gt; operands;

    <span class="hljs-comment">// Creates a new AND predicate with the specified predicates</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndPredicate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> List&lt;Predicate&gt; operands)</span> {
        <span class="hljs-built_in">this</span>.operands = operands;
    }

    <span class="hljs-comment">// Checks if the given file matches ALL predicates</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File inputFile)</span> {
        <span class="hljs-keyword">return</span> operands.stream().allMatch(predicate -&gt; predicate.isMatch(inputFile));
    }
}

<span class="hljs-comment">// Implements logical OR operation between multiple predicates</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompositePredicate</span> {
    <span class="hljs-comment">// List of predicates, at least one of which must match</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Predicate&gt; operands;

    <span class="hljs-comment">// Creates a new OR predicate with the specified predicates</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrPredicate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> List&lt;Predicate&gt; operands)</span> {
        <span class="hljs-built_in">this</span>.operands = operands;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File inputFile)</span> {
        <span class="hljs-keyword">return</span> operands.stream().anyMatch(predicate -&gt; predicate.isMatch(inputFile));
    }
}

<span class="hljs-comment">// Implements logical NOT operation on a predicate</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompositePredicate</span> {
    <span class="hljs-comment">// The predicate to negate</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Predicate operand;

    <span class="hljs-comment">// Creates a new NOT predicate with the specified predicate to negate</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NotPredicate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Predicate operand)</span> {
        <span class="hljs-built_in">this</span>.operand = operand;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File inputFile)</span> {
        <span class="hljs-keyword">return</span> !operand.isMatch(inputFile);
    }
}
</code></pre>
<ul>
<li>AndPredicate checks if all conditions pass (e.g., "size &gt; 10 and owner = 'bob'").</li>
<li>OrPredicate checks if any condition passes (e.g., "size &gt; 10 or owner = 'bob'").</li>
<li>NotPredicate takes a single predicate and flips its isMatch result (e.g., "filename not ending with '.txt'").</li>
<li>AndPredicate and OrPredicate use List&lt;Predicate&gt; to support any number of conditions.</li>
<li>NotPredicate takes just one condition.</li>
<li>Combined Impact: Enables FileSearchCriteria to process nested logical conditions efficiently.</li>
</ul>
<h3 id="filesearchcriteria-1">FileSearchCriteria</h3>
<p>The FileSearchCriteria class acts as a bridge between FileSearch and the predicate-based conditions that determine which files match, delegating the evaluation to a Predicate, whether a SimplePredicate or CompositePredicate. Here’s its implementation:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Wrapper class that encapsulates a search condition for file matching</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearchCriteria</span> {
    <span class="hljs-comment">// The predicate that defines what makes a file match</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Predicate predicate;

    <span class="hljs-comment">// Constructor that takes a predicate defining the criteria</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSearchCriteria</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Predicate predicate)</span> {
        <span class="hljs-built_in">this</span>.predicate = predicate;
    }

    <span class="hljs-comment">// Checks if the given file matches the search criteria</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File inputFile)</span> {
        <span class="hljs-keyword">return</span> predicate.isMatch(inputFile);
    }
}
</code></pre>
<p>This design centers on the isMatch method, which invokes the Predicate’s logic to assess a File and returns true for matches, such as "size &gt; 10" with SimplePredicate or "size &gt; 10 and owner = 'bob'" with CompositePredicate.</p>
<p><strong>Implementation choice:</strong> We chose to wrap the Predicate in FileSearchCriteria to keep FileSearch focused solely on filesystem traversal and isolate condition evaluation to a separate, reusable layer.</p>
<p><strong>Alternate implementation:</strong> Instead of using FileSearchCriteria, FileSearch could directly invoke the Predicate's logic to evaluate files. However, this would tightly couple traversal and filtering logic, making it harder to modify or extend conditions independently.</p>
<h3 id="filesearch-1">FileSearch</h3>
<p>The FileSearch class orchestrates the search across the filesystem, starting from a root File and leveraging FileSearchCriteria to identify matching files through recursive traversal. It employs a stack-based approach to explore directories efficiently. Here’s the implementation:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Main class responsible for performing file system searches</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearch</span> {
    <span class="hljs-comment">// Performs a recursive search through the file system starting from root</span>
    <span class="hljs-comment">// Returns a list of files that match the given criteria</span>
    <span class="hljs-keyword">public</span> List&lt;File&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File root, <span class="hljs-keyword">final</span> FileSearchCriteria criteria)</span> {
        <span class="hljs-comment">// List to store matching files</span>
        <span class="hljs-keyword">final</span> List&lt;File&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-comment">// Stack to handle recursive traversal without actual recursion</span>
        <span class="hljs-keyword">final</span> ArrayDeque&lt;File&gt; recursionStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();
        <span class="hljs-comment">// Start with the root directory</span>
        recursionStack.add(root);
        <span class="hljs-comment">// Continue until we've processed all files</span>
        <span class="hljs-keyword">while</span> (!recursionStack.isEmpty()) {
            <span class="hljs-comment">// Get the next file to process</span>
            <span class="hljs-type">File</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> recursionStack.pop();
            <span class="hljs-comment">// Check if the file matches our criteria</span>
            <span class="hljs-keyword">if</span> (criteria.isMatch(next)) {
                result.add(next);
            }
            <span class="hljs-comment">// Add all directory entries to the stack for processing</span>
            <span class="hljs-keyword">for</span> (File entry : next.getEntries()) {
                recursionStack.push(entry);
            }
        }
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre>
<p>This search method begins by initializing a result list and an ArrayDeque stack with the root File. It then processes each file by popping it from the stack, evaluating it with the criteria.isMatch, and adding matches to the result. For directories, it pushes all entries onto the stack, ensuring every file is visited in a depth-first manner. The returned List&lt;File&gt; contains all matches, mutable for flexibility in downstream use, by the client code.</p>
<p><strong>Implementation choice:</strong> We opted for a stack over recursive calls to prevent stack overflow in deep filesystems, balancing efficiency with robustness. Alternatively, a recursive method could work for smaller structures, but it risks failure on large or deeply nested directories.</p>
<h2 id="deep-dive-topic">Deep Dive Topic</h2>
<p>Now that the basic design is complete, the interviewer might ask you some deep dive questions. Let’s check out some of these.</p>
<h3 id="file-search-test">File search test</h3>
<p>After implementing our classes, it’s a good idea to verify the end-to-end logic. The UNIX file search problem is abstract, so we create a test case to demonstrate how it works.</p>
<p>Here’s a test case for the condition "non-directories owned by 'ge.*'":</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearchTest</span> {
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFileSearch</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Create a root directory and two files with different owners</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"adam"</span>, <span class="hljs-string">"root"</span>);
        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">"adam"</span>, <span class="hljs-string">"a"</span>);
        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">3000</span>, <span class="hljs-string">"george"</span>, <span class="hljs-string">"b"</span>);

        <span class="hljs-comment">// Add files to the root directory</span>
        root.addEntry(a);
        root.addEntry(b);

        <span class="hljs-comment">// Search criteria: Find non-directory files owned by users matching "ge.*"</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">FileSearchCriteria</span> <span class="hljs-variable">criteria</span> <span class="hljs-operator">=</span>
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchCriteria</span>(
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndPredicate</span>(
                                List.of(
                                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimplePredicate</span>&lt;&gt;(
                                                FileAttribute.IS_DIRECTORY,
                                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">EqualsOperator</span>&lt;&gt;(),
                                                <span class="hljs-literal">false</span>),
                                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimplePredicate</span>&lt;&gt;(
                                                FileAttribute.OWNER,
                                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegexMatchOperator</span>&lt;&gt;(),
                                                <span class="hljs-string">"ge.*"</span>))));

        <span class="hljs-comment">// Execute the search and get results</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">FileSearch</span> <span class="hljs-variable">fileSearch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearch</span>();
        <span class="hljs-keyword">final</span> List&lt;File&gt; result = fileSearch.search(root, criteria);

        <span class="hljs-comment">// Verify that only one file matches the criteria</span>
        assertEquals(<span class="hljs-number">1</span>, result.size());
        <span class="hljs-comment">// Verify that the matching file is "b"</span>
        assertEquals(<span class="hljs-string">"b"</span>, result.get(<span class="hljs-number">0</span>).getFilename());
    }
}

</code></pre>
<h2 id="wrap-up">Wrap Up</h2>
<p>With the UNIX file search system fully implemented and tested, it’s time to step back and consider what we’ve achieved. This chapter began by gathering requirements through a structured dialogue, then progressed to defining core objects, crafting their class structure, and coding the essential components.</p>
<p>The system's maintainability and extensibility are ensured by the clear division of responsibilities among the classes: File, FileSearch, FileSearchCriteria, and Predicate, which respectively represent files, traverse directories, evaluate conditions, and define match logic. Our choices, such as separating FileSearch from FileSearchCriteria and using generics in ComparisonOperator, improve scalability and maintain type safety throughout processes. We could have merged FileSearchCriteria with Predicate into one class for a tighter initial design, but this would blur their distinct roles, making it harder to update or swap condition logic without affecting traversal.</p>
<p>Congratulations on getting this far! Now give yourself a pat on the back. Good job!</p>
<h2 id="further-reading-composite-design-pattern">Further Reading: Composite Design Pattern</h2>
<p>This section gives a quick overview of the design patterns used in this chapter. It’s helpful if you’re new to these patterns or need a refresher to better understand the design choices.</p>
<h3 id="composite-design-pattern">Composite design pattern</h3>
<p>Composite is a structural pattern that lets you organize objects into tree structures and then handle these structures as if they were individual objects.</p>
<p><strong>Problem</strong></p>
<p>Imagine you have two types of objects: Files and Folders. A Folder can contain several Files as well as many smaller Folders and so on. Say you decide to create a search system that uses these classes. Searches could involve simple Files on their own, as well as Folders packed with Files, and other Folders. How would you find all items matching a specific condition, like "size &gt; 10," across this structure?</p>
<p><strong>Solution</strong></p>
<p>The Composite pattern suggests that we work with Files and Folders through a common interface that declares a method for checking conditions.</p>
<p>Here’s how this method works:</p>
<ul>
<li><strong>For a File</strong>: It checks if the File matches the condition, like "size &gt; 10," and gives a yes or no answer.</li>
<li><strong>For a Folder</strong>:
<ul>
<li>It examines each item within, testing whether it meets the condition.</li>
<li>It recursively applies this process to any nested folders, traversing the entire tree until all items are evaluated.</li>
<li>It can also enforce its constraint, such as "not a directory," to refine the result.</li>
</ul>
</li>
</ul>
<p>Here’s a simple diagram showing the Composite pattern for Files and Folders:</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a class diagram illustrating an inheritance relationship and a composition relationship in object-oriented programming.  At the top is an interface labeled 'I Item', represented by a rectangle with a large, shaded circle containing the letter 'I' in the upper left corner.  Two classes, 'C File' and 'C Folder', are positioned below, each represented by a rectangle with a large, shaded circle containing the letter 'C' in the upper left corner.  Dashed lines with open arrowheads connect 'I Item' to both 'C File' and 'C Folder', indicating that both 'File' and 'Folder' implement the 'Item' interface. A solid line with a filled diamond at the 'Folder' end connects 'I Item' to 'C Folder', labeled 'many', signifying that one 'Item' can contain many 'Folder' instances, representing a composition relationship where 'Folder' objects are part of the 'Item' object's structure.  The diagram shows that both 'File' and 'Folder' are types of 'Item', and that 'Item' can contain multiple 'Folder' instances." loading="lazy" width="245" height="253" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/object-oriented-design-interview/design-a-unix-file-search/image-6-10-OUZY7I67.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Item interface and concrete classes</figcaption></div></figure>
<p>Item is the common interface that both File and Folder use. The advantage is that we can treat all objects, File or nested Folder, the same through the common interface, letting them pass the check down the tree without knowing their types.</p>
<p><strong>When to use</strong></p>
<p>The Composite design pattern is useful in scenarios where:</p>
<ul>
<li>You need to build a tree-like object structure.</li>
<li>When you want the client code to handle both simple and complex elements uniformly.</li>
</ul>
        </article>
    </main>

    <div class="nav">
        <a href="../object-oriented-design-interview.html">← Course Contents</a>
        <a href="design-a-movie-ticket-booking-system.html">← Previous</a>
        <a href="design-a-vending-machine.html">Next →</a>
    </div>

    <footer class="metadata">
        <p>Scraped on 10/10/2025</p>
    </footer>
</body>
</html>