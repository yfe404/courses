<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design A Rate Limiter - System Design Interview</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Open Sans', Arial, sans-serif;
    font-size: 16px;
    line-height: 1.6;
    color: #454545;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    font-size: 2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.2;
}

h2 {
    font-size: 1.5em;
    margin: 1.2em 0 0.6em 0;
    line-height: 1.3;
}

h3 {
    font-size: 1.2em;
    margin: 1em 0 0.5em 0;
    line-height: 1.4;
}

p {
    margin: 0.8em 0;
}

a {
    color: #0077aa;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

ul, ol {
    margin: 0.8em 0;
    padding-left: 2em;
}

li {
    margin: 0.4em 0;
}

code, pre {
    background: #f4f4f4;
    border: 1px solid #ddd;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
}

code {
    padding: 2px 5px;
}

pre {
    padding: 10px;
    overflow-x: auto;
    margin: 1em 0;
}

pre code {
    border: none;
    padding: 0;
}

img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 1.5em auto;
}

figure {
    margin: 1.5em 0;
    text-align: center;
}

figcaption {
    font-style: italic;
    font-size: 0.9em;
    color: #666;
    margin-top: 0.5em;
}

.chapter-number {
    font-weight: bold;
    color: #0077aa;
}

.nav {
    margin: 2em 0;
    padding: 1em 0;
    border-top: 1px solid #ddd;
    border-bottom: 1px solid #ddd;
}

.nav a {
    margin-right: 1em;
}

.toc {
    list-style: none;
    padding: 0;
}

.toc li {
    margin: 0.8em 0;
}

.course-section {
    margin: 2em 0;
}

.course-title {
    font-size: 1.3em;
    font-weight: bold;
    color: #0077aa;
    margin: 1.5em 0 0.8em 0;
}

.metadata {
    font-size: 0.9em;
    color: #888;
    margin: 2em 0 1em 0;
}

.breadcrumb {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 1em;
}

.breadcrumb a {
    color: #0077aa;
}

@media (max-width: 600px) {
    body {
        padding: 10px;
    }

    h1 {
        font-size: 1.5em;
    }

    h2 {
        font-size: 1.3em;
    }
}</style>
</head>
<body>
    <div class="breadcrumb">
        <a href="../../index.html">Home</a> /
        <a href="../system-design-interview.html">System Design Interview</a> /
        Design A Rate Limiter
    </div>

    <div class="nav">
        <a href="../system-design-interview.html">← Course Contents</a>
        <a href="a-framework-for-system-design-interviews.html">← Previous</a>
        <a href="design-consistent-hashing.html">Next →</a>
    </div>

    <main>
        <h1>
            <span class="chapter-number">05</span> Design A Rate Limiter
        </h1>

        <div class="metadata">
            <a href="https://bytebytego.com/courses/system-design-interview/design-a-rate-limiter" target="_blank" rel="noopener">Original source</a>
        </div>

        <article>
            <header><strong class="style_chapter__grtAe">05</strong><h1>Design A Rate Limiter</h1></header><p>In a network system, a rate limiter is used to control the rate of traffic sent by a client or a service. In the HTTP world, a rate limiter limits the number of client requests allowed to be sent over a specified period. If the API request count exceeds the threshold defined by the rate limiter, all the excess calls are blocked. Here are a few examples:</p>
<ul>
<li>
<p>A user can write no more than 2 posts per second.</p>
</li>
<li>
<p>You can create a maximum of 10 accounts per day from the same IP address.</p>
</li>
<li>
<p>You can claim rewards no more than 5 times per week from the same device.</p>
</li>
</ul>
<p>In this chapter, you are asked to design a rate limiter. Before starting the design, we first look at the benefits of using an API rate limiter:</p>
<ul>
<li>
<p>Prevent resource starvation caused by Denial of Service (DoS) attack [1]. Almost all APIs published by large tech companies enforce some form of rate limiting. For example, Twitter limits the number of tweets to 300 per 3 hours [2]. Google docs APIs have the following default limit: 300 per user per 60 seconds for read requests [3]. A rate limiter prevents DoS attacks, either intentional or unintentional, by blocking the excess calls.</p>
</li>
<li>
<p>Reduce cost. Limiting excess requests means fewer servers and allocating more resources to high priority APIs. Rate limiting is extremely important for companies that use paid third party APIs. For example, you are charged on a per-call basis for the following external APIs: check credit, make a payment, retrieve health records, etc. Limiting the number of calls is essential to reduce costs.</p>
</li>
<li>
<p>Prevent servers from being overloaded. To reduce server load, a rate limiter is used to filter out excess requests caused by bots or users’ misbehavior.</p>
</li>
</ul>
<h2 id="step-1---understand-the-problem-and-establish-design-scope">Step 1 - Understand the problem and establish design scope</h2>
<p>Rate limiting can be implemented using different algorithms, each with its pros and cons. The interactions between an interviewer and a candidate help to clarify the type of rate limiters we are trying to build.</p>
<p><strong>Candidate</strong>: What kind of rate limiter are we going to design? Is it a client-side rate limiter or server-side API rate limiter?<br>
<strong>Interviewer</strong>: Great question. We focus on the server-side API rate limiter.</p>
<p><strong>Candidate</strong>: Does the rate limiter throttle API requests based on IP, the user ID, or other properties?<br>
<strong>Interviewer</strong>: The rate limiter should be flexible enough to support different sets of throttle rules.</p>
<p><strong>Candidate</strong>: What is the scale of the system? Is it built for a startup or a big company with a large user base?<br>
<strong>Interviewer</strong>: The system must be able to handle a large number of requests.</p>
<p><strong>Candidate</strong>: Will the system work in a distributed environment?<br>
<strong>Interviewer</strong>: Yes.</p>

<p><strong>Candidate</strong>: Is the rate limiter a separate service or should it be implemented in application code?<br>
<strong>Interviewer</strong>: It is a design decision up to you.</p>
<p><strong>Candidate</strong>: Do we need to inform users who are throttled?<br>
<strong>Interviewer</strong>: Yes.</p>
<p><strong>Requirements</strong></p>
<p>Here is a summary of the requirements for the system:</p>
<ul>
<li>
<p>Accurately limit excessive requests.</p>
</li>
<li>
<p>Low latency. The rate limiter should not slow down HTTP response time.</p>
</li>
<li>
<p>Use as little memory as possible.</p>
</li>
<li>
<p>Distributed rate limiting. The rate limiter can be shared across multiple servers or processes.</p>
</li>
<li>
<p>Exception handling. Show clear exceptions to users when their requests are throttled.</p>
</li>
<li>
<p>High fault tolerance. If there are any problems with the rate limiter (for example, a cache server goes offline), it does not affect the entire system.</p>
</li>
</ul>
<h2 id="step-2---propose-high-level-design-and-get-buy-in">Step 2 - Propose high-level design and get buy-in</h2>
<p>Let us keep things simple and use a basic client and server model for communication.</p>
<h3 id="where-to-put-the-rate-limiter">Where to put the rate limiter?</h3>
<p>Intuitively, you can implement a rate limiter at either the client or server-side.</p>
<ul>
<li>
<p>Client-side implementation. Generally speaking, client is an unreliable place to enforce rate limiting because client requests can easily be forged by malicious actors. Moreover, we might not have control over the client implementation.</p>
</li>
<li>
<p>Server-side implementation. Figure 1 shows a rate limiter that is placed on the server-side.</p>
</li>
</ul>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified client-server architecture with a rate limiter.  A light-blue rectangular box labeled 'Client' contains icons representing a laptop and a smartphone, signifying that requests originate from various client devices. A thick, blue arrow labeled 'HTTP request' extends from the Client box to a group of three vertically stacked, light-green rectangular boxes representing 'API Servers,' which are enclosed within a dashed light-blue rounded rectangle.  Adjacent to the API Servers, a white rectangular box labeled 'Rate limiter' is shown, suggesting that the rate limiter sits between the client requests and the API servers. The arrow indicates that the HTTP request flows from the client, through the rate limiter, and finally reaches the API servers.  The arrangement visually depicts a system where the rate limiter manages the flow of HTTP requests from clients to prevent server overload." loading="lazy" width="500" height="103" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(500px, 100vw), (max-width: 1200px) min(500px, 80vw), min(500px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-1-5NU243KC.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-1-5NU243KC.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-1-5NU243KC.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-1-5NU243KC.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-1-5NU243KC.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-1-5NU243KC.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-1-5NU243KC.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-1-5NU243KC.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-1-5NU243KC.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 1</figcaption></div></figure>
<p>Besides the client and server-side implementations, there is an alternative way. Instead of putting a rate limiter at the API servers, we create a rate limiter middleware, which throttles requests to your APIs as shown in Figure 2.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified client-server architecture with a rate limiter.  A light-blue rounded rectangle labeled 'Client' contains icons representing a laptop and a smartphone, symbolizing various client devices. A solid blue arrow originates from the Client box, indicating requests flowing towards a vertical rectangular component labeled 'Rate limiter'. This rate limiter acts as a gatekeeper, processing requests before they reach the servers.  Another solid blue arrow extends from the rate limiter to a dashed light-blue rounded rectangle labeled 'API Servers'.  Inside this rectangle are three vertically stacked green rectangles representing multiple API servers. The arrows indicate the unidirectional flow of requests from clients, through the rate limiter, and finally to the API servers for processing.  The overall diagram illustrates a common system design pattern where a rate limiter is used to manage and control the number of requests reaching the backend servers, preventing overload and ensuring system stability." loading="lazy" width="500" height="187" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(500px, 100vw), (max-width: 1200px) min(500px, 80vw), min(500px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-2-GC455Q56.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-2-GC455Q56.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-2-GC455Q56.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-2-GC455Q56.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-2-GC455Q56.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-2-GC455Q56.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-2-GC455Q56.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-2-GC455Q56.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-2-GC455Q56.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 2</figcaption></div></figure>
<p>Let us use an example in Figure 3 to illustrate how rate limiting works in this design. Assume our API allows 2 requests per second, and a client sends 3 requests to the server within a second. The first two requests are routed to API servers. However, the rate limiter middleware throttles the third request and returns a HTTP status code 429. The HTTP 429 response status code indicates a user has sent too many requests.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system architecture diagram illustrating rate limiting in an API.  A light-blue rounded rectangle labeled 'Client' contains icons representing a laptop and a mobile phone, signifying multiple client devices.  Multiple solid blue arrows emanate from the Client, representing requests, and point towards a tall, dark-grey rectangle labeled 'Rate limiter.'  Some requests successfully pass through the Rate limiter, indicated by the continuation of the arrows to a dashed light-blue rounded rectangle labeled 'API Servers,' which depicts three vertically stacked green server icons.  However, one request is blocked by the Rate limiter, shown by a red 'X' and a dashed red arrow pointing back to the Client with the label '429: Too many requests,' indicating a HTTP 429 error response due to exceeding the rate limit.  The diagram clearly shows the flow of requests from clients, their filtering by the Rate limiter, and the potential for rejection based on exceeding a defined request rate." loading="lazy" width="500" height="189" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(500px, 100vw), (max-width: 1200px) min(500px, 80vw), min(500px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-3-KLFLUVLJ.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-3-KLFLUVLJ.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-3-KLFLUVLJ.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-3-KLFLUVLJ.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-3-KLFLUVLJ.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-3-KLFLUVLJ.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-3-KLFLUVLJ.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-3-KLFLUVLJ.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-3-KLFLUVLJ.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 3</figcaption></div></figure>
<p>Cloud microservices [4] have become widely popular and rate limiting is usually implemented within a component called API gateway. API gateway is a fully managed service that supports rate limiting, SSL termination, authentication, IP whitelisting, servicing static content, etc. For now, we only need to know that the API gateway is a middleware that supports rate limiting.</p>
<p>While designing a rate limiter, an important question to ask ourselves is: where should the rate limiter be implemented, on the server-side or in a gateway? There is no absolute answer. It depends on your company’s current technology stack, engineering resources, priorities, goals, etc. Here are a few general guidelines:</p>
<ul>
<li>
<p>Evaluate your current technology stack, such as programming language, cache service, etc. Make sure your current programming language is efficient to implement rate limiting on the server-side.</p>
</li>
<li>
<p>Identify the rate limiting algorithm that fits your business needs. When you implement everything on the server-side, you have full control of the algorithm. However, your choice might be limited if you use a third-party gateway.</p>
</li>
<li>
<p>If you have already used microservice architecture and included an API gateway in the design to perform authentication, IP whitelisting, etc., you may add a rate limiter to the API gateway.</p>
</li>
<li>
<p>Building your own rate limiting service takes time. If you do not have enough engineering resources to implement a rate limiter, a commercial API gateway is a better option.</p>
</li>
</ul>
<h3 id="algorithms-for-rate-limiting">Algorithms for rate limiting</h3>
<p>Rate limiting can be implemented using different algorithms, and each of them has distinct pros and cons. Even though this chapter does not focus on algorithms, understanding them at high-level helps to choose the right algorithm or combination of algorithms to fit our use cases. Here is a list of popular algorithms:</p>
<ul>
<li>
<p>Token bucket</p>
</li>
<li>
<p>Leaking bucket</p>
</li>
<li>
<p>Fixed window counter</p>
</li>
<li>
<p>Sliding window log</p>
</li>
<li>
<p>Sliding window counter</p>
</li>
</ul>
<h4 id="token-bucket-algorithm">Token bucket algorithm</h4>
<p>The token bucket algorithm is widely used for rate limiting. It is simple, well understood and commonly used by internet companies. Both Amazon [5] and Stripe [6] use this algorithm to throttle their API requests.</p>
<p>The token bucket algorithm work as follows:</p>
<ul>
<li>A token bucket is a container that has pre-defined capacity. Tokens are put in the bucket at preset rates periodically. Once the bucket is full, no more tokens are added. As shown in Figure 4, the token bucket capacity is 4. The refiller puts 2 tokens into the bucket every second. Once the bucket is full, extra tokens will overflow.</li>
</ul>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified system illustrating a resource management concept, possibly related to buffer management or rate limiting in system design.  A vertical, dark-bordered rectangle depicts a source, containing three stacked, gold coin-like icons representing units of a resource.  A downward-pointing arrow labeled 'refill...' connects this source to a dark-green bucket, symbolizing a storage or buffer.  Inside the bucket are four stacked coins, indicating the existing resource level.  A horizontal arrow labeled 'overfill...' extends from the bucket to a single coin outside the bucket, suggesting an overflow mechanism where excess resources beyond the bucket's capacity are expelled.  The overall arrangement shows a resource being added to a limited-capacity container ('refill'), with excess resources being discarded ('overfill') when the container's capacity is exceeded. The text 'Viewer does not support full SVG 1.1' at the bottom is a browser-related message unrelated to the diagram's core meaning." loading="lazy" width="220" height="229" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/system-design-interview/design-a-rate-limiter/figure-4-4-37HFRAED.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 4</figcaption></div></figure>
<ul>
<li>
<p>Each request consumes one token. When a request arrives, we check if there are enough tokens in the bucket. Figure 5 explains how it works.</p>
</li>
<li>
<p>If there are enough tokens, we take one token out for each request, and the request goes through.</p>
</li>
<li>
<p>If there are not enough tokens, the request is dropped.</p>
</li>
</ul>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system for managing requests and tokens.  A block labeled 'requests' sends requests to a decision point represented by a diamond labeled 'enough tokens?'.  This decision point checks the level of tokens in a green bucket, which represents a token pool.  Tokens are added to the bucket via a downward-pointing arrow labeled 'refill...', showing a stack of gold coins. If there are 'enough tokens?', a line labeled 'yes,...' leads to a block representing successful processing, showing a stack of gold coins and light-blue rectangles, likely representing processed requests. If there are not 'enough tokens?', a line labeled 'no,...' leads to a block indicating an error: 'Viewer does not support full SVG 1.1', suggesting a limitation in handling the request due to insufficient tokens.  The overall flow depicts a token-based request processing system where requests are processed only if sufficient tokens are available in the pool, otherwise resulting in an error message." loading="lazy" width="500" height="431" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/system-design-interview/design-a-rate-limiter/figure-4-5-FGZ35C5S.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 5</figcaption></div></figure>
<p>Figure 6 illustrates how token consumption, refill, and rate limiting logic work. In this example, the token bucket size is 4, and the refill rate is 4 per 1 minute.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a diagram illustrating a token-based rate limiting system across four different time points.  The diagram shows four numbered rectangular boxes, each representing a system's state at a specific time.  Box 1 (1:00:00) shows an incoming 'request' arrow pointing to a box containing four coin icons, representing four available tokens. An outgoing arrow then points to Box 2. Box 2 (1:00:05) depicts three incoming 'request' arrows consuming three of the initial tokens (three coin icons remain). Three outgoing arrows then branch out. Box 3 (1:00:20) shows an incoming 'request' arrow pointing to an empty box (zero tokens), indicating a request that will be delayed or rejected due to token depletion. Finally, Box 4 (1:01:00) shows four tokens replenished, suggesting a refill mechanism after a certain time interval.  The text below each box provides additional context, specifying the number of tokens available at the start and the outcome of the requests.  The arrows represent the flow of requests, and the coins visually represent the available tokens within the rate limiting system." loading="lazy" width="500" height="542" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/system-design-interview/design-a-rate-limiter/figure-4-6-STPNU6NF.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 6</figcaption></div></figure>
<p>The token bucket algorithm takes two parameters:</p>
<ul>
<li>
<p>Bucket size: the maximum number of tokens allowed in the bucket</p>
</li>
<li>
<p>Refill rate: number of tokens put into the bucket every second</p>
</li>
</ul>
<p>How many buckets do we need? This varies, and it depends on the rate-limiting rules. Here are a few examples.</p>
<ul>
<li>
<p>It is usually necessary to have different buckets for different API endpoints. For instance, if a user is allowed to make 1 post per second, add 150 friends per day, and like 5 posts per second, 3 buckets are required for each user.</p>
</li>
<li>
<p>If we need to throttle requests based on IP addresses, each IP address requires a bucket.</p>
</li>
<li>
<p>If the system allows a maximum of 10,000 requests per second, it makes sense to have a global bucket shared by all requests.</p>
</li>
</ul>
<p>Pros:</p>
<ul>
<li>
<p>The algorithm is easy to implement.</p>
</li>
<li>
<p>Memory efficient.</p>
</li>
<li>
<p>Token bucket allows a burst of traffic for short periods. A request can go through as long as there are tokens left.</p>
</li>
</ul>
<p>Cons:</p>
<ul>
<li>Two parameters in the algorithm are bucket size and token refill rate. However, it might be challenging to tune them properly.</li>
</ul>
<h4 id="leaking-bucket-algorithm">Leaking bucket algorithm</h4>
<p>The leaking bucket algorithm is similar to the token bucket except that requests are processed at a fixed rate. It is usually implemented with a first-in-first-out (FIFO) queue. The algorithm works as follows:</p>
<ul>
<li>
<p>When a request arrives, the system checks if the queue is full. If it is not full, the request is added to the queue.</p>
</li>
<li>
<p>Otherwise, the request is dropped.</p>
</li>
<li>
<p>Requests are pulled from the queue and processed at regular intervals.</p>
</li>
</ul>
<p>Figure 7 explains how the algorithm works.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system for processing requests using a rate-limiting mechanism.  A group of incoming requests, depicted as several light-blue rectangles within a dashed box labeled 'requests,' are fed into a decision diamond labeled 'bucket full?'. If the bucket is not full ('no' branch), the requests enter a queue represented as a rectangle divided into sections, some filled light-blue and some white, labeled 'queue.'  This queue suggests a buffer holding requests before processing.  From the queue, requests are 'processed at a fixed rate,' indicated by an arrow leading to another group of light-blue rectangles within a dashed box labeled 'requests go through,' signifying processed requests. If the bucket is full ('yes' branch), the requests are directed to a grayed-out area at the bottom, labeled with the text 'Viewer does not support full SVG 1.1,' suggesting a rejection or alternative handling path due to a limitation.  The overall diagram illustrates a system that manages incoming requests, buffering them in a queue, and processing them at a controlled rate to prevent overload." loading="lazy" width="650" height="202" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/system-design-interview/design-a-rate-limiter/figure-4-7-AI26NI2Y.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 7</figcaption></div></figure>
<p>Leaking bucket algorithm takes the following two parameters:</p>
<ul>
<li>
<p>Bucket size: it is equal to the queue size. The queue holds the requests to be processed at a fixed rate.</p>
</li>
<li>
<p>Outflow rate: it defines how many requests can be processed at a fixed rate, usually in seconds.</p>
</li>
</ul>
<p>Shopify, an ecommerce company, uses leaky buckets for rate-limiting [7].</p>
<p>Pros:</p>
<ul>
<li>
<p>Memory efficient given the limited queue size.</p>
</li>
<li>
<p>Requests are processed at a fixed rate therefore it is suitable for use cases that a stable outflow rate is needed.</p>
</li>
</ul>
<p>Cons:</p>
<ul>
<li>
<p>A burst of traffic fills up the queue with old requests, and if they are not processed in time, recent requests will be rate limited.</p>
</li>
<li>
<p>There are two parameters in the algorithm. It might not be easy to tune them properly.</p>
</li>
</ul>
<h4 id="fixed-window-counter-algorithm">Fixed window counter algorithm</h4>
<p>Fixed window counter algorithm works as follows:</p>
<ul>
<li>
<p>The algorithm divides the timeline into fix-sized time windows and assign a counter for each window.</p>
</li>
<li>
<p>Each request increments the counter by one.</p>
</li>
<li>
<p>Once the counter reaches the pre-defined threshold, new requests are dropped until a new time window starts.</p>
</li>
</ul>
<p>Let us use a concrete example to see how it works. In Figure 8, the time unit is 1 second and the system allows a maximum of 3 requests per second. In each second window, if more than 3 requests are received, extra requests are dropped as shown in Figure 8.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a time-series chart visualizing the number of successful and rate-limited requests over a five-minute interval. The horizontal axis represents time, marked at one-minute intervals from 1:00:00 to 1:00:04. The vertical axis represents the number of requests.  Each rectangle represents a single request; light gray rectangles denote rate-limited requests, while white rectangles represent successful requests.  The chart shows a fluctuating pattern: at 1:00:00, there are three successful requests; at 1:00:01, there are three successful requests and three rate-limited requests; at 1:00:02, there are three successful requests and one rate-limited request; at 1:00:03, there is one successful request; and at 1:00:04, there are three successful requests and two rate-limited requests.  The legend clearly distinguishes between successful and rate-limited requests.  The bottom right corner displays a message indicating that the viewer does not support full SVG 1.1." loading="lazy" width="631" height="350" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/system-design-interview/design-a-rate-limiter/figure-4-8-WZZYUXFU.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 8</figcaption></div></figure>
<p>A major problem with this algorithm is that a burst of traffic at the edges of time windows could cause more requests than allowed quota to go through. Consider the following case:</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a time-series chart illustrating request distribution over a period of two minutes.  A horizontal timeline runs from 2:00:00 to 2:02:00, marked with vertical lines at each minute.  Within a dashed-line box spanning from approximately 2:00:30 to 2:01:30, light-blue rectangles represent individual requests.  The rectangles are stacked vertically to show multiple requests occurring at roughly the same time.  A total of ten requests are shown, indicated by a double-headed arrow above the box labeled '10 requests'.  The requests are not uniformly distributed; some time intervals have more requests than others.  Below the chart, the text 'Viewer does not support full SVG 1.1' suggests a possible limitation or constraint related to the data visualization." loading="lazy" width="496" height="210" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/system-design-interview/design-a-rate-limiter/figure-4-9-52MK6L22.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 9</figcaption></div></figure>
<p>In Figure 9, the system allows a maximum of 5 requests per minute, and the available quota resets at the human-friendly round minute. As seen, there are five requests between 2:00:00 and 2:01:00 and five more requests between 2:01:00 and 2:02:00. For the one-minute window between 2:00:30 and 2:01:30, 10 requests go through. That is twice as many as allowed requests.</p>
<p>Pros:</p>
<ul>
<li>
<p>Memory efficient.</p>
</li>
<li>
<p>Easy to understand.</p>
</li>
<li>
<p>Resetting available quota at the end of a unit time window fits certain use cases.</p>
</li>
</ul>
<p>Cons:</p>
<ul>
<li>Spike in traffic at the edges of a window could cause more requests than the allowed quota to go through.</li>
</ul>
<h4 id="sliding-window-log-algorithm">Sliding window log algorithm</h4>
<p>As discussed previously, the fixed window counter algorithm has a major issue: it allows more requests to go through at the edges of a window. The sliding window log algorithm fixes the issue. It works as follows:</p>
<ul>
<li>
<p>The algorithm keeps track of request timestamps. Timestamp data is usually kept in cache, such as sorted sets of Redis [8].</p>
</li>
<li>
<p>When a new request comes in, remove all the outdated timestamps. Outdated timestamps are defined as those older than the start of the current time window.</p>
</li>
<li>
<p>Add timestamp of the new request to the log.</p>
</li>
<li>
<p>If the log size is the same or lower than the allowed count, a request is accepted. Otherwise, it is rejected.</p>
</li>
</ul>
<p>We explain the algorithm with an example as revealed in Figure 10.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a flowchart illustrating a rate-limiting system that allows only two requests per minute.  The flowchart shows four stages (numbered 1-4).  Each stage is a rectangular box representing a processing unit.  Arrows indicate the flow of requests, with timestamps indicating the time of each request. Stage 1 receives a request at 1:00:01 and forwards it. Stage 2 receives this request at 1:00:30 (implying a processing delay) and forwards it.  Stage 3 receives a request at 1:00:50 and forwards it. Stage 4 receives requests at 1:00:01 and 1:00:30 (highlighted in red to indicate they are within the rate limit), and then receives another request at 1:01:40, which is processed.  The timestamps within each stage show the arrival times of requests at that stage. The title 'Allow 2 requests per minute' clarifies the system's constraint.  The diagram demonstrates how the system handles requests within and exceeding the rate limit, showing that requests exceeding the limit are still processed but with a delay." loading="lazy" width="493" height="409" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/system-design-interview/design-a-rate-limiter/figure-4-10-AI6H6IIX.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 10</figcaption></div></figure>
<p>In this example, the rate limiter allows 2 requests per minute. Usually, Linux timestamps are stored in the log. However, human-readable representation of time is used in our example for better readability.</p>
<ul>
<li>
<p>The log is empty when a new request arrives at 1:00:01. Thus, the request is allowed.</p>
</li>
<li>
<p>A new request arrives at 1:00:30, the timestamp 1:00:30 is inserted into the log. After the insertion, the log size is 2, not larger than the allowed count. Thus, the request is allowed.</p>
</li>
<li>
<p>A new request arrives at 1:00:50, and the timestamp is inserted into the log. After the insertion, the log size is 3, larger than the allowed size 2. Therefore, this request is rejected even though the timestamp remains in the log.</p>
</li>
<li>
<p>A new request arrives at 1:01:40. Requests in the range [1:00:40,1:01:40) are within the latest time frame, but requests sent before 1:00:40 are outdated. Two outdated timestamps, 1:00:01 and 1:00:30, are removed from the log. After the remove operation, the log size becomes 2; therefore, the request is accepted.</p>
</li>
</ul>
<p>Pros:</p>
<ul>
<li>Rate limiting implemented by this algorithm is very accurate. In any rolling window, requests will not exceed the rate limit.</li>
</ul>
<p>Cons:</p>
<ul>
<li>The algorithm consumes a lot of memory because even if a request is rejected, its timestamp might still be stored in memory.</li>
</ul>
<h4 id="sliding-window-counter-algorithm">Sliding window counter algorithm</h4>
<p>The sliding window counter algorithm is a hybrid approach that combines the fixed window counter and sliding window log. The algorithm can be implemented by two different approaches. We will explain one implementation in this section and provide reference for the other implementation at the end of the section. Figure 11 illustrates how this algorithm works.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a graphical depiction of a rolling rate limiter.  The horizontal axis represents time, divided into 'previous minute' and 'current minute' segments. The vertical axis represents the number of requests. A light-green rectangle labeled 'Rolling minute' spans across the boundary of the previous and current minutes, with 70% of its area in the previous minute and 30% in the current minute. This represents a rolling window of one minute. Within the rolling minute rectangle, several light-blue rectangles represent individual requests. A black rectangle encloses the requests within the previous minute, while a light-blue rectangle encloses the requests within the current minute. An arrow points from the top to the 'Rolling minute' rectangle, labeled 'Current time,' indicating the current position within the rolling window.  A text annotation states 'Rate limit: 5 requests/min,' indicating the maximum allowed requests per minute.  The diagram visually demonstrates how requests are counted within a rolling one-minute window to enforce the rate limit." loading="lazy" width="600" height="352" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/system-design-interview/design-a-rate-limiter/figure-4-11-R2MDCFXL.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 11</figcaption></div></figure>
<p>Assume the rate limiter allows a maximum of 7 requests per minute, and there are 5 requests in the previous minute and 3 in the current minute. For a new request that arrives at a 30% position in the current minute, the number of requests in the rolling window is calculated using the following formula:</p>
<ul>
<li>
<p>Requests in current window <strong>+</strong> requests in the previous window <strong>*</strong> overlap percentage of the rolling window and previous window</p>
</li>
<li>
<p>Using this formula, we get 3 + 5 * 0.7% = 6.5 request. Depending on the use case, the number can either be rounded up or down. In our example, it is rounded down to 6.</p>
</li>
</ul>
<p>Since the rate limiter allows a maximum of 7 requests per minute, the current request can go through. However, the limit will be reached after receiving one more request.</p>
<p>Due to the space limitation, we will not discuss the other implementation here. Interested readers should refer to the reference material [9]. This algorithm is not perfect. It has pros and cons.</p>
<p>Pros</p>
<ul>
<li>
<p>It smooths out spikes in traffic because the rate is based on the average rate of the previous window.</p>
</li>
<li>
<p>Memory efficient.</p>
</li>
</ul>
<p>Cons</p>
<ul>
<li>It only works for not-so-strict look back window. It is an approximation of the actual rate because it assumes requests in the previous window are evenly distributed. However, this problem may not be as bad as it seems. According to experiments done by Cloudflare [10], only 0.003% of requests are wrongly allowed or rate limited among 400 million requests.</li>
</ul>
<h3 id="high-level-architecture">High-level architecture</h3>
<p>The basic idea of rate limiting algorithms is simple. At the high-level, we need a counter to keep track of how many requests are sent from the same user, IP address, etc. If the counter is larger than the limit, the request is disallowed.</p>
<p>Where shall we store counters? Using the database is not a good idea due to slowness of disk access. In-memory cache is chosen because it is fast and supports time-based expiration strategy. For instance, Redis [11] is a popular option to implement rate limiting. It is an in-memory store that offers two commands: INCR and EXPIRE.</p>
<ul>
<li>
<p>INCR: It increases the stored counter by 1.</p>
</li>
<li>
<p>EXPIRE: It sets a timeout for the counter. If the timeout expires, the counter is automatically deleted.</p>
</li>
</ul>
<p>Figure 12 shows the high-level architecture for rate limiting, and this works as follows:</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system architecture diagram illustrating a client-server interaction with rate limiting.  A rectangular box labeled 'Client' contains icons representing a laptop and a mobile phone, signifying various client devices.  A solid blue arrow connects the Client to a light-blue hexagonal box labeled 'Rate limiter middleware,' indicating that client requests first pass through this rate-limiting component.  From the rate limiter, another solid blue arrow points to a dashed-line box labeled 'API Servers,' depicted as three vertically stacked green server icons, representing the backend application servers handling client requests.  Finally, a solid blue arrow extends from the rate limiter to a red, three-layered cube labeled 'Redis,' suggesting that the rate limiter uses Redis, an in-memory data store, to track and manage request rates.  The arrows indicate the unidirectional flow of requests, with the API Servers potentially sending responses back through the rate limiter to the client (though this return path isn't explicitly shown)." loading="lazy" width="550" height="217" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(550px, 100vw), (max-width: 1200px) min(550px, 80vw), min(550px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-12-HDGSAAHQ.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-12-HDGSAAHQ.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-12-HDGSAAHQ.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-12-HDGSAAHQ.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-12-HDGSAAHQ.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-12-HDGSAAHQ.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-12-HDGSAAHQ.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-12-HDGSAAHQ.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-12-HDGSAAHQ.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 12</figcaption></div></figure>
<ul>
<li>
<p>The client sends a request to rate limiting middleware.</p>
</li>
<li>
<p>Rate limiting middleware fetches the counter from the corresponding bucket in Redis and checks if the limit is reached or not.</p>
</li>
<li>
<p>If the limit is reached, the request is rejected.</p>
</li>
<li>
<p>If the limit is not reached, the request is sent to API servers. Meanwhile, the system increments the counter and saves it back to Redis.</p>
</li>
</ul>
<h2 id="step-3---design-deep-dive">Step 3 - Design deep dive</h2>
<p>The high-level design in Figure 12 does not answer the following questions:</p>
<ul>
<li>
<p>How are rate limiting rules created? Where are the rules stored?</p>
</li>
<li>
<p>How to handle requests that are rate limited?</p>
</li>
</ul>
<p>In this section, we will first answer the questions regarding rate limiting rules and then go over the strategies to handle rate-limited requests. Finally, we will discuss rate limiting in distributed environment, a detailed design, performance optimization and monitoring.</p>
<h3 id="rate-limiting-rules">Rate limiting rules</h3>
<p>Lyft open-sourced their rate-limiting component [12]. We will peek inside of the component and look at some examples of rate limiting rules:</p>
<pre><code>domain: messaging
descriptors:
  - key: message_type
    value: marketing
    rate_limit:
      unit: day
      requests_per_unit: 5
</code></pre>
<p>In the above example, the system is configured to allow a maximum of 5 marketing messages per day. Here is another example:</p>
<pre><code>domain: auth
descriptors:
  - key: auth_type
    value: login
    rate_limit:
      unit: minute
      requests_per_unit: 5
</code></pre>
<p>This rule shows that clients are not allowed to login more than 5 times in 1 minute. Rules are generally written in configuration files and saved on disk.</p>
<h3 id="exceeding-the-rate-limit">Exceeding the rate limit</h3>
<p>In case a request is rate limited, APIs return a HTTP response code 429 (too many requests) to the client. Depending on the use cases, we may enqueue the rate-limited requests to be processed later. For example, if some orders are rate limited due to system overload, we may keep those orders to be processed later.</p>
<h4 id="rate-limiter-headers">Rate limiter headers</h4>
<p>How does a client know whether it is being throttled? And how does a client know the number of allowed remaining requests before being throttled? The answer lies in HTTP response headers. The rate limiter returns the following HTTP headers to clients:</p>
<pre><code>X-Ratelimit-Remaining: The remaining number of allowed requests within the window.

X-Ratelimit-Limit: It indicates how many calls the client can make per time window.

X-Ratelimit-Retry-After: The number of seconds to wait until you can make a request again without being throttled.
</code></pre>
<p>When a user has sent too many requests, a 429 too many requests error and <em>X-Ratelimit-Retry-After</em> header are returned to the client.</p>
<h3 id="detailed-design">Detailed design</h3>
<p>Figure 13 presents a detailed design of the system.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system architecture diagram illustrating API request handling and rate limiting.  A client (represented by laptop and phone icons) sends requests to a Rate Limiter middleware.  If the request is within the rate limits, the middleware labels it 'success' and forwards it to a CACHE, which contains 'Cached rules'. The CACHE forwards the request to a set of API Servers.  If the request is not cached, the API Servers process it and store the result in Redis.  If the request exceeds the rate limits, the middleware labels it 'rate limited' and the request is handled in one of two ways:  option 1, the request is dropped (represented by a circle), or option 2, the request is sent to a Message queue for later processing.  A 'Rules' box sits above the 'Workers' (which feed the CACHE), indicating that the rate limiting rules originate from this source.  The system returns a '429: too many requests' error to the client if rate limiting is exceeded." loading="lazy" width="750" height="595" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(750px, 100vw), (max-width: 1200px) min(750px, 80vw), min(750px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-13-G2VF2RCQ.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-13-G2VF2RCQ.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-13-G2VF2RCQ.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-13-G2VF2RCQ.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-13-G2VF2RCQ.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-13-G2VF2RCQ.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-13-G2VF2RCQ.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-13-G2VF2RCQ.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-13-G2VF2RCQ.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 13</figcaption></div></figure>
<ul>
<li>
<p>Rules are stored on the disk. Workers frequently pull rules from the disk and store them in the cache.</p>
</li>
<li>
<p>When a client sends a request to the server, the request is sent to the rate limiter middleware first.</p>
</li>
<li>
<p>Rate limiter middleware loads rules from the cache. It fetches counters and last request timestamp from Redis cache. Based on the response, the rate limiter decides:</p>
</li>
<li>
<p>if the request is not rate limited, it is forwarded to API servers.</p>
</li>
<li>
<p>if the request is rate limited, the rate limiter returns 429 too many requests error to the client. In the meantime, the request is either dropped or forwarded to the queue.</p>
</li>
</ul>
<h3 id="rate-limiter-in-a-distributed-environment">Rate limiter in a distributed environment</h3>
<p>Building a rate limiter that works in a single server environment is not difficult. However, scaling the system to support multiple servers and concurrent threads is a different story. There are two challenges:</p>
<ul>
<li>
<p>Race condition</p>
</li>
<li>
<p>Synchronization issue</p>
</li>
</ul>
<h4 id="race-condition">Race condition</h4>
<p>As discussed earlier, rate limiter works as follows at the high-level:</p>
<ul>
<li>
<p>Read the <em>counter</em> value from Redis.</p>
</li>
<li>
<p>Check if (<em>counter + 1</em>) exceeds the threshold.</p>
</li>
<li>
<p>If not, increment the counter value by 1 in Redis.</p>
</li>
</ul>
<p>Race conditions can happen in a highly concurrent environment as shown in Figure 14.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a diagram illustrating a race condition in a counter system.  The diagram shows two independent requests, labeled 'request 1' and 'request 2,' each initiating a sequence of operations.  Both requests first call a 'read_counter' function, which returns the current counter value (initially 3).  Next, both requests proceed to a 'check_and_increment' function.  The 'check_and_increment' function, in this example, appears to read the counter value, then increment it.  Request 1 reads 3, increments to 4, and updates the counter. Request 2 concurrently reads 3, increments to 4, and updates the counter.  The final counter value is 4, but the expected value after two increments from an initial value of 3 should be 5.  This discrepancy highlights the race condition: the counter's value is not atomically updated, leading to an incorrect final result.  The diagram visually depicts the flow of requests and the counter's value at each stage, clearly showing the concurrent operations and the resulting inconsistency." loading="lazy" width="651" height="341" decoding="async" data-nimg="1" src="https://bytebytego.com/images/courses/system-design-interview/design-a-rate-limiter/figure-4-14-VGQOSEYS.svg" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 14</figcaption></div></figure>
<p>Assume the <em>counter</em> value in Redis is 3. If two requests concurrently read the <em>counter</em> value before either of them writes the value back, each will increment the <em>counter</em> by one and write it back without checking the other thread. Both requests (threads) believe they have the correct <em>counter</em> value 4. However, the correct <em>counter</em> value should be 5.</p>
<p>Locks are the most obvious solution for solving race condition. However, locks will significantly slow down the system. Two strategies are commonly used to solve the problem: Lua script [13] and sorted sets data structure in Redis [8]. For readers interested in these strategies, refer to the corresponding reference materials [8] [13].</p>
<h4 id="synchronization-issue">Synchronization issue</h4>
<p>Synchronization is another important factor to consider in a distributed environment. To support millions of users, one rate limiter server might not be enough to handle the traffic. When multiple rate limiter servers are used, synchronization is required. For example, on the left side of Figure 15, client 1 sends requests to rate limiter 1, and client 2 sends requests to rate limiter 2. As the web tier is stateless, clients can send requests to a different rate limiter as shown on the right side of Figure 15. If no synchronization happens, rate limiter 1 does not contain any data about client 2. Thus, the rate limiter cannot work properly.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents two different system architectures for handling rate limiting.  The left side shows a simpler design where two clients (Client 1 and Client 2), each represented by a laptop and a mobile phone icon within a rounded rectangle labeled with the client number, independently connect to their respective rate limiters.  Each rate limiter, depicted as a light-blue hexagon labeled 'Rate limiter 1' and 'Rate limiter 2' respectively, processes requests from its assigned client.  A unidirectional arrow indicates the flow of requests from the client to the corresponding rate limiter. The right side illustrates a more complex architecture where the same two clients now connect to both rate limiters.  Client 1 sends requests to both 'Rate limiter 1' and 'Rate limiter 2,' and similarly, Client 2 sends requests to both rate limiters.  The connections are represented by unidirectional arrows showing the flow of requests from each client to both rate limiters.  The dashed lines around each system suggest separate deployments or logical groupings." loading="lazy" width="600" height="186" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(600px, 100vw), (max-width: 1200px) min(600px, 80vw), min(600px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-15-Q55WVCBS.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-15-Q55WVCBS.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-15-Q55WVCBS.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-15-Q55WVCBS.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-15-Q55WVCBS.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-15-Q55WVCBS.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-15-Q55WVCBS.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-15-Q55WVCBS.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-15-Q55WVCBS.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 15</figcaption></div></figure>
<p>One possible solution is to use sticky sessions that allow a client to send traffic to the same rate limiter. This solution is not advisable because it is neither scalable nor flexible. A better approach is to use centralized data stores like Redis. The design is shown in Figure 16.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a system architecture diagram illustrating rate limiting using Redis.  Two clients, labeled 'Client 1' and 'Client 2,' each represented by icons of a laptop and a mobile phone within light-blue rectangular boxes, send requests. Each client's requests pass through a separate rate limiter, depicted as light-blue hexagons labeled 'Rate limiter 1' and 'Rate limiter 2' respectively.  Thick blue arrows indicate the flow of requests.  Both rate limiters then send information to a central Redis database, represented by a red, three-layered cube with geometric shapes on top, labeled 'Redis.'  The arrows show that both rate limiters send data to the same Redis instance.  The overall diagram shows a client-rate limiter-database architecture where the rate limiters manage the flow of requests from multiple clients to a shared Redis database, likely for managing request frequency and preventing abuse." loading="lazy" width="600" height="233" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(600px, 100vw), (max-width: 1200px) min(600px, 80vw), min(600px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-16-JQMOMJUG.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-16-JQMOMJUG.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-16-JQMOMJUG.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-16-JQMOMJUG.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-16-JQMOMJUG.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-16-JQMOMJUG.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-16-JQMOMJUG.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-16-JQMOMJUG.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-16-JQMOMJUG.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 16</figcaption></div></figure>
<h3 id="performance-optimization">Performance optimization</h3>
<p>Performance optimization is a common topic in system design interviews. We will cover two areas to improve.</p>
<p>First, multi-data center setup is crucial for a rate limiter because latency is high for users located far away from the data center. Most cloud service providers build many edge server locations around the world. For example, as of 5/20 2020, Cloudflare has 194 geographically distributed edge servers [14]. Traffic is automatically routed to the closest edge server to reduce latency.</p>
<figure class="py-1"><div style="display: flex; justify-content: center;"><img alt="Image represents a simplified map, possibly of a geographical region, showing the distribution of data points or resources.  The map is primarily light blue, depicting landmasses with irregular boundaries. Scattered across these landmasses are numerous light purple circles with white outlines, suggesting locations of individual entities or data points.  A single, larger light purple circle with a white outline is located on one of the landmasses, and a dark grey circle is situated to its left. A black arrow points from the grey circle directly towards the larger light purple circle, indicating a flow of information or a connection between these two points. The grey circle might represent a source or origin, while the larger purple circle could be a destination or central point receiving data. The smaller purple circles are distributed across both landmasses, suggesting a network or cluster of related entities.  The overall arrangement suggests a client-server or data aggregation model, where data from multiple sources (smaller purple circles) might be collected and processed at a central location (larger purple circle), potentially originating from a specific source (grey circle)." loading="lazy" width="400" height="236" decoding="async" data-nimg="1" sizes="(max-width: 840px) min(400px, 100vw), (max-width: 1200px) min(400px, 80vw), min(400px, 80vw)" srcset="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-17-AWRJL2OI.png&amp;w=640&amp;q=75 640w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-17-AWRJL2OI.png&amp;w=750&amp;q=75 750w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-17-AWRJL2OI.png&amp;w=828&amp;q=75 828w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-17-AWRJL2OI.png&amp;w=1080&amp;q=75 1080w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-17-AWRJL2OI.png&amp;w=1200&amp;q=75 1200w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-17-AWRJL2OI.png&amp;w=1920&amp;q=75 1920w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-17-AWRJL2OI.png&amp;w=2048&amp;q=75 2048w, https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-17-AWRJL2OI.png&amp;w=3840&amp;q=75 3840w" src="https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fdesign-a-rate-limiter%2Ffigure-4-17-AWRJL2OI.png&amp;w=3840&amp;q=75" style="color: transparent;"></div><div style="display: flex; justify-content: center;"><figcaption class="py-1">Figure 17 (Source: [10])</figcaption></div></figure>
<p>Second, synchronize data with an eventual consistency model. If you are unclear about the eventual consistency model, refer to the “Consistency” section in the “Design a Key-value Store” chapter.</p>
<h3 id="monitoring">Monitoring</h3>
<p>After the rate limiter is put in place, it is important to gather analytics data to check whether the rate limiter is effective. Primarily, we want to make sure:</p>
<ul>
<li>
<p>The rate limiting algorithm is effective.</p>
</li>
<li>
<p>The rate limiting rules are effective.</p>
</li>
</ul>
<p>For example, if rate limiting rules are too strict, many valid requests are dropped. In this case, we want to relax the rules a little bit. In another example, we notice our rate limiter becomes ineffective when there is a sudden increase in traffic like flash sales. In this scenario, we may replace the algorithm to support burst traffic. Token bucket is a good fit here.</p>
<h2 id="step-4---wrap-up">Step 4 - Wrap up</h2>
<p>In this chapter, we discussed different algorithms of rate limiting and their pros/cons. Algorithms discussed include:</p>
<ul>
<li>
<p>Token bucket</p>
</li>
<li>
<p>Leaking bucket</p>
</li>
<li>
<p>Fixed window</p>
</li>
<li>
<p>Sliding window log</p>
</li>
<li>
<p>Sliding window counter</p>
</li>
</ul>
<p>Then, we discussed the system architecture, rate limiter in a distributed environment, performance optimization and monitoring. Similar to any system design interview questions, there are additional talking points you can mention if time allows:</p>
<ul>
<li>
<p>Hard vs soft rate limiting.</p>
</li>
<li>
<p>Hard: The number of requests cannot exceed the threshold.</p>
</li>
<li>
<p>Soft: Requests can exceed the threshold for a short period.</p>
</li>
<li>
<p>Rate limiting at different levels. In this chapter, we only talked about rate limiting at the application level (HTTP: layer 7). It is possible to apply rate limiting at other layers. For example, you can apply rate limiting by IP addresses using Iptables [15] (IP: layer 3). Note: The Open Systems Interconnection model (OSI model) has 7 layers [16]: Layer 1: Physical layer, Layer 2: Data link layer, Layer 3: Network layer, Layer 4: Transport layer, Layer 5: Session layer, Layer 6: Presentation layer, Layer 7: Application layer.</p>
</li>
<li>
<p>Avoid being rate limited. Design your client with best practices:</p>
</li>
<li>
<p>Use client cache to avoid making frequent API calls.</p>
</li>
<li>
<p>Understand the limit and do not send too many requests in a short time frame.</p>
</li>
<li>
<p>Include code to catch exceptions or errors so your client can gracefully recover from exceptions.</p>
</li>
<li>
<p>Add sufficient back off time to retry logic.</p>
</li>
</ul>
<p>Congratulations on getting this far! Now give yourself a pat on the back. Good job!</p>
<h2 id="reference-materials">Reference materials</h2>
<p>[1] Rate-limiting strategies and techniques:<br>
<a href="https://cloud.google.com/solutions/rate-limiting-strategies-techniques" target="_blank" rel="noopener noreferrer"><u>https://cloud.google.com/solutions/rate-limiting-strategies-techniques</u></a></p>
<p>[2] Twitter rate limits: <a href="https://developer.twitter.com/en/docs/basics/rate-limits" target="_blank" rel="noopener noreferrer"><u>https://developer.twitter.com/en/docs/basics/rate-limits</u></a></p>
<p>[3] Google docs usage limits: <a href="https://developers.google.com/docs/api/limits" target="_blank" rel="noopener noreferrer"><u>https://developers.google.com/docs/api/limits</u></a></p>
<p>[4] IBM microservices: <a href="https://www.ibm.com/cloud/learn/microservices" target="_blank" rel="noopener noreferrer"><u>https://www.ibm.com/cloud/learn/microservices</u></a></p>
<p>[5] Throttle API requests for better throughput:<br>
<a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html" target="_blank" rel="noopener noreferrer"><u>https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html</u></a></p>
<p>[6] Stripe rate limiters: <a href="https://stripe.com/blog/rate-limiters" target="_blank" rel="noopener noreferrer"><u>https://stripe.com/blog/rate-limiters</u></a></p>
<p>[7] Shopify REST Admin API rate limits:<br>
<a href="https://help.shopify.com/en/api/reference/rest-admin-api-rate-limits" target="_blank" rel="noopener noreferrer"><u>https://help.shopify.com/en/api/reference/rest-admin-api-rate-limits</u></a></p>
<p>[8] Better Rate Limiting With Redis Sorted Sets:<br>
<a href="https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/" target="_blank" rel="noopener noreferrer"><u>https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/</u></a></p>
<p>[9] System Design — Rate limiter and Data modelling:<br>
<a href="https://medium.com/@saisandeepmopuri/system-design-rate-limiter-and-data-modelling-9304b0d18250" target="_blank" rel="noopener noreferrer"><u>https://medium.com/@saisandeepmopuri/system-design-rate-limiter-and-data-modelling-9304b0d18250</u></a></p>
<p>[10] How we built rate limiting capable of scaling to millions of domains:<br>
<a href="https://blog.cloudflare.com/counting-things-a-lot-of-different-things/" target="_blank" rel="noopener noreferrer"><u>https://blog.cloudflare.com/counting-things-a-lot-of-different-things/</u></a></p>
<p>[11] Redis website: <a href="https://redis.io/" target="_blank" rel="noopener noreferrer"><u>https://redis.io/</u></a></p>
<p>[12] Lyft rate limiting: <a href="https://github.com/lyft/ratelimit" target="_blank" rel="noopener noreferrer"><u>https://github.com/lyft/ratelimit</u></a></p>
<p>[13] Scaling your API with rate limiters:<br>
<a href="https://gist.github.com/ptarjan/e38f45f2dfe601419ca3af937fff574d#request-rate-limiter" target="_blank" rel="noopener noreferrer"><u>https://gist.github.com/ptarjan/e38f45f2dfe601419ca3af937fff574d#request-rate-limiter</u></a></p>
<p>[14] What is edge computing:<br>
<a href="https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/" target="_blank" rel="noopener noreferrer"><u>https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/</u></a></p>
<p>[15] Rate Limit Requests with Iptables: <a href="https://blog.programster.org/rate-limit-requests-with-iptables" target="_blank" rel="noopener noreferrer"><u>https://blog.programster.org/rate-limit-requests-with-iptables</u></a></p>
<p>[16] OSI model:<br>
<a href="https://en.wikipedia.org/wiki/OSI_model#Layer_architecture" target="_blank" rel="noopener noreferrer"><u>https://en.wikipedia.org/wiki/OSI_model#Layer_architecture</u></a></p>
        </article>
    </main>

    <div class="nav">
        <a href="../system-design-interview.html">← Course Contents</a>
        <a href="a-framework-for-system-design-interviews.html">← Previous</a>
        <a href="design-consistent-hashing.html">Next →</a>
    </div>

    <footer class="metadata">
        <p>Scraped on 10/10/2025</p>
    </footer>
</body>
</html>